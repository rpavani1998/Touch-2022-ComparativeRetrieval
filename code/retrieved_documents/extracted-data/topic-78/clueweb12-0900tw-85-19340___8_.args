in fact quicksort is a very elegant general purpose sorting algorithm and every developer should be familiar with its principles.there are faster algorithms for some sets of data types quicksort is beautiful because of the elegant idea behind its principles.if you have two sorted lists, one with items with a greater value from a given value and the other with items smaller form that given value, you can simply concatenate them and you can be sure that the resulting list will be sorted with no need of special merge.- iterative implementation isn’t easy - there are faster algorithms for some sets of data types quicksort is beautiful because of the elegant idea behind its principles.but recursion is dangerous sometimes, so an iterative approach is also available.the problem is that there’s not an easy way to get the middle element from a list and this will slow down the algorithm.as i said above, the recursive approach is something very natural for quicksort as it follows the divide and conquer principles.the good thing is that in practice with randomly generated lists there is not a high possibility to go into the worst case of quicksort.the thing is that in the worst case quicksort is not so effective and it’s practically as slow as bubble sort and insertion sort.more this section is brought to you in partnership with: when it comes to sorting items by comparing them, merge sort is one very natural approach.why using quicksort - recursive implementation is easy - in general its speed is same as merge sort – o(n*log(n))why using quicksort in general its speed is same as merge sort – o(n*log(n))array_push($stack, $left); } return $sorted; } // 1, 2, 3, 4, 5, 5, 6, 7, 8, 9 print_r(quicksort_iterative($list)); complexity the complexity of quicksort in the average case is o(n*log(n)) – same as merge sort.elegant solution with no tricky merging as merge sort why not using quicksort as slow as bubble sort in the worst case!first of all, the best choice for a pivot is the bottleneck.