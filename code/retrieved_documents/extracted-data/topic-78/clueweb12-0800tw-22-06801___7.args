insertion sort, bubble sort and shell sort are based on the comparison model.
so far so good, so let’s say we have a very large list of data, which we want to sort.
the good news is that this algorithm is fast, but not so difficult to implement and that sounds quite good from a developer’s point of view.
after sorting the smaller lists, which is supposed to be easier than sorting the entire initial list, we can try to merge the result into one sorted list.
insertion sort, bubble sort and shell sort are based on the comparison model.
we can start comparing the first items of the lists and than we can pop the smaller of them both and put it into a new list containing the merged (sorted) array.
the problem with these three algorithms is that their complexity is o(n2) so they are very slow.
the problem with these three algorithms is that their complexity is o(n2) so they are very slow.
so far so good, so let’s say we have a very large list of data, which we want to sort.
implementation the good news is that this algorithm is fast, but not so difficult to implement and that sounds quite good from a developer’s point of view.
we can start comparing the first items of the lists and than we can pop the smaller of them both and put it into a new list containing the merged (sorted) array.
however recursion can be bitter so you can go for a iterative solution.
if they remain too large, we can continue breaking them down until we get to something very easy to sort as shown on the diagram bellow.
if they remain too large, we can continue breaking them down until we get to something very easy to sort as shown on the diagram bellow.
after sorting the smaller lists, which is supposed to be easier than sorting the entire initial list, we can try to merge the result into one sorted list.
however recursion can be bitter so you can go for a iterative solution.
