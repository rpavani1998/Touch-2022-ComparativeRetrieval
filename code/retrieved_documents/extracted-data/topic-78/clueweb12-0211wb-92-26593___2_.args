in radix sort, one repeatedly partitions the objects based on one of the elements of the sequence, moving from least significant to most significant element of the sequence.a careful analysis will show you that if you use fewer steps, you won't have been able to compare each element to every other element (directly or indirectly).if each object to be sorted can be represented as a sequence of values (e.g., a sequence of digits in a decimal number, a sequence of characters in words, a sequence of bits in the binary representation of the object) and sorting can be based on that sequence, then it is possible to sort based on those sequences.as we learn some more data structures, we'll also learn some more sorting methods that depend on those data structures.if we know that the elements in our array are in a restricted range, we can do a sort that array without comparing and swapping, if we're willing to use some extra space.silly sort here is an interesting sorting algorithm that relies on limitations to the input to ensure quicker sorting.other sorting algorithms - as we learn some more data structures, we'll also learn some more sorting methods that depend on those data structures.- in radix sort, one repeatedly partitions the objects based on one of the elements of the sequence, moving from least significant to most significant element of the sequence.this can save some space, but may then require extra time.most often, we simply use bits for the partitioning, as these are easiest to check and use.we then step through our array, copying or moving each element to the appropriate bucket.(in the extreme case, we only use two buckets in each sort or subsort, giving us something close to quick sort.)in each round, we spend o(n) time taking stuff out of the vector (assuming that we can append to each bucket in constant time) and o(m+n) time putting stuff back into the vector.one (quicksort) is expected o(n*log_2(n)), but can behave significantly worse.- most often, we simply use bits for the partitioning, as these are easiest to check and use.