we’ll take a root note as an argument, so we can construct any major scale we like.
i was stumped on this one myself for a bit.
for example, why no whole tone between b and c, e and f?
ruby  passes objects by reference.
however, inside the method, i’m in a new scope.
ruby must notreally be passing a referece, right?
the circle of fifths.
aug 6th, 2010 for all the folks in #rubyonrails, and beyond.
i’m going to attempt to show another example, in case that’s helpful.
a : gcd(b, a % b); end; def rp(a, b); gcd(a, b)
[] tmp.each do |element|
finally, a hundred thousand element array; sorry for the lack of stats, but i was too impatient to let insertion_sort finish.
merge_sort([3], 2, 2): merge([2,5,3], 0, 2, 2): left <- [2,5,∞] right <- [3,∞] loop(0..2):
== 1; end or, indented: def gcd(a, b) b == 0 ?
this is  actually really cool; each scale, in addition to being unique in that, well, it  has a different root note, is unique in that it is the only scale to have its  specific number of sharps or flats.
no good; same exact problem.
note: i did take a liberty in the above listing of what’s happening; in actuality the entire array is passed each time; i made it look as though just the subarray were being passed in each case, because that is the only part that is being looked at in each nested section.
this is actually really cool; each scale, in addition to being unique in that, well, it has a different root note, is unique in that it is the only scale to have its specific number of sharps or flats.
[0, 7, 2, 9, 4, 11,  6, 1, 8, 3, 10, 5]
well, the main reason is that both of these methods are significantly slower than good old array::sort, which is built in to ruby (and which, as far as i know, is implemented using thequicksort algorithm).
g#/ab a#/bb b c#/db d#/eb f c#/db  d#/eb f f#/gb g#/ab a#/bb c g#/ab a#/bb c c#/db d#/eb f g d#/eb f g g#/ab a#/bb  c d a#/bb c d d#/eb f g a f g a a#/bb c d e not as neat as it could look since i put the #/b both in the original notes  array; the note you’d read would be the one with a consecutive letter  after the previous note.
[2,3,4,5,6] > # but wait >
merge sort (huge_array): 61.710000 11.990000 73.700000 ( 74.332743) ruby array::sort (huge_array): 0.020000 0.000000 0.020000 ( 0.020800) the interesting column is the last one: real, as in “real time” (more or less, taking into the account that we’re just benchmarking).
[0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5]
["c", "c#/db", "d",  "d#/eb", "e", "e#/f", "f#/gb",  "g", "g#/ab", "a", "a#/bb",  "b/cb"] =>
that’s all i have to say about that say it with me now: “ruby passes objects by reference.
a sharp or flat is added or removed each increment you  go around the circle.
but still, why structure the notes  this way?
well-tempered clavier (evidently there’s some dispute over whether or not bach’s intended tuning was equal or, uh, “well” tempered; i was not aware of this!)) and a 7 note major scale – neither of which are absolutely necessary, of course, and there are other ways to do it.
the same noteletter only appears  once in any given scale.
(0..11).map{|n| @notes[(n+root)%12]} ?
i thought you’d never ask.
h => {:bar =>"baz",:baz=>"qux"} > a =>
h => {:bar  =>"baz",:baz=>"qux"} > a =>
that way you aren’t actually modifying the original object.
( 0.027746) ruby array::sort (bigger_array): 0.000000 0.000000 0.000000 ( 0.000161) medium_array has 10,000 elements in it...
one does not simply walk into mordor oct 22nd, 2010 by land and by sea and by reference oct 6th, 2010 photo source i recently attempted to fit the quicksort algorithm into under 140  characters of ruby.
[4,∞] loop(3..4): [1,4] merge_sort([0], 5, 5): merge([1,4,0], 3, 5, 5): left <- [1,4,∞] right <- [0,∞] loop(3..5):
fun with the major scale aug 11th, 2010 got to chatting with nate (@fowlduck) about musical notation last night.
@jmchilton, who was a ta when i took structure of computer programming i (or whatever it was called; the scheme class) at the u of m, supplied this alternative solution to the relative prime problem: def gcd(a, b); b == 0 ?
so why is it c that has all natural notes (no sharps or flats)?
so, just calling major with no arguments should give us the c major scale; calling with, say, 5 should give us f major (5 in this case is the index of f in @notes; but you were already following that, i know): > major =>
insertion takes 0.24 seconds, merge takes 0.028, and sort!
our original objects were changed when they were  modified inside the method.
but still, why structure the notes this way?
, once again, is blowing them away at only 0.0016 seconds.
the octave consists of twelve semi-tones, in which the major scale is set in this pattern: whole tone, whole tone, semitone, whole tone, whole tone, whole tone, whole tone, semi-tone.
if element = pivot sub_sequence_b  greeting =
regardless, there we have it.
the merge sort is split into two parts; a merge method that acts as a helper, and the actual merge_sort which calls itself recursively, also calling merge when needed.
a b c#/db d e f#/gb g#/ab e f#/gb g#/ab a b c#/db  d#/eb b c#/db d#/eb e f#/gb g#/ab
it just got me thinking  about the major scale and the circle of fourths & fifths, which led to some  playing around on the command line, which led to this.
1 end in other words, it pays to know your math.
the same noteletter only appears once in any given scale.
[0,1,2,3,4, 5] (bold elements are the ones which were the “current” element moved back,italic elements are the ones that had to be shifted forward in this step.)
i could alter it, still: if i changed the reassign method so  that it didobj.replace("some new value!") inside the  method body, the original object would be changed, just likeshiftit did to the array and the hash.
this post is not meant to be a defense of music notation, a  “setting straight” of anything, or even a definitive description of  musical theory (at which i’m a rank amateur).
the answer comes down to the idea ofbindings and scope.
d e f#/gb g a b c#/db
the second chapter of introduction to algorithms by cormen, leiserson, et al., describes the algorithms for insertion sort and merge sort in pseudocode, and compares their relative efficiency (or lack thereof).
not content to simply feed it one sample, i fed it the text from several of the posts from the archive.
a b c#/db d e f#/gb g#/ab e f#/gb g#/ab a b c#/db d#/eb b c#/db d#/eb e f#/gb g#/ab
i know, i know, the faux motivational poster is an old and tired meme.
"bar", :bar => "baz", :baz =>
that part, to me at least, does seem arbitrary, but effectively it doesn’t matter.
let’s just say it would take awhile.
so, if you go around clockwise, you’re counting by fifths (g is the fifth note of the c major scale, d is the fifth note of the g major scale, etc) and if you go around counter-clockwise you’re counting by fourths (f is the fourth note of c, bb is the fourth note of f, etc).
in eb, the note following g is ab… and so on.
ruby quite definitely, always, passed objects by reference.
aug 4th, 2010 pic taken along the trail on the way from minneapolis to hopkins.
def shiftit(obj) obj.shift end #irb > h = {:foo =>
i don’t have any startling conclusions to close this off with.
there are a few reasons.
say it with me now: “ruby passes objects by reference.
even when i realized this was happening, i still made the mistake of just doing tmp = sequence on my first try.
it just got me thinking about the major scale and the circle of fourths & fifths, which led to some playing around on the command line, which led to this.
jul 29th, 2010 i gave a short presentation on rvm on monday at rum.
if you’re bothering to read this and it still isn’t clear, just run the sort locally and add some puts statements liberally so you can see what’s going on.
copyright © 2012 - phil crissman - powered by octopress
"c d e e#/f g a b/cb" > major(5)  =>
ruby quite definitely, always, passed objects by  reference.
clocking in at only 0.02 seconds.
given the above system, the major scale in one key and one key only will have no sharps or flats.
so we need 7 letters.
no, we’re not the stupid ones =>
the thing that makes it seem so strange is, at least in part, the major scale.
you’ll find that any method of modifying an object inside another method with actually change (even delete, if you go that far) the original object that you passed in.
(using quicksort) isway faster: only 0.000016 seconds.
seemathematics of musical scales and tuning systems for more.
(0..11).map{|n|  @notes[(n+root)%12]} ?
circle.each{|n| puts major(n) }
a : gcd(b, a % b) end def rp(a, b) gcd(a, b) ==
a sharp or flat is added or removed each increment you go around the circle.
insertion sort (bigger_array): 0.240000 0.000000 0.240000 ( 0.238994) merge sort (bigger array): 0.030000 0.010000 0.040000
(i’m making it  an instance variable so i can use it in a method later; this was all done in  irb.)
well, let’s make a little  method to construct a major scale from the@notes variable.
here were the results: =>
well-tempered clavier (evidently there’s some dispute over  whether or not bach’s intended tuning was equal or, uh,  “well” tempered; i was not aware of this!)) and a 7 note major  scale – neither of which are absolutely necessary, of course, and there  are other ways to do it.
so, if you go around clockwise, you’re counting by fifths (g is the  fifth note of the c major scale, d is the fifth note of the g major scale, etc)  and if you go around counter-clockwise you’re counting by fourths (f is  the fourth note of c, bb is the fourth note of f, etc).
> puts greeting hello!
this post is not meant to be a defense of music notation, a “setting straight” of anything, or even a definitive description of musical theory (at which i’m a rank amateur).
the thing that makes it seem so strange is, at least in part, the major  scale.
if a scale has 3 sharps, it’s a. period.
sequence on my first try.
when i tell ruby that foo = "bar", ruby binds the local variable namedfoo to a string object, “bar”.
foo is a string object, and when i pass it to my reassign method, i am passing a reference to the real object, foo.
again, if you’re interested enough in the topic that you’re still working out this algorithm, fire up irb and just try it out, it will make more sense as you do so.
back to the quicksort implementation i started with: the way to get around this is to use .clone or .dup to get acopy of the object.
where it gets really interesting is the circle of fourths and fifths.
if you go around clockwise, each scale has one additional sharped note until you get to 180 degrees around, then it has n-1 flat notes, and loses one flat each fifth till you get back to c (no sharps or flats); vis versa the other direction.
here were the results: user system total real small_array has 100 elements in it...
just  that music is pretty cool, and that a few of the things thatseem arbitrary just have to be that way – assuming we’re going to base  the system around 12 equally tempered semitones (seeequal temperment, or even
our original objects were changed when they were modified inside the method.
that doesn’t mean a whole lot.
"hello!" > reassign(greeting)
there are a variety of ways one could write the insertion sort in ruby; this is more or less an literal translation of theintro to algorithms pseudocode to ruby – it could perhaps be made a little more ruby-ish, but here’s my version: def insertion_sort(sequence) sequence[1..sequence.size].each_with_index do |j, index| i = index sequence[0..i].reverse.each do |k| break unless k > j sequence[i + 1] =
c d e f g a b g a b c d e f#/gb d e f#/gb g a b c#/db
aug 11th, 2010 got to chatting with nate (@fowlduck) about musical notation last night.
rp, then, simply returns true if the gcd of a and b is 1; otherwise false.
i think i’m a clone, now back to the quicksort implementation i started with: the way to get around  this is to use .clone or .dup to get acopy of the object.
we’ll take a root note as an argument, so we can construct any major  scale we like.
when  i tell ruby thatfoo = "bar", ruby binds the local  variable namedfoo to a string object, “bar”.
so, let’s just accept the scale as a given; that  this pattern of whole tones and semi-tones sounds pleasing to the ear.
see also: insertion sort merge sort ruby algorithm library <– some pretty interesting stuff in here.
no good; same exact problem.tmp is now just a  reference straight tosequence, so altering tmp modifiessequence as well.
jul 27th, 2010 i’ve seen the i write like links show up on facebook and twitter a few times, so i decided i’d take a look.
that part, to me at least, does seem arbitrary, but effectively it  doesn’t matter.
so, evidently, according to their analyses, i write most often like cory doctorow.
like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 | c | | d | | e | f | | g | | a | | b | c  | ... (etc) the next root note (13th semi-tone, above) is only a semi-tone off from the  last note of the scale.
if you go around  clockwise, each scale has one additional sharped note until you get to 180  degrees around, then it has n-1 flat notes, and loses one flat each fifth till  you get back to c (no sharps or flats); vis versa the other direction.
tmp is now just a reference straight to sequence, so altering tmp modifies sequence as well.
i could alter it, still: if i changed the reassign method so that it did obj.replace("some new value!") inside the method body, the original object would be changed, just like shiftit did to the array and the hash.
here’s a version modeled after the pseudocode in intro to algorithms: def merge_sort(sequence, first, last) if first  1, it calculates a midpoint; integer division works fine for this, using (first + last) / 2.
so, let’s just accept the scale as a given; that this pattern of whole tones and semi-tones sounds pleasing to the ear.
first  lets set it up: > circle = (0..11).map{|n| n*7%12 } =>
i write like: h.p. lovecraft.
so the reason this is how not to write sorting algorithms in ruby is simply that, you really probably don’t need to, unless you need something faster than a quicksort written in c. the reason, hopefully, to be playing around writing algorithms in ruby or inwhatever your favorite language happens to be, is just to understand them better.
in a nutshell: in case this is a little unclear, it would go something like this: starting array: [5,2,3,1,4,0] first pass: [2,5,3,1,4,0] second pass: [2,3,5,1,4,0] third pass: [1,2,3,5,4,0] fourth pass: [1,2,3,4,5,0] fifth pass:
and finally, good old sort!
that’s a good question.
so we said that the circle of fifths added a sharp each increment, and then flipped to flats and removed on each increment.
you’ll find that any method of modifying an object inside another  method with actually change (even delete, if you go that far) the original  object that you passed in.
(0..11).map{|n| n*7%12 }
the emperor’s new web not sure how they are analyzing the text and reaching their conclusions, but there’s at least alittle bit of smarts in there; that last one, the one which was compared to swift, is indeed a satire, though i’m not going to claim it’s in the calibre of swift’s satire, but still; their algorithm picked something out of it which prompted the comparison.
let’s say we started with the same starting array as the insertion_sort example.
[offset[0], offset[2], offset[4], offset[5],  offset[7], offset[9], offset[11]].join(" ") ?> end => nil so, just calling major with no arguments should give us the c  major scale; calling with, say, 5 should give us f major (5 in this case is the  index of f in @notes; but you were already following that, i know): > major =>
the small array is pretty fast for all three methods, but even still, we can see that merge_sort is alittle faster, and the built in .sort!
the semi-tone before or after any given note  is a flat or a sharp respectively, giving rise to the b
g#/ab a#/bb b c#/db d#/eb f c#/db d#/eb f f#/gb g#/ab a#/bb c g#/ab a#/bb c c#/db d#/eb f g d#/eb f g g#/ab a#/bb c d a#/bb c d d#/eb f g a f g a a#/bb c d e not as neat as it could look since i put the #/b both in the original notes array; the note you’d read would be the one with a consecutive letter after the previous note.
now even the merge_sort shows its limits, taking over a minute, about 74.3 seconds.
need to use tmp = sequence.clone , or something like it.
=> nil so, assignment inside a method doesn’t change our object.
a ten thousand element array starts to show the difference even more dramatically: insertion_sort now takes 24.1 seconds, close to half a minute, while the merge_sort still runs in under a second.
[2,3,5] merge_sort([1,4,0], 3, 5): mid <- 4 merge_sort([1,4], 3, 4): mid <- 3 merge_sort([1], 3, 3): merge_sort([4], 4, 4): merge([1,4], 3, 4, 4): left <-
[1,2,3,4,5,6] > shiftit(h) => {:bar  =>"baz",:baz=>"qux"} > shiftit(a) =>
[offset[0], offset[2], offset[4], offset[5], offset[7], offset[9], offset[11]].join(" ") ?> end => nil
as the method returns from each level of recursion, each “half” of the subarray under consideration has been sorted, until it gets all the way back to the first call to merge_sort, and executes merge on each (sorted) half of the full array.
so, just for fun, i wrote a little script to make some benchmarks of these various methods on arrays of various sizes.
i’ve only readdown and out in the magic kingdom, and several of his blog posts/essays, but enough to consider it a compliment, though i’m not certain it’s deserved.
"e#/f g a a#/bb c d e"
i write like: cory doctorow.
["c", "c#/db", "d", "d#/eb", "e", "e#/f", "f#/gb", "g", "g#/ab", "a", "a#/bb", "b/cb"] so, to read our circle, we’d do: > circle.map{|n| @notes[n]} =>
> def major(root=0) ?> offset =
"c d e e#/f g a b/cb" > major(5) =>
sorry, the insertion_sort was taking too long!
the octave consists of twelve semi-tones, in which the major scale is  set in this pattern: whole tone, whole tone, semitone, whole tone, whole tone,  whole tone, whole tone, semi-tone.
["c", "c#/db", "d", "d#/eb", "e", "e#/f", "f#/gb", "g", "g#/ab", "a", "a#/bb", "b/cb"] =>
first lets set it up: > circle =
insertion sort (medium_array): 23.960000 0.010000 23.970000 ( 24.096455)
for example, why no whole tone between b  and c, e and f?
like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 | c | | d | | e | f | | g | | a | | b | c | ... (etc) the next root note (13th semi-tone, above) is only a semi-tone off from the last note of the scale.
then how come assignment in a method doesn’t change an  object?
circle.each{|n| puts major(n) } c d e f g a b g a b c d  e f#/gb
in eb, the note  following g is ab… and so on.
insertion sort (small_array): 0.000000 0.000000 0.000000 ( 0.002122) merge sort (small_array): 0.000000 0.000000 0.000000 ( 0.001499) ruby array::sort (small_array): 0.000000 0.000000 0.000000 ( 0.000016) bigger_array has 1000 elements in it...
{:foo=>"bar",:bar =>"baz",:baz=>"qux"}  >
i - 1 end sequence[i+1] = j end end
that way you  aren’t actually modifying the original object.
"some new value" inside the method scope, trying to reassign foo, ruby sees that i’m binding foo to a new value; but from  inside method scope, ruby is not going to let me change the binding from  another scope.
so instead, ruby figures that i want a local variable that is also named foo, inside my method scope, and it assigns my new value to the local foo, not the original foo.
it looks like: def q(s);t=s.dup;t.size= pivot sub_sequence_a =
seemathematics of musical scales and tuning systems  for more.
"some new value" inside the method scope, trying to reassign foo, ruby sees that i’m binding foo to a new value; but from inside method scope, ruby is not going to let me change the binding from another scope.
just that music is pretty cool, and that a few of the things thatseem arbitrary just have to be that way – assuming we’re going to base the system around 12 equally tempered semitones (seeequal temperment, or even bach’s
oct 22nd, 2010 oct 6th, 2010 photo source i recently attempted to fit the quicksort algorithm into under 140 characters of ruby.
merge sort (medium_array): 0.720000 0.020000 0.740000 ( 0.726312) ruby array::sort (medium_array): 0.000000 0.000000 0.000000 ( 0.001637) huge_array has 100,000 elements in it...
the semi-tone before or after any given note is a flat or a sharp respectively, giving rise to the b
given the above system, the major scale in one key and  one key only will have no sharps or flats.
def shiftit(obj) obj.shift end #irb > h = {:foo =>  "bar", :bar => "baz", :baz =>
ruby must  notreally be passing a referece, right?
(again), way faster, only 0.00016 seconds.
the next bigger, bigger_array, the differences stand out a little more.
["c", "g", "d", "a", "e", "b/cb", "f#/gb", "c#/db", "g#/ab", "d#/eb", "a#/bb", "e#/f"] hooray.
the slides can be found at rubymn-rvm.heroku.com.
foo is a  string object, and when i pass it to myreassign method, i am  passing a reference to the real object,foo.
gcd is a recursive function, basically euclid’s algorithm for finding the greatest common denominator.
he  was pointing out that bits of the notation seem arbitrary and probably archaic,  likening it to legacy code of a sort.
["c", "c#/db", "d",  "d#/eb", "e", "e#/f", "f#/gb",  "g", "g#/ab", "a", "a#/bb",  "b/cb"] so, to read our circle, we’d do: > circle.map{|n| @notes[n]} =>
[] tmp.each do |element| if element = pivot sub_sequence_b   greeting =
so in g, the note following e is f#.
he was pointing out that bits of the notation seem arbitrary and probably archaic, likening it to legacy code of a sort.
there isn’t another choice.
let’s watch it happen: >>
it still doesn’t necessarily seem to make sense.
even when i realized this  was happening, i still made the mistake of just doingtmp =
ruby passes objects by reference.
(i’m making it an instance variable so i can use it in a method later; this was all done in irb.)
for one, we want to be able to express every scale  by naming off the notes, and we’d like each note to be a different  letter.
then it calls itself recursively on each subarray; these in turn will continue splitting each subarray into two parts until it gets to the point where it’s just two subarrays of one element each; which are then fed to merge and sorted.
let’s just construct a reference array really quick.
[1,2,3,4,5,6] > shiftit(h) => {:bar =>"baz",:baz=>"qux"} > shiftit(a)
["c",  "g", "d", "a", "e", "b/cb",  "f#/gb", "c#/db", "g#/ab", "d#/eb",  "a#/bb", "e#/f"] hooray.
so we said that the circle of fifths added a sharp each increment, and then  flipped to flats and removed on each increment.
so instead, ruby figures that i want a local variable that is also named foo, inside my method scope, and it assigns my new  value to the localfoo, not the original foo.
how can we map it to notes?
"qux"} => {:foo=>"bar",:bar =>"baz",:baz=>"qux"} >
this time, to show what the recursion is actually doing, i’ll write out what each nested call to merge_sort( and/or merge) would actually look like: starting array: [5,2,3,1,4,0] merge_sort([5,2,3,1,4,0], 0, 5): mid <- 2 merge_sort([5,2,3], 0, 2): mid <- 1 merge_sort([5,2], 0, 1): mid <- 0 merge_sort([5], 0, 0): merge_sort([2], 1, 1): merge([5,2],0, 1, 1): left <- [5,∞] right <- [2,∞] loop(0..1): [2,5] # just showing the result in this step; the two elements are sorted.
well, let’s make a little method to construct a major scale from the @notes variable.
so for fun, we can explore the circle of fifths in the command line.
[0,1,2,3,4,5] uhm, hopefully that’s clear.
i decided to write them out in ruby and run some simple benchmarks, just for fun.
[0,1,4] merge([2,3,5,0,1,4], 0, 3, 5): left <- [2,3,5,∞] right <- [0,1,4,∞] loop(0..5):
for one, we want to be able to express every scale by naming off the notes, and we’d like each note to be a different letter.
if a scale has 3 sharps, it’s a.  period.
as i thought; there’s always a better way to do it.
i wish i’d thought to do it that way, but i’ll certainly remember it.← older blog archives newer → my pinboard bookmarks »
i didn’t look at this until after i’d already written my versions of the insertion sort and the merge sort; their version of insertion_sort is nearly the same, but their merge sort is somewhat more succinct, and looks worth playing around with.)