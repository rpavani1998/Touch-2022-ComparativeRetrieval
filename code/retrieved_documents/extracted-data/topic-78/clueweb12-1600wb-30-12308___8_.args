taking advantage of evolutionary and revolutionary changes in sorting technologies sounds like fertile ground for a clever compiler.a software engineer similarly chooses from a wide variety of different sorting algorithms based on the desired tradeoffs between coding complexity, suitability to size of problem (i.e., internal vs. external sorts), average space consumption, average time consumption, variability of space/time consumption, and sort stability.however, it does serve as an example where the programmer can use the clever compiler's capabilities as a tool to simplify the task of exploring what-if scenarios to improve program performance, although judiciously (i.e., not in inner loops).the source code files for eqntott include an implementation for qsort(), which makes sense, since the stability of standard c library qsort() --- that is, whether it will or will not preserve the initial ordering of elements being sorted which compare as equal --- is intentionally undefined.it's less tedious and less error-prone to let the clever compiler manage program versions than to do so by hand.furthermore, casual trials with another similarly-sized input file for eqntott (modeling a 4-bit 16-input/output multiplexer) suggests that the reference input file for the specint92 benchmark use of eqntott is in fact somewhat anomalous for eliciting such poor behavior from quicksort; however, program performance for the multiplexor input file was still about 20% better with merge sort than with quicksort, consistent with the results in table which shows that the merge sort implementation tends to perform fewer comparisons --- and the number of comparisons, when each comparison can be quite expensive, will dominate the running time more than the efficiency of the inner loops of the sorting algorithm.if the system qsort() had been written with a qif statement to quasistatically select between a quicksort implementation or a merge sort implementation, it would not be necessary to go to this kind of effort, nor necessary to speculate about whether typical user files provided as input to eqntott tend to elicit o(n ) behavior from the quicksort used; whether or not quicksort often behaved poorly or not on user inputs would be directly observed and taken into account.to reiterate, if the library writer had written the system qsort() with a qif statement, then sorting performance would be improved on average, without any effort from the application programmer's part and without complicating the semantics of qsort() usage.investigation readily uncovered that the linux system qsort() is supplied by the gnu implementation of the libc library; by default, it does not use the quicksort algorithm, but rather uses the merge sort algorithm if it can allocate enough temporary buffer to perform a standard two-space merge sort, only falling back to an in-place quicksort if the attempt to allocate memory fails.another obvious approach to improving the performance of eqntott would be to try to make cmppt() execute faster.i.e., one hypothesis is that in this case merge sort tends to be comparing elements which the comparison routine can quickly decide whetherab, whereas quicksort tends to be comparing elements which the comparison routine cannot quickly determine the ordering relationship.by including its own qsort(), those who submitted eqntott to the spec organization as a benchmark could provide a reference output file to go with the reference input file; whereas if eqntott used the system qsort(), then the reference output file might not match eqntott's output on a given platform even though the difference would be entirely due to sort stability, and would not make the resulting output incorrect.hence it can matter greatly to the total run-time exactly which elements are compared with each other, something which was not true for sorting integers.attacking qsort() the source code files for eqntott include an implementation for qsort(), which makes sense, since the stability of standard c library qsort() --- that is, whether it will or will not preserve the initial ordering of elements being sorted which compare as equal --- is intentionally undefined.hence which sort should be selected in a given usage will depend on both the input data pattern and on the cost of the comparison function provided to qsort().