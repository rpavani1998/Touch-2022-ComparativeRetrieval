as the method returns from each level of recursion, each “half” of the subarray under consideration has been sorted, until it gets all the way back to the first call to merge_sort, and executes merge on each (sorted) half of the full array.then it calls itself recursively on each subarray; these in turn will continue splitting each subarray into two parts until it gets to the point where it’s just two subarrays of one element each; which are then fed to merge and sorted.a ten thousand element array starts to show the difference even more dramatically: insertion_sort now takes 24.1 seconds, close to half a minute, while the merge_sort still runs in under a second.tmp is now just a reference straight to sequence, so altering tmp modifies sequence as well.so the reason this is how not to write sorting algorithms in ruby is simply that, you really probably don’t need to, unless you need something faster than a quicksort written in c. the reason, hopefully, to be playing around writing algorithms in ruby or inwhatever your favorite language happens to be, is just to understand them better.again, if you’re interested enough in the topic that you’re still working out this algorithm, fire up irb and just try it out, it will make more sense as you do so.the small array is pretty fast for all three methods, but even still, we can see that merge_sort is alittle faster, and the built in .sort!this time, to show what the recursion is actually doing, i’ll write out what each nested call to merge_sort( and/or merge) would actually look like: starting array: [5,2,3,1,4,0] merge_sort([5,2,3,1,4,0], 0, 5): mid <- 2 merge_sort([5,2,3], 0, 2): mid <- 1 merge_sort([5,2], 0, 1): mid <- 0 merge_sort([5], 0, 0): merge_sort([2], 1, 1): merge([5,2],0, 1, 1): left <- [5,∞] right <- [2,∞] loop(0..1): [2,5] # just showing the result in this step; the two elements are sorted.for one, we want to be able to express every scale by naming off the notes, and we’d like each note to be a different letter.you’ll find that any method of modifying an object inside another method with actually change (even delete, if you go that far) the original object that you passed in.he was pointing out that bits of the notation seem arbitrary and probably archaic, likening it to legacy code of a sort.so, just for fun, i wrote a little script to make some benchmarks of these various methods on arrays of various sizes.if you’re bothering to read this and it still isn’t clear, just run the sort locally and add some puts statements liberally so you can see what’s going on.well, the main reason is that both of these methods are significantly slower than good old array::sort, which is built in to ruby (and which, as far as i know, is implemented using thequicksort algorithm).our original objects were changed when they were modified inside the method.