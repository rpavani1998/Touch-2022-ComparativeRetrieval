similar resource-use statements are made about "iterative" procedures, meaning that they can execute on input of arbitrary size without needing to allocate an unbounded number of stack frames.
porting and optimisation --------------------------
[start end]) - use  of the let-optionals macro from scsh to parse and default optional arguments to  three routines.
permission is hereby  granted, free of charge, to any person obtaining a copy of this software and  associated documentation files (the "software"), to deal in the  software without restriction, including without limitation the rights to use,  copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the  software, and to permit persons to whom the software is furnished to do so,  subject to the following conditions: the above copyright notice and this  permission notice shall be included in all copies or substantial portions of  the software.
again, easy to port the macro or rewrite the code to parse,  default, and error check the args by hand.
choose the algorithm that matches your needs: vector insert sort stable, but only suitable for small vectors -- o(n^2).
it is necessarily the case that the specifications of these procedures make statements about execution "pragmatics."
lis  list list-merge lis1 lis2  list list-merge!
here are my  notes from the systems i checked.
the two interfaces share  common function signatures wherever possible, to facilitate switching a given  call from one procedure to another.
these are  well-understood algorithms, each of them well under a page of code.
[r5rs] revised^5  report on the algorithmic language scheme, r. kelsey, w. clinger, j. rees  (editors).
lis  list (list merge sort) list-stable-sort lis  list (vector merge sort) list-stable-sort!
i've designed the api for a full-featured sort toolkit, which i propose as an srfi.
** algorithm-specific sorting packages =
one implementation even has a buggy implementation that has been in use for  about 20 years!
- detailed: you specify the actual algorithm (quick,  heap, insert, merge).
if you want to delete  duplicate elements from a large list or vector, sort the elements to bring  equal items together, then use one of these procedures, for a total time of o(n  lg n).
the optional-arg parsing, defaulting, and error checking is done with a portable r4rs macro.
abstract procedure  index introduction
[this link may not be valid while the srfi is in draft form.]
the merge operations are stable: an element of lis1 will come before an equal-comparing element in lis2 in the result list.
a clever pivot-picking trick (median of three samples) helps avoid worst-case behaviour, but pathological cases can still blow up.
[start end]) - use of the let-optionals macro from scsh to parse and default optional arguments to three routines.
v v1 v2  unspecific vector-sort v  vector (heap or quick sort) vector-sort!
no o(n lg n) o(n lg n)
the straightforward algorithms are basic, core stuff -- sophomore-level.
v insert yes o(n^2)  o(n^2)
sorted?-lib - sorted predicates list-sorted?
this  includes notes on porting and implementation-specific optimisations.
different sort and merge algorithms have different properties.
* introduction --------------
v  unspecific (heap or quick sort) vector-stable-sort v  vector (vector merge sort) vector-stable-sort!
** reference implementation =
i've designed the api for a  full-featured sort toolkit, which i propose as an srfi.
should it be (list-sort <  lis) or (list-sort lis <)
there are only four non-r4rs bits in the code: - use of multiple-value return, with the r5rs values procedure, and the simple (receive (var ...)
the implementation of vector merge  sort provided by this srfi's reference implementation is, additionally, a  "natural" sort, meaning that it exploits existing order in the input  data, providing o(n) best case.
there are several (quotient n 2)'s that could be changed to a fixnum right-shift, as well, in both the list and vector code.
nothing for stable sorting.
i mean, you'd really have to be a boor to take this free code i wrote and mutate its interface over to your incompatible, unportable api, wouldn't you?
v  unspecific vector-merge v1 v2   vector vector-merge!
there are only four non-r4rs bits in the code: - use of  multiple-value return, with the r5rs values procedure, and the simple (receive  (var ...)
reuses its input vector to hold the answer, packing its answer into the index range [start,end'), where end' is the non-negative exact integer returned as its value.
list-delete-neighbor-dups does not alter its input list; its answer may share storage with the input list.
vector-delete-neighbor-dups v =
- a vector-copy procedure.
the first/leftmost element of a run of equal elements is the one that survives.
v  boolean vector-merge v1 v2  vector vector-merge!
quick-sort returns a vector of length end-start.
there are several (quotient n 2)'s that could be  changed to a fixnum right-shift, as well, in both the list and vector code.
lis1 lis2  list list-sort lis  list (vector  heap or quick) list-sort!
these packages provide more specific  sorting functionality, that is, specific committment to particular algorithms  that have particular pragmatic consequences (such as memory locality,  asymptotic running time) beyond their semantic behaviour (sorting, stable  sorting, merging, etc.).
in fact, all the  code bumming i've done pretty much disappears in the noise unless you have a  good compiler and also can dump the vector-index checks and generic arithmetic  -- so i've really just set things up for you to exploit.
(vector-delete-neighbor-dups '#(1 1 2 7 7 7 0
should it be (list-sort < lis) or (list-sort lis <)
[start end] -> end' list-sorted?
delndup-lib - list and vector delete neighbor duplicates list-delete-neighbor-dups lis = -> list list-delete-neighbor-dups!
it's just amazing to me that  in 2002, sorting and merging hasn't been completely put to bed.
merge-sorting a  vector requires the allocation of a temporary "scratch" work vector  for the duration of the sort.
reuses its  input vector to hold the answer, packing its answer into the index range  [start,end'), where end' is the non-negative exact integer returned as its  value.
available at http://www.elwood.com/alu/table/references.htm#cltl2
the optional start/end arguments provide for sorting of subranges,  and default to 0 and the length of the corresponding vector.
the little exported cover procedures are where you move the error checks.
list-delete-neighbor-dups! is permitted, but not required, to mutate its input  list in order to construct its answer.
[start end] ->  end' list-sorted?
worst case average case in-place ------------------------------------------------------
the  straightforward algorithms are basic, core stuff -- sophomore-level.
lis1 lis2  list list-sort lis  list (vector heap or quick) list-sort!
and acm sigplan notices, vol. 33, no. 9, october, 1998.
it's better than what you have.
vector heap sort not stable.
destructive list merge sort stable, fast and in-place (i.e., allocates no new cons cells).
having the source available for all of these above-cited schemes made life a  lot easier writing this code.
poor locality on large vectors.
-------------------------------------------------------------------------------  * design rules --------------
worst case average case in-place  ------------------------------------------------------
** reference implementation  =
heap-sort returns a vector of length end-start.
in a couple of hours, i  was able to download and check the sources of 9 scheme systems.
scheme programmers may  want to adopt this package.
v  unspecific  these procedures sort their data using quick sort, which is not a stable  sorting algorithm.
vector-insert-sort-lib -  vector insertion sort insert-sort v  vector insert-sort!
the  code is designed to enable this -- each file usually exports one or two  "safe" procedures that end up calling an internal  "dangerous" primitive.
- simple: you specify semantics: datatype (list or vector), mutability, and stability.
- a vector-copy  procedure.
this code is tightly bummed, as far as i can go in portable scheme.
as such, they do not allocate any extra cons cells -- they are "in place" sorts.
i have done it in the backwards-compatible way.
having the source available for all of these above-cited schemes made life a lot easier writing this code.
this document, in simple text format: http://srfi.schemers.org/srfi-32/srfi-32.txt archive of srfi-32 discussion-list email: http://srfi.schemers.org/srfi-32/mail-archive/maillist.html srfi web site: http://srfi.schemers.org/ [commonlisp] common lisp: the language guy l. steele jr. (editor).
see below for the properties of this algorithm.)
vector heap sort - vector quick sort (with median-of-3 pivot picking) -
digital press, maynard, mass., second edition 1990.
guaranteed fast -- o(n lg n) *worst* case.
a  clever stable vector merge sort, albeit not very bummed.
(the reference implementation  is, additionally, a "natural" sort.
the merge operations are stable: an element of lis1 will come before an  equal-comparing element in lis2 in the result list.
it sort of goes with sorting; it's exactly ten lines of code.
see below for the properties of this  algorithm.)
[r5rs] revised^5 report on the algorithmic language scheme, r. kelsey, w. clinger, j. rees (editors).
while i wrote all of this code myself, i read a lot of code before i began writing.
i thank the authors of the open source i  consulted when designing this library, particularly richard o'keefe, donovan  kolby and the mit scheme team.
the two interfaces share common function signatures wherever possible, to facilitate switching a given call from one procedure to another.
i thank the authors of the open source i consulted when designing this library, particularly richard o'keefe, donovan kolby and the mit scheme team.
last update: 2002/7/21 emacs should display this document in outline  mode.
but i prefer the < first, data after way.
abstract procedure index introduction what's wrong with the current state of affairs?
"fast" means o(n lg n)  worse-case, and substantially better if the data is already mostly ordered, all  the way down to linear time for a completely-ordered input list (i.e., it is a  "natural" sort).
this document, in simple text format:  http://srfi.schemers.org/srfi-32/srfi-32.txt archive of srfi-32 discussion-list  email: http://srfi.schemers.org/srfi-32/mail-archive/maillist.html srfi web  site: http://srfi.schemers.org/ [commonlisp] common lisp: the language guy l.  steele jr. (editor).
i have  done it in the backwards-compatible way.
short summary: no restrictions.
the srfi-32 sort libraries -*- outline -*- olin shivers first draft: 1998/10/19
as such, they do not  allocate any extra cons cells -- they are "in place" sorts.
nothing for stable sorting, and naive quicksort has bad  worst-case behaviour.
a clever stable vector merge sort, albeit not very bummed.
vector-merge-sort-lib - vector merge sort vector-merge-sort v  vector vector-merge-sort!
this could be fixed very easily, but it isn't worth it given the other problems with the algorithm.
again, easy to port the macro or rewrite the code to parse, default, and error check the args by hand.
i appreciate the authors making their source  available under such open terms.
different algorithms have different properties, both  semantic & pragmatic, so these exports are necessary.
for example, the sole distinction between heap sort and quick sort -- both of which are provided by this library -- is one of execution time, which is not a "semantic" distinction.
list-delete-neighbor-dups!
if you want to delete duplicate elements from a large list or vector, sort the elements to bring equal items together, then use one of these procedures, for a total time of o(n lg n).
"scheme implementors," in this  context, includes slib, which isn't really a standalone implementation of  scheme, but is an influential collection of api's and code.
the vector is not altered outside the  range [start,end').
this includes notes on porting and implementation-specific optimisations.
gambit sort-list list  bool)  -> 'a list -> 'a list "smooth applicative merge sort," which is  stable.
pointer *writing*, which is what the set-cdr!s  of a destructive list-sort algorithm do, is even worse, especially if your  scheme has a generational gc -- the writes will thrash the write-barrier.
vector-quick-sort-lib - vector quick sort quick-sort v  vector quick-sort!
and the destructive-list variant allocates zero cons cells; it simply rearranges the cells of the input list.
vector-delete-neighbor-dups!
you could speed up the vector code a lot by error-checking the procedure parameters and then shifting over to fixnum-specific arithmetic and dangerous vector-indexing and vector-setting primitives.
this should provide *big* speedups.
they run in o(n lg n) worst case, o(n) best  case, and require only a logarithmic number of stack frames.
v  unspecific these procedures sort their data using quick sort, which is not a stable sorting algorithm.
this could be fixed very easily, but it  isn't worth it given the other problems with the algorithm.
this code is tightly bummed, as far as i can  go in portable scheme.
the ! procedures are destructive -- they use set-cdr!s to rearrange the cells of the lists into the proper order.
similar  resource-use statements are made about "iterative" procedures,  meaning that they can execute on input of arbitrary size without needing to  allocate an unbounded number of stack frames.
higher-order and symbolic computation, vol. 11, no. 1, september, 1998.
"scheme implementors," in this context, includes slib, which isn't really a standalone implementation of scheme, but is an influential collection of api's and code.
it is - very portable, - much better code than what is currently in elk,  gambit, bigloo, scheme->c, mzscheme, rscheme, scheme48, mit scheme, or slib,  and - priced to move: free code.
permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "software"), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions: the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.
vector-insert-sort-lib - vector insertion sort insert-sort v  vector insert-sort!
and made available under the same copyright as the srfi text (see above).
however, all  such code is, itself, either open source or public domain, rendering irrelevant  any issue of "copyright taint."
a clever pivot-picking trick (median of three samples) helps avoid  worst-case behaviour, but pathological cases can still blow up.
it's just amazing to me that in 2002, sorting and merging hasn't been completely put to bed.
the common  lisp "hyperspec," produced by kent pitman, is essentially the ansi  spec for common lisp:  http://www.xanalys.com/software_tools/reference/hyperspec/
- simple: you specify semantics: datatype (list or vector),  mutability, and stability.
vector-heap-sort-lib - vector heap sort heap-sort v  vector heap-sort!
this document is copyright (c) olin shivers (1998, 1999).
the code is tightly  bummed.
is in-place, leaving its  result in v[start,end).
scheme 48 & t  sort-list list  (0 2 3) (list-merge!
and made available under the same copyright  as the srfi text (see above).
- comparison  function before or after the list/vector argument?
(the reference implementation is, additionally, a "natural" sort.
it returns end' as its result.
v  boolean return #f iff there is an adjacent pair ...
leaves its result in v[start,end).
these  procedures uniformly observe the following parameter order: the data to be  sorted come before the the comparison function.
more in the spirit of the offering, you could make this api  available, and then also write a little module providing your old interface  that is defined in terms of this api.
last update: 2002/7/21 emacs should display this document in outline mode.
vector-delete-neighbor-dups does not alter its  input vector, but rather allocates a fresh vector to hold the result.
- comparison function before or after the list/vector argument?
heap-sort quick-sort  insert-sort list-merge-sort vector-merge-sort heap-sort!
so i have designed and written a fairly comprehensive sorting & merging toolkit.
you can skip to the next section if you  aren't morbidly curious.
the merge operations are  stable: an element of v1 will come before an equal-comparing element in v2 in  the result vector.
it is clearly written, and commented in my usual voluminous style.
note that sorting lists involves chasing pointers  through memory, which can be a loser on modern machine architectures because of  poor cache & page locality.
this package should be  trivial to port.
see below for the properties of  this algorithm.)
they run in o(n lg n) worst case, o(n) best case, and require only a logarithmic number of stack frames.
v  boolean return #f iff  there is an adjacent pair ...
* algorithmic properties ------------------------
however, all such code is, itself, either open source or public domain, rendering irrelevant any issue of "copyright taint."
the right solution: implement a full toolbox of carefully written standard sort routines.
and the destructive-list variant allocates zero cons cells; it simply  rearranges the cells of the input list.
design rules what vs. how consistency across function signatures data parameter first, less-than parameter after ordering, comparison functions & stability all vector operations accept optional subrange parameters required vs. allowed side-effects procedure specification procedure naming and functionality types of parameters and return values sort-lib - general sorting package algorithm-specific sorting packages algorithmic properties topics to be resolved during discussion phase porting and optimisation references & links acknowledgements copyright *
insert-sort returns a vector of length end-start.
in a couple of hours, i was able to download and check the sources of 9 scheme systems.
predicates, vector binary search, vector and list delete-equal-neighbor procedures.
vector-merge returns a vector of length (end1-start1)+(end2-start2).
pointer *writing*, which is what the set-cdr!s of a destructive list-sort algorithm do, is even worse, especially if your scheme has a generational gc -- the writes will thrash the write-barrier.
the target subvector v[start0,end0) may not  overlap either source subvector v1[start1,end1) v2[start2,end2).
while i wrote all  of this code myself, i read a lot of code before i began writing.
vector-merge-sort returns a vector of length end-start.
in the input list or vector such that y   list list-merge-sort!
this document, in html:  http://srfi.schemers.org/srfi-32/srfi-32.html
o(n lg n)  worst-case, and possibly better, depending upon the input list (see above).
in fact, all the code bumming i've done pretty much disappears in the noise unless you have a good compiler and also can dump the vector-index checks and generic arithmetic -- so i've really just set things up for you to exploit.
vector-quick-sort-lib - vector quick sort quick-sort v   vector quick-sort!
a very reliable workhorse.
only chez does it differently.
vector-merge returns a  vector of length (end1-start1)+(end2-start2).
lis  list (list merge sort)  list-stable-sort lis  list (vector merge sort) list-stable-sort!
it is - very portable, - much better code than what is currently in elk, gambit, bigloo, scheme->c, mzscheme, rscheme, scheme48, mit scheme, or slib, and - priced to move: free code.
sorting vectors has inherently better locality.
the right  solution: implement a full toolbox of carefully written standard sort routines.
(the reference implementation is,  additionally, a "natural" sort.
(i invite correction from the bigloo implementors.)
abstract ---------- current scheme sorting  packages are, every one of them, surprisingly bad.
-------------------------------------------------------------------------------  * references & links --------------------
rscheme  vector-sort!
vector-delete-neighbor-dups does not alter its input vector, but rather allocates a fresh vector to hold the result.
open source-code is a wonderful thing.
** consistency across function  signatures ===
multiple-value binding macro.
lis  boolean vector-sorted?
not in-place -- requires a temporary buffer of equal size.
i appreciate the authors making their source available under such open terms.
is fast on average -- o(n lg n) -- but has bad worst-case behaviour.
3 7) => #(7 0 -2) ;; result left in v[3,9): (let ((v (vector 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6))) (cons (vector-delete-neighbor-dups!
there are two  different interfaces: "what" (simple) & "how"  (detailed).
lis = -> list  vector-delete-neighbor-dups v =
design rules  what vs. how consistency across function signatures data parameter first,  less-than parameter after ordering, comparison functions & stability all  vector operations accept optional subrange parameters required vs. allowed  side-effects procedure specification procedure naming and functionality types  of parameters and return values sort-lib - general sorting package  algorithm-specific sorting packages algorithmic properties topics to be  resolved during discussion phase porting and optimisation references &  links acknowledgements copyright *
* porting and optimisation --------------------------
programmers that need a particular algorithm can use  one of these packages.
scheme 48 & t sort-list list  (0 2 3) (list-merge!
the optional start/end arguments provide for sorting of subranges, and default to 0 and the length of the corresponding vector.
available at  http://www.schemers.org/documents/standards/  -------------------------------------------------------------------------------  * acknowledgements ------------------
this is a tiny little procedure: (vector-copy v
has good memory locality for big vectors (unlike heap sort).
predicates, vector binary search,  vector and list delete-equal-neighbor procedures.
the spec comes with 1200 lines of high-quality reference code: tightly written, highly commented, portable code, available for free.
the comparison function = passed to these procedures is always applied  (= x y) where x comes before y in the containing list or vector.
the package includes - vector insert sort (stable) -
these procedures are linear time -- much faster than the o(n^2)  general duplicate-element deletors that do not assume any "bunching"  of elements (such as the ones provided by srfi-1).
list-delete-neighbor-dups! is permitted, but not required, to mutate its input list in order to construct its answer.
the little exported cover procedures are where  you move the error checks.
[start end] -> vector  vector-delete-neighbor-dups!
vector-or-list vector; quicksort; vector->list," hence also loser.
bigloo, scheme->c couldn't find anything -- but maybe  i didn't search for the right thing, since the bigloo names are french.
- calls to an error function for  complaining about bad arguments.
these procedures are linear time -- much faster than the o(n^2) general duplicate-element deletors that do not assume any "bunching" of elements (such as the ones provided by srfi-1).
-------------------------------------------------------------------------------  * procedure index ----------------- list-sorted?
- a general, non-algorithmic  set of procedure names for general sorting and merging.
- a general, non-algorithmic set of procedure names for general sorting and merging.
this srfis destructive list merge and merge sort implementations are opportunistic -- they avoid redundant set-cdr!s, and try to take long already-ordered runs of list structure as-is when doing the merges.
either  -------------------------------------------------------------------------------  * topics to be resolved during discussion phase  -----------------------------------------------
in the input list or vector such that y  list list-merge-sort!
but if you tour the major scheme implementations out there on the net, you find badly written code that provides extremely spotty coverage of the algorithm space.
the list or vector is not otherwise disordered.
the comparison function = passed to these procedures is always applied (= x y) where x comes before y in the containing list or vector.
the comments in the code indicate where the initial error checks would have to be added.
the sort procedures sort their  data using a list merge sort, which is stable.
there are two different interfaces: "what" (simple) & "how" (detailed).
this document is copyright  (c) olin shivers (1998, 1999).
i particularly solicit comments  about the following topics.
i particularly solicit comments about the following topics.
these packages provide more specific sorting functionality, that is, specific committment to particular algorithms that have particular pragmatic consequences (such as memory locality, asymptotic running time) beyond their semantic behaviour (sorting, stable sorting, merging, etc.).
but  if your scheme has a faster mechanism (e.g., chez), you should definitely port  over to it.
return true if their input list or vector is in sorted order, as determined by their  (1 2 7 0 -2)
the srfi-32 sort libraries -*- outline -*- olin shivers first draft:
but if you  tour the major scheme implementations out there on the net, you find badly  written code that provides extremely spotty coverage of the algorithm space.
[start end] -> end' these procedures delete adjacent duplicate elements from a list or a vector, using a given element-equality procedure =.
programmers that need a particular algorithm can use one of these packages.
the natural merge sorts (pure list, destructive list, and vector) are not only my own code, but are implementations of an algorithm of my own devising.
[start end]) in the srfi?
this package should be trivial to port.
v  unspecific vector-merge v1 v2  vector vector-merge!
mzscheme naive  quicksort -- but not available for vector sorting, even though it internally  uses a vector.
-------------------------------------------------
vector-merge! writes its result  into vector v, beginning at index start0, for indices less than end0 = start0 +  (end1-start1)
the optional-arg  parsing, defaulting, and error checking is done with a portable r4rs macro.
vector heap  sort not stable.
note that argument defaulting and error-checking are interleaved -- you don't have to error-check defaulted start/end args to see if they are fixnums that are legal vector indices for the corresponding vector, etc. ------------------------------------------------------------------------------- * references & links --------------------
** data parameter first, less-than  parameter after ==
if not  supplied, the sort routines allocate one themselves.
you can skip to the next section if you aren't morbidly curious.
------------------------------------------------------------------------------- * algorithmic properties ------------------------
the code is tightly bummed.
delndup-lib -  list and vector delete neighbor duplicates list-delete-neighbor-dups lis =
the list or vector is not otherwise  disordered.
not  in-place -- requires a temporary buffer of equal size.
=> #(7 0 -2) ;; result left in v[3,9): (let ((v (vector 0 0 0 1 1 2 2 3 3 4  4 5 5 6 6))) (cons (vector-delete-neighbor-dups!
is fast on average -- o(n lg n) -- but  has bad worst-case behaviour.
note that sorting lists involves chasing pointers through memory, which can be a loser on modern machine architectures because of poor cache & page locality.
lis = -> list vector-sorted?
different algorithms have different properties, both semantic & pragmatic, so these exports are necessary.
bigloo, scheme->c couldn't find anything -- but maybe i didn't search for the right thing, since the bigloo names are french.
this scratch vector can be passed in by the  client as the optional temp argument; if so, the supplied vector must be of  size >=
** algorithm-specific sorting packages  =
"fast" means o(n lg n) worse-case, and substantially better if the data is already mostly ordered, all the way down to linear time for a completely-ordered input list (i.e., it is a "natural" sort).
additionally, list-merge! is iterative, not recursive -- it can operate on arguments of arbitrary size without requiring an unbounded amount of stack space.
------------------------------------------------------------------------------- * copyright -----------
choose the algorithm that matches your  needs: vector insert sort stable, but only suitable for small vectors --  o(n^2).
scheme programmers may want to adopt this package.
v  unspecific these procedures sort their data using heap sort, which is not a stable sorting algorithm.
the natural merge sorts (pure list,  destructive list, and vector) are not only my own code, but are implementations  of an algorithm of my own devising.
the ! procedures are destructive -- they use set-cdr!s to  rearrange the cells of the lists into the proper order.
merge-sorting a vector requires the allocation of a temporary "scratch" work vector for the duration of the sort.
vector-delete-neighbor-dups v  =
vector-merge-sort-lib -  vector merge sort vector-merge-sort v  vector  vector-merge-sort!
[start end] -> vector vector-delete-neighbor-dups!
-> list list-delete-neighbor-dups!
the software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement.
- detailed: you specify the actual algorithm (quick, heap, insert, merge).
vector vector; sort; vector->list", which allocates unneeded temp storage.
the spec comes with  1200 lines of high-quality reference code: tightly written, highly commented,  portable code, available for free.
copyright -----------
pure list merge sort stable and fast --
** consistency across function signatures ==
but i prefer the < first, data  after way.
should we include  (vector-binary-search v keykey key
mzscheme naive quicksort -- but not available for vector sorting, even though it internally uses a vector.
v insert yes o(n^2) o(n^2)
this document, in html: http://srfi.schemers.org/srfi-32/srfi-32.html
abstract ---------- current scheme sorting packages are, every one of them, surprisingly bad.
list-merge vector-merge list-sort vector-sort list-stable-sort vector-stable-sort list-delete-neighbor-dups vector-delete-neighbor-dups list-merge!
o(n lg n) worst-case, and possibly better, depending upon the input list (see above).
higher-order and symbolic computation, vol. 11, no. 1, september,  1998.
destructive list merge sort stable, fast and  in-place (i.e., allocates no new cons cells).
v  unspecific (vector merge sort)
#(0 0 0  1 2 3 4 5 6 4 4 5 5 6 6))
that is, we write (sort lis  boolean list-merge lis1 lis2  list list-merge!
v  unspecific these procedures sort  their data using heap sort, which is not a stable sorting algorithm.
vector-merge! writes its result into vector v, beginning at index start0, for indices less than end0 = start0 + (end1-start1) +
heap-sort quick-sort insert-sort list-merge-sort vector-merge-sort heap-sort!
as i'll detail bewlow, i wasn't very happy with  the state of the scheme world for sorting and merging lists and vectors.
the sort procedures sort their data using a list merge sort, which is stable.
should we include (vector-binary-search v keykey key
additionally, list-merge! is iterative, not recursive -- it can operate on  arguments of arbitrary size without requiring an unbounded amount of stack  space.
in no  event shall the authors or copyright holders be liable for any claim, damages  or other liability, whether in an action of contract, tort or otherwise,  arising from, out of or in connection with the software or the use or other  dealings in the software.
note that argument defaulting and error-checking are interleaved --  you don't have to error-check defaulted start/end args to see if they are  fixnums that are legal vector indices for the corresponding vector, etc.
say c-h m for instructions on how to move through it by sections (e.g., c-c c-n, c-c c-p).
there is also a highly bummed quicksort for vectors.
[start end] -> end' these procedures delete  adjacent duplicate elements from a list or a vector, using a given  element-equality procedure
vector merge sort (stable) - pure and destructive list merge sort  (stable) - stable vector and list merge - miscellaneous sort-related  procedures: vector and list merging, sorted?
it  sort of goes with sorting; it's exactly ten lines of code.
lis = -> list vector-delete-neighbor-dups v =
different sort and merge  algorithms have different properties.
there is overwhelming consistency among the  implementations: data first, < after.
you could speed up the vector code a lot by  error-checking the procedure parameters and then shifting over to  fixnum-specific arithmetic and dangerous vector-indexing and vector-setting  primitives.
v  unspecific these procedures stably sort their data using insertion sort.
- calls to an error function for complaining about bad arguments.
i'd like scheme implementors to adopt this code and  its api -- in fact, the code is a bribe to make it easy for implementors to  converge on the suggested api.
the code is designed to enable this -- each file usually exports one or two "safe" procedures that end up calling an internal "dangerous" primitive.
gambit sort-list list  bool) -> 'a list -> 'a list "smooth applicative merge sort," which is stable.
-------------------------------------------------------------------------------  * introduction --------------
there is overwhelming consistency among the implementations: data first, < after.
that is, we write (sort lis   boolean list-merge lis1 lis2  list  list-merge!
so i  have designed and written a fairly comprehensive sorting & merging toolkit.
return true if their input list or vector  is in sorted order, as determined by their  (1 2 7 0 -2)
the package includes - vector insert sort  (stable) - vector heap sort - vector quick sort (with median-of-3 pivot  picking) -
v v1 v2  unspecific the sort procedures sort their data  using vector merge sort, which is stable.
these procedures uniformly observe the following parameter order: the data to be sorted come before the the comparison function.
v   unspecific (heap or quick sort) vector-stable-sort v   vector (vector merge sort) vector-stable-sort!
hence the reference implementation is copyright (c) 1998 by olin shivers.
vector vector; sort; vector->list", which  allocates unneeded temp storage.
#(0 0 0 1 2 3 4 5 6 4 4 5 5 6 6))
and they are  stable.
the common lisp "hyperspec," produced by kent pitman, is essentially the ansi spec for common lisp: http://www.xanalys.com/software_tools/reference/hyperspec/
(i  invite correction from the bigloo implementors.)
this scratch vector can be passed in by the client as the optional temp argument; if so, the supplied vector must be of size >=
the merge operations are stable: an element of v1 will come before an equal-comparing element in v2 in the result vector.
more in the spirit of the offering, you could make this api available, and then also write a little module providing your old interface that is defined in terms of this api.
these are well-understood algorithms, each of them well under a page of code.
list-merge  vector-merge list-sort vector-sort list-stable-sort vector-stable-sort  list-delete-neighbor-dups vector-delete-neighbor-dups list-merge!
available at http://www.schemers.org/documents/standards/ ------------------------------------------------------------------------------- * acknowledgements ------------------
the target subvector v[start0,end0) may not overlap either source subvector v1[start1,end1) v2[start2,end2).
- include vector-binary-search ?
** data parameter first, less-than parameter after ==
nothing for stable sorting, and naive quicksort has bad worst-case behaviour.
vector quick sort not stable.
either ------------------------------------------------------------------------------- * topics to be resolved during discussion phase -----------------------------------------------
as i'll detail bewlow, i wasn't very happy with the state of the scheme world for sorting and merging lists and vectors.
is in-place, leaving its result in v[start,end).
poor locality on  large vectors.
the first/leftmost element of a run of equal  elements is the one that survives.
* table of contents -------------------
one implementation even has a buggy implementation that has been in use for about 20 years!
lis  list (list merge sort) list-delete-neighbor-dups lis = -> list list-delete-neighbor-dups!
v v1 v2  unspecific the sort procedures sort their data using vector merge sort, which is stable.
v  unspecific these procedures stably sort their data  using insertion sort.
the comments in the code indicate where the initial error checks  would have to be added.
but you could, of course -- it's freely available.
vector-heap-sort-lib - vector heap sort heap-sort v   vector heap-sort!
i mean, you'd really have to be a boor to take  this free code i wrote and mutate its interface over to your incompatible,  unportable api, wouldn't you?
if not supplied, the sort routines allocate one themselves.
fast -- o(n lg n) -- and has good memory locality for large vectors.
------------------------------------------------------------------------------- * design rules --------------
------------------------------------------------------------------------------- * procedure index ----------------- list-sorted?
v v1 v2  unspecific  vector-sort v  vector (heap or quick sort) vector-sort!
this srfis destructive list  merge and merge sort implementations are opportunistic -- they avoid redundant  set-cdr!s, and try to take long already-ordered runs of list structure as-is  when doing the merges.
hence the reference implementation is  copyright (c) 1998 by olin shivers.
fast -- o(n lg n) -- and  has good memory locality for large vectors.
i'd like scheme implementors to adopt this code and its api -- in fact, the code is a bribe to make it easy for implementors to converge on the suggested api.
in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.
it's better  than what you have.
[this link may not be valid while  the srfi is in draft form.]
for example, the sole distinction between  heap sort and quick sort -- both of which are provided by this library -- is  one of execution time, which is not a "semantic" distinction.
lis   list (list merge sort) list-delete-neighbor-dups lis = -> list  list-delete-neighbor-dups!
list-delete-neighbor-dups does not alter its input list; its answer may share  storage with the input list.
the implementation of vector merge sort provided by this srfi's reference implementation is, additionally, a "natural" sort, meaning that it exploits existing order in the input data, providing o(n) best case.
say c-h m for instructions on how to move through it by sections (e.g.,  c-c c-n, c-c c-p).
heap-sort  returns a vector of length end-start.
implementors want this code.
what's wrong with the current state of affairs?
the software is provided "as is", without warranty of  any kind, express or implied, including but not limited to the warranties of  merchantability, fitness for a particular purpose and noninfringement.
-------------------------------------------------------------------------------
here are my notes from the systems i checked.
has good memory locality for big vectors (unlike  heap sort).
v  boolean vector-merge v1 v2  vector  vector-merge!
but you could, of course -- it's freely  available.
examples: (list-delete-neighbor-dups '(1 1 2 7 7 7 0
it is necessarily the  case that the specifications of these procedures make statements about  execution "pragmatics."
but if your scheme has a faster mechanism (e.g., chez), you should definitely port over to it.
the vector is not altered outside the range [start,end').
vector merge sort stable.
end, and will not be altered outside the range [start,end).
vector merge sort (stable) - pure and destructive list merge sort (stable) - stable vector and list merge - miscellaneous sort-related procedures: vector and list merging, sorted?