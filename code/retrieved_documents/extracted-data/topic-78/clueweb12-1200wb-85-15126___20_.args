one of the advantages of carrying out ranking rather than sorting is that the index array can be computed without the performance penalty of moving the elements around when they are of large sizes.in many instances, it suits better the actual need of the user, who can then use the index array to order other related sets or to select some elements, than a sorting program would.such unique ranking routines allow users to isolate individual cases out of a mass of discrete data.it also has better worst case behavior than valnth/indnth, and is about 20% faster in average for random uniformly distributed values.it also has better worst case behavior than indnth, but is about 10% slower in average for random uniformly distributed values.ranking consists in finding, for each element of a set, its rank in the sorted set, without effectively changing the initial order (or disorder !) of the set.but if one wants an optimized program, one takes this simple implementation, and looks for redundant operations, investigates runs with sample data sets with a profiling tool, and is led to duplicate code with slight modifications rather than use tests in inner loops, to process differently the first and the last iterations, or to take into account some special cases that are only special in that they can be done faster.such a routine would prove useful in finding a limited number of unique values in an array.in some instances, one is not actually interested in modifying the order of the elements in a set, but only in knowing how to access them in increasing -- or decreasing -- order.in most cases, the quicksort or merge sort method is faster.this is fine and recommended for small programs, but yet may lead to architecture andmakefile problems for large applications.ranking is especially needed when the sizes of the elements are large, and that moving them around is resource-consuming.in many cases, the refined quicksort method implemented by valnthÂ / indnth is faster, though much more difficult to read and understand.in many cases, the refined quicksort method implemented by valnth / indnth is faster, though much more difficult to read and understand.to show the potential speed gains, we conducted an experiment involving 100,000 trials of simulating a random vector of length 500 with duplicates and ranking the 9 smallest unique elements (duplicates discarded).