this means that they will be more robust and hopefully faster.so the 5.8 quicksort scrambles large arrays before sorting them, as a statistical defence against quadratic behaviour.for very small lists this may result in slightly slower sorting times, but in general the speedup should be at least 20%.quicksort has a worst case run time that can grow like n**2, so-called quadratic behaviour, and it can hap- pen on patterns that may well arise in normal use.modules may fail to compile at all, or they may compile and work incorrectly.this algorithm is reasonably fast while producing a much better spread of values than the old hashing algorithm (originally by chris torek, later tweaked by ilya zakharevich).the quicksort divide and conquer strategy works well on platforms with relatively small, very fast, caches.with these, you can implement rather advanced parsing algorithms.these failures are unlikely to get fixed as 5.005-style threads are considered fundamentally broken.the aix c compiler vac version 5.0.0.0 may produce buggy code, resulting in a few random tests failing when run as part of "make test", but when the failing tests are run by hand, they succeed.· the "exec list" and "system list" operations now produce warnings on tainted data and in some future release they will produce fatal errors.additional bonuses are that the worst case behaviour ofsort() is now better (in computer science terms it now runs in time o(n log n), as opposed to quicksort’s theta(n**2) worst-case run time behaviour), and thatsort() is now stable (meaning that elements with identical keys will stay ordered as they were before the sort).it is now implemented using a windows message loop, and is there- fore less prone to random crashes.this seems to be a compiler error since if compiled with gcc no core dump ensues, and no failures have been seen on the said test on any other platform.[561] · the perl parser has been stress tested using both random input and markov chain input and the few found crashes and lockups have been fixed.