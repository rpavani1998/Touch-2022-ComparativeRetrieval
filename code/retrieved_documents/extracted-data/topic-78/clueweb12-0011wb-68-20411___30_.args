this will freeze the database, making it a very good tool to do consistent backups.this feature is very useful if you need all your transactions to behave as if they are running serially, without sacrificing too much throughput, as is currently the case with other 'serializable' isolation implementations (this is usually done by locking every record accessed).one of the really great features of synchronous replication is that it is controllable per session.an unlogged table is much faster to write, but won't survive a crash (it will be truncated at database restart in case of a crash).this still is synchronous replication because no data will be lost if the master crashes.performance improvements synchronous writes have been optimized to less stress the filesystem.there is another benefit: we can slice the array when it is multidimensional.as we're only retrieving data from a file, it seems to be overkill, but sql/med is also capable of coping with remote databases.it was a major setup problem with 9.0: a vacuum could destroy records that were still necessary to running queries on the slave, triggering replication conflicts.with the trigger, we added some logic, we could send more useful error messages.but performance and responsiveness (latency) has been greatly improved on write intensive loads.this new tool is used to create a clone of a database, or a backup, using only the streaming replication features.it's better, from a security point of view, than having a superuser role doing this job.there are other new replication features for postgresql 9.1: it was a major setup problem with 9.0: a vacuum could destroy records that were still necessary to running queries on the slave, triggering replication conflicts.it was a very common trap, this type of queries became dramatically slower when one was partitioning his/her data.