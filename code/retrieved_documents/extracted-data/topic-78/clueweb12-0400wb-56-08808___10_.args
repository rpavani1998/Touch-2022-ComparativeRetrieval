these packages provide more specific sorting functionality, that is, specific committment to particular algorithms that have particular pragmatic consequences (such as memory locality, asymptotic running time) beyond their semantic behaviour (sorting, stable sorting, merging, etc.).a clever pivot-picking trick (median of three samples) helps avoid worst-case behaviour, but pathological cases can still blow up.additionally, list-merge! is iterative, not recursive -- it can operate on arguments of arbitrary size without requiring an unbounded amount of stack space.different algorithms have different properties, both semantic & pragmatic, so these exports are necessary.this srfis destructive list merge and merge sort implementations are opportunistic -- they avoid redundant set-cdr!s, and try to take long already-ordered runs of list structure as-is when doing the merges.sorting vectors has inherently better locality.the sort procedures sort their data using a list merge sort, which is stable.the implementation of vector merge sort provided by this srfi's reference implementation is, additionally, a "natural" sort, meaning that it exploits existing order in the input data, providing o(n) best case.similar resource-use statements are made about "iterative" procedures, meaning that they can execute on input of arbitrary size without needing to allocate an unbounded number of stack frames.however, all such code is, itself, either open source or public domain, rendering irrelevant any issue of "copyright taint."the natural merge sorts (pure list, destructive list, and vector) are not only my own code, but are implementations of an algorithm of my own devising.the merge operations are stable: an element of lis1 will come before an equal-comparing element in lis2 in the result list.the merge operations are stable: an element of v1 will come before an equal-comparing element in v2 in the result vector.these procedures are linear time -- much faster than the o(n^2) general duplicate-element deletors that do not assume any "bunching" of elements (such as the ones provided by srfi-1).having the source available for all of these above-cited schemes made life a lot easier writing this code.