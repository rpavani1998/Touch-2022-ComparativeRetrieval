this approach has a further benefit: it makes it more likely that the function will only return a single type.as we will see insection 8.6, the space of possible parse trees is very large; a parser can be thought of as providing a relatively efficient way to find the right solution(s) within a very large space of candidates.to illustrate the difference in efficiency, we will create a list of 1000 numbers, randomize the list, then sort it, counting the number of list manipulations required.now we can try a simple sort method called bubble sort, that scans through the list many times, exchanging adjacent items if they are out of order.however, nltk also provides several algorithms for sorting lists, to illustrate the variety of possible methods.now, as we saw above, python provides a built-in function sort() that performs this task efficiently.sorting algorithms now, as we saw above, python provides a built-in function sort() that performs this task efficiently.we can compare its performance by timing how long it takes to execute it a million times.this class is derived from python's built-in list class, permitting us to use standard list operations to access the children of a tree node.for example, the task of a parser is to identify one or more parse trees for a given sentence.we can use lists to implement so-called abstract data types such as stacks and queues.we can try the same task using various sorting algorithms.before we can begin we have to be explicit about how the complexity of a sentence is to be measured: word count, verb count, character count, parse-tree depth, etc.the stack keeps track of this level of nesting, exploiting the fact that the item at the top of the stack is actually shared with a more deeply nested item.however, we can use stacks for more sophisticated processing of strings containing nested structure, as shown inexample 4.3.