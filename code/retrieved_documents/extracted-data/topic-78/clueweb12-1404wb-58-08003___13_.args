instead, we can just keep a stack of "calls" to quicksort that we want to make, and execute the appropriate code within our getenumerator() method, so we can yield at the right point.it just feels right to have both the primary and secondary key selectors in the same type, which is what will happen with the current code.one tiny micro-optimization point to note is that for each loop i'm using the length property of the array rather than "count" as the upper bound, as i believe that will reduce the amount of array boundary checking the jit will generate.we're definitelycomputing the earliest results first, due to the order of the recursion - but we can't yield from the recursive method - iterator blocks just don't do that.this site is automatically generated and cannot be reviewed for abusive content.just as a reminder, one of my aims was to be able to use iterator blocks to return some values to anyone iterating over the result stream without having to doall the sorting work.now we can easily create a projection from two key selectors to a new one which selects a composite key.the actual quicksort part is reasonably standard except for the fact that i pass in both the arrays for both indexes and keys - usually there's just the one array which is being sorted.for various reasons (mentioned inpart 26b) life is better if we execute the key selector once per input element.for type parameters it's not too bad, but for normal parameters it can be awful if you mess around with the names - particularly for those using named arguments.the basic results are very roughly: when evaluating the whole ordered list, edulinq appears to run about 10% faster than linq to objects when evaluating only the top 5 of a large ordered list, edulinq can be much faster.addendum an earlier version of this post (and the merge sort implementation) had a flawed piece of code for choosing the pivot.this evening, having pulled the "early out" code from the source repository, the edulinq implementation is running faster than the linq to objects implementation even when the "early out" isn't actually doing much good.left, i.e. we're sorting one element, or right == left - 1, which will occur if we picked a pivot which was the maximum or minimum value in the list at the previous recursive step.once partition has returned where the pivot element ended up, quicksort doesn't touch that element itself (we already know it will be in the right place).