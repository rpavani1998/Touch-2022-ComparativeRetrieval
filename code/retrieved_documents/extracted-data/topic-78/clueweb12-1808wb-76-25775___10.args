instead of examples of specific code macros (general or not) it would be nice to see common programming practices using macros.
i enjoyed most of the talks and still had an opportunity to talk with fellow lispers.
one of the main points was that lispers should not use constructions which are not part of the standard language when the standard provide options, just because you want to save some typing.
jack harper talked about the company he recently started, secure outcomes, that produces a unique portable fingerprint scanner.
my perception is that the possibility to enable hacking as it was possible with clbuild is one of the most exciting future features for quicklisp.
the only source file i could find with a sort implementation wassort.d and it looks like it contains an implementation of tree sort with a self-balanced binary tree, which also gives this algorithm an average and worst-case performance of o(nlgn).
still, nick levine talk was good and entertaining.
he started by telling how a group of hackers with a lisp and/orerlang background got together to improve the mobile tcp/ip communications.
in the afternoon the talks started with paul miller from xanalys.
he started talking aboutgdl, the main product from his company, genworks.
thanks to quicklisp, the problem now is not installing libraries but finding them and knowing which ones are good.
i enjoyed talking withluís oliveira and meeting zach beane.
cliki still seems to me the best starting point.
in the end, it always depends on the project, the people, etc, but code style is important and should not be ignored.
quicksort has a worst-case performance of o(n2) but it can be optimized in several ways so that it also gives an expected worst-case performance of o(nlgn).
this is a problem that exists in the current1.0.1 release but i’ve sent a bug report with a quick fix to the maintainers.
the plan is to add more algorithms, for example,bucket sort and timsort.
then he proceed to how quicklisp was developed, some technical issues, what is the role of quicklisp and what is the reception after one year.
the main goal of zsort is to be a collection of portable sorting algorithms.
another interesting point of the talk was that cl is used as their main development language.
i am not sure if creating another site as suggested would be a good thing since resources are already scarce.
however, the main thing on the todo list is adding the possibility ofexternal sorting (to handle large amounts of data) and parallel versions of some sorting algorithms.
i was only present at the meeting itself since going to the dinners and city tour would have been way out of my budget.
the best and most awaited talk, quicklisp, technically and socially , was given byzach beane.
one of the things that makes zach happy it’s the number of emails he gets saying that people are back to using cl and contributing more to the community (i.e., making libraries available) because of ql.
also, the standard functions might not be the best for a certain situation and as such you might need a specialized sort.
apparently, all implementations are bottom-up merge sorts with the exception of ccl and ecl.
paul also gave us a demonstration of the tool as well as some notes on future development.
the application is quite impressive and was developed using just cl.
ccl chooses the pivot with a median-of-3 method and always sorts the smaller partition to ensure a worst-case stack depth of o(lgn).
if they can be fast, even better.
in the same way a programmer shouldn’t implement a sorting algorithm every time it needs to sort something, the programmer should also be aware of the limitations/advantages of the system sort.
in a survey he did, most cl programmers were installing libraries by hand, including zach!
the most interesting bits were:marco antoniotti announced els 2012, to be held in zadar, croatia, around april-may;christophe rhodes talked again about swankr, a swank and slime for r; theannouncement of abcl 1.0.0 by erik huelsmann.
thanks to quicklisp, the problem now is not installing libraries but finding them and knowing which ones are good.
i just made the basic drive rover with some sounds.
while reading the source code of the implementations, i realized that abcl was using quicksort in stable-sort for all non-list sequences.
moreover, all their analysis and maintenance tools are also all in cl.
i am not sure if creating another site as suggested would be a good thing since resources are already scarce.
moreover, we keep the algorithm in a single place, making it easier to maintain.
one of the main points was that lispers should not use constructions which are not part of the standard language when the standard provide options, just because you want to save some typing.
another interesting point of the talk was that cl is used as their main development language.
hans also talked abut the 80-column rule, style guides, etc.
zach started by giving an overview of the famous library problem of cl, the solutions that existed before ql, explaining their advantages and disadvantages.
zach started by giving an overview of the famous library problem of cl, the solutions that existed before ql, explaining their advantages and disadvantages.
the talk focused then on the social impact of quicklisp in the community.
in addition, we might also want the possibility of using a key to access the vector elements.
in the same way a programmer shouldn’t implement a sorting algorithm every time it needs to sort something, the programmer should also be aware of the limitations/advantages of the system sort.
if one knows the properties of the data, it is possible to understand if the provided sort can or will pose a problem.
even if for most situations the standard functions are more than enough, thezsort library could be a useful complement.
however, i found it surprising to find quicksort in the stable-sort column because it is not a stable algorithm.
it was quite interesting to see how hard can it be to prepare a book, especially for a publisher who was (is?)not very lisp-friendly.
not all was perfect but everything went smoothly.
moreover, all their analysis and maintenance tools are also all in cl.
hans also talked abut the 80-column rule, style guides, etc.
in addition, he also explained why prefers lispworks to any other implementation.
apparently, all implementations are bottom-up merge sorts with the exception of ccl and ecl.
this was the interesting part of the talk since he explained the aims of clf, the people behind it, etc.
i must confess his talk was the weaker of the day mainly because he talked about two different subjects without any connection.
written by jorge tavares june 13, 2011 at 10:18 posted in programming tagged with fun, lego mindstoms, lisp« older entries blog at wordpress.com.
however, it was not clear how it will distinguish itself from alu in terms of operation (in terms of purpose, clf just focus on common lisp while alu in all lisp dialects) and this was the main concern that was expressed during the questions time.
if you want to share, feel free to drop a line.
the difference between the two is that the second function sorts in a way that guaranteesstability, i.e., two elements that are equal remain in the same position after sorting is completed.
after presenting clf, and since there was still some time left for the next presenter, he went back to gdl.
it is more important for another programmer to understand faster what is written than forcing him to look for the definition of the unusual constructs.
this is a problem that exists in the current1.0.1 release but i’ve sent a bug report with a quick fix to the maintainers.
luke concluded by hinting that the sales of their product is going very well!
while reading the source code of the implementations, i realized that abcl was using quicksort in stable-sort for all non-list sequences.
this was the interesting part of the talk since he explained the aims of clf, the people behind it, etc.
then, he showed us how tcp badly misbehaves in a mobile network and how their product,sambal, can give 10% to 27% improvements.
something more like lejos would be nicer (but in common lisp).
paul also gave us a demonstration of the tool as well as some notes on future development.
if we want a simple-vector, the macro will expand to use the correct type declaration and svref.
ccl chooses the pivot with a median-of-3 method and always sorts the smaller partition to ensure a worst-case stack depth of o(lgn).
in the first one, he talked about his experiences of trying to write acl book foro’reilly.
with 6 comments zsort is a library that i started working on as a simple hobby project.
if we want a simple-vector, the macro will expand to use the correct type declaration and svref.
he started by telling how a group of hackers with a lisp and/orerlang background got together to improve the mobile tcp/ip communications.
moreover, we keep the algorithm in a single place, making it easier to maintain.
this can be very useful in situations where we want to optimize code since it becomes easy to add the proper type declarations to the input arguments of an algorithm.
my perception is that the possibility to enable hacking as it was possible with clbuild is one of the most exciting future features for quicklisp.
even if for most situations the standard functions are more than enough, thezsort library could be a useful complement.
i was only present at the meeting itself since going to the dinners and city tour would have been way out of my budget.
unless you know your input data has some special properties that you can take advantage of, the provided sort should be enough for your needs and probably is more efficiently implemented.
the only source file i could find with a sort implementation wassort.d and it looks like it contains an implementation of tree sort with a self-balanced binary tree, which also gives this algorithm an average and worst-case performance of o(nlgn).
there is still a lot of work to be done, but i think the library as it is can already be a little useful.
in addition, we might also want the possibility of using a key to access the vector elements.
the main goal of zsort is to be a collection of portable sorting algorithms.
in the end, it always depends on the project, the people, etc, but code style is important and should not be ignored.
if a key function is needed it will also include it.
in addition, he also explained why prefers lispworks to any other implementation.
anyway, the eclm was a nice venue.
quicksort has a worst-case performance of o(n2) but it can be optimized in several ways so that it also gives an expected worst-case performance of o(nlgn).
however, in the actual product boxes they have reimplemented the algorithms in c. the reason: extreme pragmatism.
the application is quite impressive and was developed using just cl.
so, for a lack of a better expression name, let’s call themmacros design patterns.
luke concluded by hinting that the sales of their product is going very well!
i think there is still room for improvement in some implementations but knowing now the strengths and weaknesses of the sorts in cl is already good enough.
according to each implementation, which can make an application unportable if you rely on a specific type of sorting.
the plan is to add more algorithms, for example,bucket sort and timsort.
this can be very useful in situations where we want to optimize code since it becomes easy to add the proper type declarations to the input arguments of an algorithm.
in the first one, he talked about his experiences of trying to write acl book foro’reilly.
i was curious about it and went to check the source forabcl, ccl, clisp, cmucl, ecl and sbcl.
i must confess his talk was the weaker of the day mainly because he talked about two different subjects without any connection.
also, and very important, what people were actually using and what difficulties they were facing.
jack harper talked about the company he recently started, secure outcomes, that produces a unique portable fingerprint scanner.
the talk was dedicated tolink explorer, a windows desktop tool to analyze data.
the talk focused then on the social impact of quicklisp in the community.
if one knows the properties of the data, it is possible to understand if the provided sort can or will pose a problem.
anyway, the eclm was a nice venue.
also, the standard functions might not be the best for a certain situation and as such you might need a specialized sort.
after presenting clf, and since there was still some time left for the next presenter, he went back to gdl.
i’ve learned what algorithms are actually used and enjoyed seing how they were implemented.
it was quite interesting to see how hard can it be to prepare a book, especially for a publisher who was (is?)not very lisp-friendly.
common lisp provides thesort and stable-sort functions but these can have different algorithms implemented according to each implementation, which can make an application unportable if you rely on a specific type of sorting.
they have a tcp/ip stack fully implemented in cl!
then, he showed us how tcp badly misbehaves in a mobile network and how their product,sambal, can give 10% to 27% improvements.
i’ve learned what algorithms are actually used and enjoyed seing how they were implemented.
one of the things that makes zach happy it’s the number of emails he gets saying that people are back to using cl and contributing more to the community (i.e., making libraries available) because of ql.
i find it very useful.
the talk was dedicated tolink explorer, a windows desktop tool to analyze data.
unless you know your input data has some special properties that you can take advantage of, the provided sort should be enough for your needs and probably is more efficiently implemented.
it is more important for another programmer to understand faster what is written than forcing him to look for the definition of the unusual constructs.
however, it was not clear how it will distinguish itself from alu in terms of operation (in terms of purpose, clf just focus on common lisp while alu in all lisp dialects) and this was the main concern that was expressed during the questions time.
another interesting thing is that merge sort is also used for lists in sort, in most of the implementations.
the most interesting bits were:marco antoniotti announced els 2012, to be held in zadar, croatia, around april-may;christophe rhodes talked again about swankr, a swank and slime for r; theannouncement of abcl 1.0.0 by erik huelsmann.
then he proceed to how quicklisp was developed, some technical issues, what is the role of quicklisp and what is the reception after one year.
instead of examples of specific code macros (general or not) it would be nice to see common programming practices using macros.
in ecl (and abcl) quicksort implements a partition scheme which deals better with duplicate elements (although is not the three-way partitioning) but it always picks as pivot the first element.
i think there is still room for improvement in some implementations but knowing now the strengths and weaknesses of the sorts in cl is already good enough.
however, i found it surprising to find quicksort in the stable-sort column because it is not a stable algorithm.
also, and very important, what people were actually using and what difficulties they were facing.
as before, the internal language it’s a bit limited.
in ecl (and abcl) quicksort implements a partition scheme which deals better with duplicate elements (although is not the three-way partitioning) but it always picks as pivot the first element.
another interesting thing is that merge sort is also used for lists in sort, in most of the implementations.
i enjoyed most of the talks and still had an opportunity to talk with fellow lispers.
something more like lejos would be nicer (but in common lisp).
still, nick levine talk was good and entertaining.
this exploration of the sorting algorithms used in the open source implementations was very educational and interesting to me.
however, the main thing on the todo list is adding the possibility ofexternal sorting (to handle large amounts of data) and parallel versions of some sorting algorithms.
these kind of threads are always enjoyable because each time you learn something new and see really interesting things.
the use of sort and stable-sort requires some care (see the section sort pitfalls) but lets focus on the algorithms and not on its usage.
as expected, most of the implementations use merge sort to implement stable-sort since it is a stable sort with average and worst-case performance of o(nlgn).
still, it was also quite interesting.
if you want to share, feel free to drop a line.
as expected, most of the implementations use merge sort to implement stable-sort since it is a stable sort with average and worst-case performance of o(nlgn).
this exploration of the sorting algorithms used in the open source implementations was very educational and interesting to me.
these kind of threads are always enjoyable because each time you learn something new and see really interesting things.
in a survey he did, most cl programmers were installing libraries by hand, including zach!
the difference between the two is that the second function sorts in a way that guaranteesstability, i.e., two elements that are equal remain in the same position after sorting is completed.
the macro contains the algorithm (in this simple case the mean) and the arguments allow us to configure the multiple versions we need.
so, for a lack of a better expression name, let’s call themmacros design patterns.
he started talking aboutgdl, the main product from his company, genworks.
there is still a lot of work to be done, but i think the library as it is can already be a little useful.
the macro contains the algorithm (in this simple case the mean) and the arguments allow us to configure the multiple versions we need.
cliki still seems to me the best starting point.