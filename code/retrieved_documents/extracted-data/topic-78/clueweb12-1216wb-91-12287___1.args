to start with, we can set up a binary tree of the right size and shape, and put the objects into the tree in any old order.
to make the whole thing a heap, we merely have to percolate that value down to a lower level in the tree.
it also uses even fewer comparisons than heapsort, and is especially suited for data stored as linked lists.
<= 2 n log n. note that this is worse than either merge sort or heap sort, and requires random number generator to avoid being really bad.
it can be done in a way that uses very little extra memory.
different methods work better in different applications.
heapsort uses close to the right number of comparisons but needs to move data around quite a bit.
<= 2 n log n. note that this is worse than either merge sort or heap sort, and requires random number generator to avoid being really bad.
merge sort is good for data that's too big to have in memory at once, because its pattern of storage access is very regular.
it's probably good when memory is tight, and you are sorting many small items that come stored in an array.
like heapsort it can sort "in place" by moving data in an array.
to start with, we can set up a binary tree of the right size and shape, and put the objects into the tree in any old order.
to make the whole thing a heap, we merely have to percolate that value down to a lower level in the tree.
