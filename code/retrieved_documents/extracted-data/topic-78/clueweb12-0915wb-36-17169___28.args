ruby passes objects by reference.
finally, a hundred thousand element array; sorry for the lack of stats, but i was too impatient to let insertion_sort finish.
this is actually really cool; each scale, in addition to being unique in that, well, it has a different root note, is unique in that it is the only scale to have its specific number of sharps or flats.
note: i did take a liberty in the above listing of what’s happening; in actuality the entire array is passed each time; i made it look as though just the subarray were being passed in each case, because that is the only part that is being looked at in each nested section.
this is actually really cool; each scale, in addition to being unique in that, well, it has a different root note, is unique in that it is the only scale to have its specific number of sharps or flats.
well, the main reason is that both of these methods are significantly slower than good old array::sort, which is built in to ruby (and which, as far as i know, is implemented using thequicksort algorithm).
a sharp or flat is added or removed each increment you go around the circle.
one does not simply walk into mordor oct 22nd, 2010 by land and by sea and by reference oct 6th, 2010 photo source i recently attempted to fit the quicksort algorithm into under 140 characters of ruby.
fun with the major scale aug 11th, 2010 got to chatting with nate (@fowlduck) about musical notation last night.
our original objects were changed when they were modified inside the method.
1 end in other words, it pays to know your math.
i could alter it, still: if i changed the reassign method so that it didobj.replace("some new value!") inside the method body, the original object would be changed, just likeshiftit did to the array and the hash.
this post is not meant to be a defense of music notation, a “setting straight” of anything, or even a definitive description of musical theory (at which i’m a rank amateur).
not content to simply feed it one sample, i fed it the text from several of the posts from the archive.
i know, i know, the faux motivational poster is an old and tired meme.
ruby quite definitely, always, passed objects by reference.
aug 4th, 2010 pic taken along the trail on the way from minneapolis to hopkins.
even when i realized this was happening, i still made the mistake of just doing tmp = sequence on my first try.
jul 29th, 2010 i gave a short presentation on rvm on monday at rum.
if you’re bothering to read this and it still isn’t clear, just run the sort locally and add some puts statements liberally so you can see what’s going on.
ruby quite definitely, always, passed objects by reference.
given the above system, the major scale in one key and one key only will have no sharps or flats.
the thing that makes it seem so strange is, at least in part, the major scale.
you’ll find that any method of modifying an object inside another method with actually change (even delete, if you go that far) the original object that you passed in.
(using quicksort) isway faster: only 0.000016 seconds.
seemathematics of musical scales and tuning systems for more.
a sharp or flat is added or removed each increment you go around the circle.
this post is not meant to be a defense of music notation, a “setting straight” of anything, or even a definitive description of musical theory (at which i’m a rank amateur).
the thing that makes it seem so strange is, at least in part, the major scale.
when i tell ruby that foo = "bar", ruby binds the local variable namedfoo to a string object, “bar”.
again, if you’re interested enough in the topic that you’re still working out this algorithm, fire up irb and just try it out, it will make more sense as you do so.
here were the results: user system total real small_array has 100 elements in it...
our original objects were changed when they were modified inside the method.
aug 11th, 2010 got to chatting with nate (@fowlduck) about musical notation last night.
when i tell ruby thatfoo = "bar", ruby binds the local variable namedfoo to a string object, “bar”.
so, let’s just accept the scale as a given; that this pattern of whole tones and semi-tones sounds pleasing to the ear.
no good; same exact problem.tmp is now just a reference straight tosequence, so altering tmp modifiessequence as well.
so, evidently, according to their analyses, i write most often like cory doctorow.
tmp is now just a reference straight to sequence, so altering tmp modifies sequence as well.
i could alter it, still: if i changed the reassign method so that it did obj.replace("some new value!") inside the method body, the original object would be changed, just like shiftit did to the array and the hash.
so, let’s just accept the scale as a given; that this pattern of whole tones and semi-tones sounds pleasing to the ear.
so the reason this is how not to write sorting algorithms in ruby is simply that, you really probably don’t need to, unless you need something faster than a quicksort written in c. the reason, hopefully, to be playing around writing algorithms in ruby or inwhatever your favorite language happens to be, is just to understand them better.
you’ll find that any method of modifying an object inside another method with actually change (even delete, if you go that far) the original object that you passed in.
the emperor’s new web not sure how they are analyzing the text and reaching their conclusions, but there’s at least alittle bit of smarts in there; that last one, the one which was compared to swift, is indeed a satire, though i’m not going to claim it’s in the calibre of swift’s satire, but still; their algorithm picked something out of it which prompted the comparison.
the small array is pretty fast for all three methods, but even still, we can see that merge_sort is alittle faster, and the built in .sort!
=> nil so, assignment inside a method doesn’t change our object.
a ten thousand element array starts to show the difference even more dramatically: insertion_sort now takes 24.1 seconds, close to half a minute, while the merge_sort still runs in under a second.
as the method returns from each level of recursion, each “half” of the subarray under consideration has been sorted, until it gets all the way back to the first call to merge_sort, and executes merge on each (sorted) half of the full array.
so, just for fun, i wrote a little script to make some benchmarks of these various methods on arrays of various sizes.
i’ve only readdown and out in the magic kingdom, and several of his blog posts/essays, but enough to consider it a compliment, though i’m not certain it’s deserved.
"some new value" inside the method scope, trying to reassign foo, ruby sees that i’m binding foo to a new value; but from inside method scope, ruby is not going to let me change the binding from another scope.
so instead, ruby figures that i want a local variable that is also named foo, inside my method scope, and it assigns my new value to the local foo, not the original foo.
seemathematics of musical scales and tuning systems for more.
"some new value" inside the method scope, trying to reassign foo, ruby sees that i’m binding foo to a new value; but from inside method scope, ruby is not going to let me change the binding from another scope.
oct 22nd, 2010 oct 6th, 2010 photo source i recently attempted to fit the quicksort algorithm into under 140 characters of ruby.
given the above system, the major scale in one key and one key only will have no sharps or flats.
(again), way faster, only 0.00016 seconds.
the next bigger, bigger_array, the differences stand out a little more.
the slides can be found at rubymn-rvm.heroku.com.
he was pointing out that bits of the notation seem arbitrary and probably archaic, likening it to legacy code of a sort.
he was pointing out that bits of the notation seem arbitrary and probably archaic, likening it to legacy code of a sort.
ruby passes objects by reference.
for one, we want to be able to express every scale by naming off the notes, and we’d like each note to be a different letter.
then it calls itself recursively on each subarray; these in turn will continue splitting each subarray into two parts until it gets to the point where it’s just two subarrays of one element each; which are then fed to merge and sorted.
so instead, ruby figures that i want a local variable that is also named foo, inside my method scope, and it assigns my new value to the localfoo, not the original foo.
this time, to show what the recursion is actually doing, i’ll write out what each nested call to merge_sort( and/or merge) would actually look like: starting array: [5,2,3,1,4,0] merge_sort([5,2,3,1,4,0], 0, 5): mid <- 2 merge_sort([5,2,3], 0, 2): mid <- 1 merge_sort([5,2], 0, 1): mid <- 0 merge_sort([5], 0, 0): merge_sort([2], 1, 1): merge([5,2],0, 1, 1): left <- [5,∞] right <- [2,∞] loop(0..1): [2,5] # just showing the result in this step; the two elements are sorted.
so for fun, we can explore the circle of fifths in the command line.
for one, we want to be able to express every scale by naming off the notes, and we’d like each note to be a different letter.
