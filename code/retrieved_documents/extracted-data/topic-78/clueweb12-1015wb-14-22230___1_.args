comparison sorts and general purpose sorts a comparison sort is a sorting algorithm where the final order the items end up in is determined only by comparisons between individual items of input.in merge sort, the merge procedure chooses an item from one of two arrays after comparing the next item from both arrays.in heap sort, the heapify procedure determines where to place items based on their comparisons with adjacent elements of the tree.we require only "constant" storage and time to store and process the arrayc. this sort is very sensitive to the kinds of data to be stored; they must be integral (like integers and characters) and they must be in a very small range.it turns out we can use astable version of counting sort as the basis for another sort calledradix sort that can sort a much wider range of data, like character strings and numbers with small decimal representations.for an array of pointers to character strings, thestrcmp function works fine.qsort is a randomized version of quicksort with very good performance.since the number of comparisons is at least the number of array accesses or other operations, this is the lower bound on the worst case time-complexity of any comparison sort.any sorting algorithm at all, comparison or not, has a trivial( n) lower bound time complexity; it has to at least examine alln elements of the array before it can guarantee they are sorted.linear-time sorting algorithms any sorting algorithm at all, comparison or not, has a trivial( n) lower bound time complexity; it has to at least examine alln elements of the array before it can guarantee they are sorted.if we ignore the procedural aspects of these algorithms and look only at the data being sorted, we see that each comparison results in at most one change in the order of the array, e.g.,in the worst case, the sorting algorithm will have to "search" all the way down to a leaf node, so( n ln n) comparisons is the best a comparison sort can be expected to do.in the worst case, the sorted permutation may be a leaf node, requiring a number of comparisons proportional to the height of the tree.so sorting is like a search from the initial permutation (root) to the sorted permutation (some node in the tree).for example, the followingdecision tree shows the movement of data in the bubble sort algorithm performed on three items (the tree is not complete; it is large): { a b c } / \ / \ / \ a b / \ { a b c } { b a c } b  c a c / \ / \ { a b c } { a c b } { b a c } { b c a } / \ / \ / \ a general purpose sort is a sorting algorithm that works on any kind of ordered data.we could use quicksort or merge sort, but these are really overkill.