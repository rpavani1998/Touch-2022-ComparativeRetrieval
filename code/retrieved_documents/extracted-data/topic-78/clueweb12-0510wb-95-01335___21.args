in short, an invention is not patentable, for lack of novelty, if the claimed subject matter was disclosed before the date of filing.
the number of comparisons and array accesses however grows quadratically with n for all the elementary sorting algorithms discussed so far, and more sophisticated algorithms become faster.
by the same token, an evaluation is based on patent documents, witnesses, expert witnesses, other admissible evidence, presentations of the parties involved etc as input, together with relevant legal rules for determination of an infringement or related validity contest.
for example, inspecting the codes of selection sort, insertion sort, bubblesort, and should we have presented them also quicksort and mergesort, one would notice that the algorithms never arrive at a value in the middle of the array without first traversing through adjacent places from either edge of the array.
by breaking the compared values into parts, however, one can sort even faster.
insertion sort, as we presented it, is not stable whereas bubblesort is.
the idea is to treat the keys as a sequence of units, for example characters.
as the output of the algorithm one might also regard the memory consumption and computing time.19
in such a case, the test could be devised so that a part of the group searches the literature and the internet for similar existing algorithms, and presents them to the remaining group along with the algorithm of the inventor.
it exhibits similar performance characteristics as quicksort, but the computer science community again considers it a new sorting algorithm in its own right.
indiamond v diehr25 , for example, a case concerning a patented rubber curing method involving an arrhenius equation26 in algorithmic form, the us supreme court excluded from patent protectionlaws of nature, natural phenomena, and abstract ideas.
in a word processor, for example, input is via the keyboard and mouse, and output is the display.
it is also possible however that a device, even though it falls within the literal description of a claim of patent, to perform the same or a similar function as the patented device but in a way that is substantially different.
for example, to change the sorting algorithms output from ascending to descending order requires such a trivial variation in the code that no one would consider the modified code to implement a different algorithm.
another one may well be that the searches for prior art are far less than optimal and result in the granting of overlapping patents, which is widely recognised as a problem.35 alternatively, one might ask whether computer scientists granted patents on early elementary sorting algorithms, such as selection and insertion sort, are distinct algorithms of a lower status than sorting algorithms developed later.
if these experts can within, say, an hour of discussion present solutions close to those of the inventor, then a sufficient level of non-obviousness has clearly not been reached.
this moving to adjacent values and also the swapping of values can be performed equally well on linked lists as on arrays: incrementing the indexes i and j to the array x is replaced by following the next-fields in the linked lists nodes; swapping values in two indexes is replaced by a handful of linked list manipulation statements.
a subtler change in output, for example the stability of sorting – whether the sorting algorithm preserves the relative order of equal values – can, however, be a distinguishing factor.
the non-obviousness or inventive step in patenting is directly linked both to the existing knowledge made public in the field, and to the expertise of an average professional skilled in the relevant trade.33
in a sense, patent law gives the applicants a certain freedom of discretion to define the scope of their claimed invention, provided the mentioned exclusions do not apply, and the application is sufficiently disclosed.
by generalising the type the very same code (and consequently the same algorithm) is able to sort integers, strings, names of people, phone numbers, dates, addresses, etc.
the idea is to treat the keys as a sequence of units, for example characters.
28 u.s. patent code § 112; additionally, in the us the “best mode requirement” also limits the spectre of the claims in this respect.
in software patenting, understood broadly, algorithms, data structures, protocols, software architectures and designs have in practice been granted patents.
in the patenting law context, the motivation to obtain the broadest possible monopoly and the widest available protection for the invention is an incentive to couch applications in terms that are as generic as possible.
in such a case, the test could be devised so that a part of the group searches the literature and the internet for similar existing algorithms, and presents them to the remaining group along with the algorithm of the inventor.
unfortunately problems are seldom sufficiently well-defined and consequently there is rarely ever a chance for a group of experts to converge upon a solution near to that of the inventor.
consequently, there is no reason why the very same sorting algorithm could not sort the appendix of references in a book, a row of integers in lotto, or the chronological schedule of departing flights on the airport.
the operating system that provides the file access primitives to the word processor views the requests of the word processor in reversed roles.
the non-obviousness or inventive step in patenting is directly linked both to the existing knowledge made public in the field, and to the expertise of an average professional skilled in the relevant trade.33
we then reserve one bucket for each distinct character and with one pass through the values to be sorted we can place all values which begin with character 'a' into the bucket for characters 'a', values which begin with 'b' to the bucket for 'b's, etc.
according to computing folklore, selection and insertion sorts are the fastest sorting methods for array sizes up to around ten or twenty.
a similar process of abstraction of internal details can be used to create amalgamates of sorting algorithms.
it has been shown mathematically that no sorting algorithm based on comparing entire values can be faster than quicksort or merge sort by more than a constant factor.
if the algorithm of the inventor is judged between themselves to be more similar to one of the prior algorithms than the existing algorithms, then the algorithm of the inventor would not be judged as sufficiently non-obvious.
the suspect invention is therefore, in principle, so far removed from the invention as disclosed in the patent that it is considered in law to be an entirely different thing.
if, having regard to the state of the art, it is not obvious to a person skilled in the art.”
a similar process of abstraction of internal details can be used to create amalgamates of sorting algorithms.
programming languages are frequently accompanied by standardlibraries which may provide tens of additional data structures and the internet and scientific literature can be consulted for thousands more.
the suspect invention is therefore, in principle, so far removed from the invention as disclosed in the patent that it is considered in law to be an entirely different thing.
algorithms may employ variousdata structures in order to manage larger amounts of data than can be expressed in a fixed number of variables.
sameness in functionality computer scientists and software engineers may colloquially call two algorithms equivalent if they produce the same output for the same input, possibly with attention also to the required memory and computing times.
the invention is similar enough that a skilled professional would render it
by the same token, pursuant to § 103 (a) of the u.s. patent code: a patent may not be obtained though the invention is not identically disclosed or described as set forth in section 102 of this title, if the differences between the subject matter sought to be patented and the prior art are such that the subject matter as a whole would have been obvious at the time the invention was made to a person having ordinary skill in the art to which said subject matter pertains… these two factors should ideally return the appraisal of the merits back to the computer scientists and their skill in the first instance.
it must also consider the contemporary sophisticated practices of software engineers and computer scientists who develop and implement algorithms as part of the establishment ofprior art.
sameness through abstraction of application writing software can be a very laborious task.
should the difference nevertheless exist, one of the reasons for the discrepancy lies in that algorithms are34 patented when they are embedded in a particular application in a certain field.
we can provide justifications for some of these arguments, but in many cases they merely encode what we - as practitioners and educators in computer science and software engineering - consider to be obvious to a person having ordinary skill in the art.
another one may well be that the searches for prior art are far less than optimal and result in the granting of overlapping patents, which is widely recognised as a problem.35 alternatively, one might ask whether computer scientists granted patents on early elementary sorting algorithms, such as selection and insertion sort, are distinct algorithms of a lower status than sorting algorithms developed later.
as the importance of the courts and particularly that of cafc42 is widely recognised in the determination of actual patent scope, the language of the claim has been allowed to prevail at a high level of abstraction when the software invention has been disclosed.
as with a hand of playing cards, the input and output arrays can be made to occupy the same physical array.
the main focus of this paper is that the algorithms underlying computer programmes are the focal point of discourse on patentability of computer software.
even if a claim as literally read includes the impugned thing, claims are limited by construction to cover the invention disclosed in the patent and to exclude a thing which is different from the disclosed invention.
writing software can be a very laborious task.
the rules may contain mathematical or logical operations, repetition, procession to another rule, or temporary performance of another set of rules; they allow access to the internal state of the algorithm, takinginput and producing output.
in the european epo/epc settings, in spite of the “as such” exclusion from patentability regarding software, the number of epo issued software patents in 2002 was some 30,000.43 while some software patents concern only particular instances of a computer programme or its subroutines embracing the practical implementation of the underlying idea protected by a patent, the system has allowed claims to cover a broader area of application.44 the sheer statistics show that the similarity appraisal and the methodology used has remarkable practical significance.
the supreme court found the claim to be too broad, drawing a parallel with the case of a patent of a mere principle, and thus inadmissible.
in such a case, the invention, even though not the same as the prior art, lacks an inventive step.
an infringing device, process or other embodiment of invention that does not fall within the literal scope of a patent claim may nevertheless be considered equivalent to the claimed invention.
next, for all buckets containing a nontrivial number of elements we recursively perform the same sorting procedure again but now place the values into subbuckets according the second letter, then the third etc.
analysing the number of operations would show that the number of operations depends linearly on the product of the number of values and on the number of characters that form the (longest) value.
this legal typology has to compared with software development where one step in the process is also specification, the task of precisely describing the software to be written, preceded by domain analysis and then succeeded by creation of software architecture referring to abstract representation of the system, implementation in the form of coding and writing the requisite documentation, and testing and debugging the programme.
by comparison, in the american context, exceptions to patentability evolved as a result of case law and are still found therein.
this legal typology has to compared with software development where one step in the process is also specification, the task of precisely describing the software to be written, preceded by domain analysis and then succeeded by creation of software architecture referring to abstract representation of the system, implementation in the form of coding and writing the requisite documentation, and testing and debugging the programme.
introduction whether two algorithms - described abstractly in a document or employed concretely in, for example, a computer programme - are ‘the same’ or different from one another, may be a crucial determination in certain legal disputes.
the correct subject-matter10 is the underlying algorithms or sometimes even logical designs 11 that may cover tens of different types of software as eventually implemented in a given computer programme.
by this argument one could show, for example, that none of selection sort, quicksort and radix sort can be similar to each other.20 similarly, quicksort is evidently different from mergesort because an unfortunate choice of pivot elements causes quicksort to assume a quadratically growing computing time whereas mergesort can be guaranteed to consume never more than time proportional to n log n. furthermore, one can argue that selection sort and insertion sort must be different algorithms since insertion sort can process a readily sorted input array in time linearly proportional to n whereas selection sort always requires time proportional to n2.
in the european epo/epc settings, in spite of the “as such” exclusion from patentability regarding software, the number of epo issued software patents in 2002 was some 30,000.43 while some software patents concern only particular instances of a computer programme or its subroutines embracing the practical implementation of the underlying idea protected by a patent, the system has allowed claims to cover a broader area of application.44 the sheer statistics show that the similarity appraisal and the methodology used has remarkable practical significance.
such disputes will range from trade secret thefts or copyright violations to the determination of the scope of a patent,1 which is the legal focus of the current paper.2 the court responsible for such a decision must find a balance between protection of the intellectual property rights of the claimant on the one hand, and avoidance of a false judgment against the innocent respondent on the other.
by the same token, pursuant to § 103 (a) of the u.s. patent code: a patent may not be obtained though the invention is not identically disclosed or described as set forth in section 102 of this title, if the differences between the subject matter sought to be patented and the prior art are such that the subject matter as a whole would have been obvious at the time the invention was made to a person having ordinary skill in the art to which said subject matter pertains… these two factors should ideally return the appraisal of the merits back to the computer scientists and their skill in the first instance.
this might be true simply because as the field became more thoroughly researched (and taught), the general level of competence rose.
ideally one would like to devise a psychometric test in which a handful of reputedly competent software engineers and computer scientists and the inventor are given the same problem to be solved.
these bar from patentabilityas such discoveries, scientific theories and mathematical methods, aesthetic creations, schemes, rules and methods for performing mental acts, playing games or doing business, and programmes for computers and presentations of information.
this subtle change from partitioning when breaking up to merging when combining leads changes the resulting algorithm from quicksort to merge sort.
by comparison, in the american context, exceptions to patentability evolved as a result of case law and are still found therein.
for example, to change the sorting algorithms output from ascending to descending order requires such a trivial variation in the code that no one would consider the modified code to implement a different algorithm.
whereas mathematicians store an unbound number n values in a variable indexed through subscripting x1, x2, ..., xn, a software engineer writing c or java would use an array x[0], x[1], …, x[n-1].
this can be achieved by writing the code generic (abstract, parametric) so that aspects of the code can be changed without any deeper understanding of the algorithm itself.
in quicksort the linear-time array partitioning work is performed when breaking up the problem into smaller subproblems and no work needs to be done when combining the solved subproblems into a sorted original array.
these bar from patentabilityas such discoveries, scientific theories and mathematical methods, aesthetic creations, schemes, rules and methods for performing mental acts, playing games or doing business, and programmes for computers and presentations of information.
in such a case, the invention, even though not the same as the prior art, lacks an inventive step.
arrays are all we need to deliver the message in this presentation, but typical programming languages may contain such data structuring mechanisms as records, objects (as in object-oriented programming) and in some cases linked lists or associative arrays indexed by arbitrary values instead of mere integers.
while at the infancy and pioneer stages of an industry one sees patents with broad scope, patenting does not taper off later.
in short, an invention is not patentable, for lack of novelty, if the claimed subject matter was disclosed before the date of filing.
this can be achieved by writing the code generic (abstract, parametric) so that aspects of the code can be changed without any deeper understanding of the algorithm itself.
in a word processor, for example, input is via the keyboard and mouse, and output is the display.
indiamond v diehr25 , for example, a case concerning a patented rubber curing method involving an arrhenius equation26 in algorithmic form, the us supreme court excluded from patent protectionlaws of nature, natural phenomena, and abstract ideas.
this might be true simply because as the field became more thoroughly researched (and taught), the general level of competence rose.
in the case of quicksort, a doubly linked list will be needed, but consequently quicksort can also be made stable.
according to computing folklore, selection and insertion sorts are the fastest sorting methods for array sizes up to around ten or twenty.
unfortunately problems are seldom sufficiently well-defined and consequently there is rarely ever a chance for a group of experts to converge upon a solution near to that of the inventor.
competent programmers therefore try to avoid duplicate work by writing easily reusable code.
in the patenting law context, the motivation to obtain the broadest possible monopoly and the widest available protection for the invention is an incentive to couch applications in terms that are as generic as possible.
the operating system that provides the file access primitives to the word processor views the requests of the word processor in reversed roles.
the discovery of applicability of the algorithm and various preparatory and subsequent steps could easily however result in a non-obvious idea.
for example, inspecting the codes of selection sort, insertion sort, bubblesort, and should we have presented them also quicksort and mergesort, one would notice that the algorithms never arrive at a value in the middle of the array without first traversing through adjacent places from either edge of the array.
algorithms may employ variousdata structures in order to manage larger amounts of data than can be expressed in a fixed number of variables.
in the second alternative, the judiciary makes the final decision.
in insertion sort the basic idea is to take the first value in the input array, insert it into the correct position in the output array, and repeat these steps for the remainder of the input array until no more input elements remain.
this moving to adjacent values and also the swapping of values can be performed equally well on linked lists as on arrays: incrementing the indexes i and j to the array x is replaced by following the next-fields in the linked lists nodes; swapping values in two indexes is replaced by a handful of linked list manipulation statements.
assuming the physical devices were readily available, s/he will regard the sorting of a deck of cards or a herd of cattle according to weight as equally obvious, void of any inventive step.
insertion sort, as we presented it, is not stable whereas bubblesort is.
arrays are all we need to deliver the message in this presentation, but typical programming languages may contain such data structuring mechanisms as records, objects (as in object-oriented programming) and in some cases linked lists or associative arrays indexed by arbitrary values instead of mere integers.
j; tmp = x[max]; x[max] = x[i]; x[i] = tmp; } a software engineer comparing this to the original code, especially the structure of their iterations, may wish the comfort of more than a few seconds to verify that these codes indeed perform the same thing and do so essentially by employing the same algorithm.
28 u.s. patent code § 112; additionally, in the us the “best mode requirement” also limits the spectre of the claims in this respect.
we do not claim wikipedia to be the most authoritative source, but it is either more extensive or more up-to-date than the printed alternatives.
the number of comparisons and array accesses however grows quadratically with n for all the elementary sorting algorithms discussed so far, and more sophisticated algorithms become faster.
in the original eighth patent claim one samuel morse claimed any use of electromagnetism for printing intelligible signs, characters, or letters at a distance.
ideally one would like to devise a psychometric test in which a handful of reputedly competent software engineers and computer scientists and the inventor are given the same problem to be solved.
even if there is no anticipation and the invention is novel, the invention is not patentable if an imaginary person, having ordinary skill in the art, would know how to solve the problem to which the invention is directed, by using the same mechanism.
the rules may contain mathematical or logical operations, repetition, procession to another rule, or temporary performance of another set of rules; they allow access to the internal state of the algorithm, takinginput and producing output.
it is perhaps useful first to discern what is actually happening, instead of proceeding on the basis of the perceived patent protection of computer programmes.
9 thus, in principle, when an algorithm is implemented in a computer programme, the actual programme, whether in source or object code, together with supporting documentation, is protected by the copyright, while the functional idea of the algorithm underlying the programme remains in the realm of patent law.
an infringing device, process or other embodiment of invention that does not fall within the literal scope of a patent claim may nevertheless be considered equivalent to the claimed invention.
in fact, association of the output of one algorithm with the input of another is the standard method of composing algorithms into larger algorithms and eventually into programmes, regardless of whether the association is accomplished through ordinary function calls, shared memory, a middleware of some sort, or a network connection and explicit encoding to a data exchange protocol.
by article 56 epc, “an invention shall be considered as involving an inventive step if, having regard to the state of the art, it is not obvious to a person skilled in the art.”
the invention is similar enough that a skilled professional would render it obvious.16 sameness-preserving transformations can be compared with the doctrine of equivalents in patent law and ipr management parlance.
quicksort, by default, is not stable, whereas merge sort can be.
competent programmers therefore try to avoid duplicate work by writing easily reusable code.
these parameters are brought to bear with the application of the patent-granting or rejecting “algorithm”, the legal code with inherent elasticity that establishes the rules governing the appraisal.
even if there is no anticipation and the invention is novel, the invention is not patentable if an imaginary person, having ordinary skill in the art, would know how to solve the problem to which the invention is directed, by using the same mechanism.
should the difference nevertheless exist, one of the reasons for the discrepancy lies in that algorithms are34 patented when they are embedded in a particular application in a certain field.
we do not claim wikipedia to be the most authoritative source, but it is either more extensive or more up-to-date than the printed alternatives.
as mentioned above, short recourse to u.s. practice implies that there has been a trend to employ a relatively high standard of non-obviousness, while the patents that are granted are entitled to broad protection.40 while reliable statistics are not easy to come by, the higher standard has already facilitated more than 100,000 u.s. software patents in 2002.41 the breadth of scope has its own interesting tale to tell.
people also have a natural tendency to limit the number of items to learn and remember, and hence tend to cluster or abstract more diverse items into one group as the number of items increases.
as a near exception, professor michael s paterson et al have filed the u.s. patent 6,185,220 on a method for laying out sorting networks on vlsi, but it is unclear whether the actual sorting networks are covered by the patent.
next, for all buckets containing a nontrivial number of elements we recursively perform the same sorting procedure again but now place the values into subbuckets according the second letter, then the third etc.
this subtle change from partitioning when breaking up to merging when combining leads changes the resulting algorithm from quicksort to merge sort.
a subtler change in output, for example the stability of sorting – whether the sorting algorithm preserves the relative order of equal values – can, however, be a distinguishing factor.
if the algorithm of the inventor is judged between themselves to be more similar to one of the prior algorithms than the existing algorithms, then the algorithm of the inventor would not be judged as sufficiently non-obvious.
in insertion sort the basic idea is to take the first value in the input array, insert it into the correct position in the output array, and repeat these steps for the remainder of the input array until no more input elements remain.
the broad scope for patenting software currently implies that not only computer programmes but also the underlying algorithms may be patented, and this makes the discourse noteworthy.
in fact, association of the output of one algorithm with the input of another is the standard method of composing algorithms into larger algorithms and eventually into programmes, regardless of whether the association is accomplished through ordinary function calls, shared memory, a middleware of some sort, or a network connection and explicit encoding to a data exchange protocol.
it is perhaps useful first to discern what is actually happening, instead of proceeding on the basis of the perceived patent protection of computer programmes.
as mentioned above, short recourse to u.s. practice implies that there has been a trend to employ a relatively high standard of non-obviousness, while the patents that are granted are entitled to broad protection.40 while reliable statistics are not easy to come by, the higher standard has already facilitated more than 100,000 u.s. software patents in 2002.41 the breadth of scope has its own interesting tale to tell.
as the output of the algorithm one might also regard the memory consumption and computing time.19
it is also possible however that a device, even though it falls within the literal description of a claim of patent, to perform the same or a similar function as the patented device but in a way that is substantially different.
we then reserve one bucket for each distinct character and with one pass through the values to be sorted we can place all values which begin with character 'a' into the bucket for characters 'a', values which begin with 'b' to the bucket for 'b's, etc.
a computer scientist or software engineer can instantiate a readily generalised sorting algorithm to sort, for example, names of people in a few seconds of typing.
during the patent prosecution phase, a patent examiner first compares and evaluates, on the basis of his or her experience, the patent application and its specification38 with the description, claims and references together with the information available from the supporting databases and arguments brought forward by the inventor and patent agent or attorney.
as with a hand of playing cards, the input and output arrays can be made to occupy the same physical array.
in quicksort the linear-time array partitioning work is performed when breaking up the problem into smaller subproblems and no work needs to be done when combining the solved subproblems into a sorted original array.
these parameters are brought to bear with the application of the patent-granting or rejecting “algorithm”, the legal code with inherent elasticity that establishes the rules governing the appraisal.
programming languages are frequently accompanied by standardlibraries which may provide tens of additional data structures and the internet and scientific literature can be consulted for thousands more.
as a near exception, professor michael s paterson et al have filed the u.s. patent 6,185,220 on a method for laying out sorting networks on vlsi, but it is unclear whether the actual sorting networks are covered by the patent.
in a sense, patent law gives the applicants a certain freedom of discretion to define the scope of their claimed invention, provided the mentioned exclusions do not apply, and the application is sufficiently disclosed.
in software patenting, understood broadly, algorithms, data structures, protocols, software architectures and designs have in practice been granted patents.
it exhibits similar performance characteristics as quicksort, but the computer science community again considers it a new sorting algorithm in its own right.
a computer scientist or software engineer can instantiate a readily generalised sorting algorithm to sort, for example, names of people in a few seconds of typing.
at the level of language, the epc speaks only of patent application including then,inter alia, the description and claims together with possible drawings, eg uk and u.s. law uses word specification to cover the same aspects.
j; tmp = x[max]; x[max] = x[i]; x[i] = tmp; } a software engineer comparing this to the original code, especially the structure of their iterations, may wish the comfort of more than a few seconds to verify that these codes indeed perform the same thing and do so essentially by employing the same algorithm.
flowcharts and detailed descriptions of the patented programmes, let alone source code or object code, are often absent.6 the protectable subject-matter may not therefore be the computer programme or its subroutines, as sometimes implied by statutes7 and academic literature.
it must also consider the contemporary sophisticated practices of software engineers and computer scientists who develop and implement algorithms as part of the establishment ofprior art.
whereas mathematicians store an unbound number n values in a variable indexed through subscripting x1, x2, ..., xn, a software engineer writing c or java would use an array x[0], x[1], …, x[n-1].
by the same token, an evaluation is based on patent documents, witnesses, expert witnesses, other admissible evidence, presentations of the parties involved etc as input, together with relevant legal rules for determination of an infringement or related validity contest.
this also concludes our exposure to source code.
during the patent prosecution phase, a patent examiner first compares and evaluates, on the basis of his or her experience, the patent application and its specification38 with the description, claims and references together with the information available from the supporting databases and arguments brought forward by the inventor and patent agent or attorney.
the similarity or distinction of two algorithms therefore assumes a dominant role when a patent infringement dispute or the issue of novelty or obviousness arises.
scripted enter your email address: delivered by feedburner kenneth oksanen, perttu virtanen, eljas soisalon-soininen, jukka kemppinen* download options whether two algorithms - described abstractly in a document or employed concretely in, for example, a computer programme - are ‘the same’ or different from one another, may be a crucial determination in certain legal disputes.
by this argument one could show, for example, that none of selection sort, quicksort and radix sort can be similar to each other.20 similarly, quicksort is evidently different from mergesort because an unfortunate choice of pivot elements causes quicksort to assume a quadratically growing computing time whereas mergesort can be guaranteed to consume never more than time proportional to n log n. furthermore, one can argue that selection sort and insertion sort must be different algorithms since insertion sort can process a readily sorted input array in time linearly proportional to n whereas selection sort always requires time proportional to n2.
in its abstract formulation, the sorting operates through a series of arithmetic operations that are mathematical but the sorting algorithm can subsequently beapplied to many different ordering tasks, starting from alphabetic ordering and proceeding to numerous everyday and professional or industrial sorting operations in which the underlying mathematical principle is more distant from the relevant, concrete task such as sorting letters in mail, scheduling flights, or indexing a book.
the discovery of applicability of the algorithm and various preparatory and subsequent steps could easily however result in a non-obvious idea.
in the case of quicksort, a doubly linked list will be needed, but consequently quicksort can also be made stable.
we can provide justifications for some of these arguments, but in many cases they merely encode what we - as practitioners and educators in computer science and software engineering - consider to be obvious to a person having ordinary skill in the art.
even if a claim as literally read includes the impugned thing, claims are limited by construction to cover the invention disclosed in the patent and to exclude a thing which is different from the disclosed invention.
this domain has the virtue of being easy to describe, requires modest programming skills, and is rich with analogues in everyday life, yet sufficiently complex to be solved by a large number of different algorithms.
this domain has the virtue of being easy to describe, requires modest programming skills, and is rich with analogues in everyday life, yet sufficiently complex to be solved by a large number of different algorithms.
the supreme court found the claim to be too broad, drawing a parallel with the case of a patent of a mere principle, and thus inadmissible.
the main focus of this paper is that the algorithms underlying computer programmes are the focal point of discourse on patentability of computer software.
by breaking the compared values into parts, however, one can sort even faster.
the similarity or distinction of two algorithms therefore assumes a dominant role when a patent infringement dispute or the issue of novelty or obviousness arises.
it has been shown mathematically that no sorting algorithm based on comparing entire values can be faster than quicksort or merge sort by more than a constant factor.
analysing the number of operations would show that the number of operations depends linearly on the product of the number of values and on the number of characters that form the (longest) value.
if these experts can within, say, an hour of discussion present solutions close to those of the inventor, then a sufficient level of non-obviousness has clearly not been reached.
9 thus, in principle, when an algorithm is implemented in a computer programme, the actual programme, whether in source or object code, together with supporting documentation, is protected by the copyright, while the functional idea of the algorithm underlying the programme remains in the realm of patent law.
as the importance of the courts and particularly that of cafc42 is widely recognised in the determination of actual patent scope, the language of the claim has been allowed to prevail at a high level of abstraction when the software invention has been disclosed.
by generalising the type the very same code (and consequently the same algorithm) is able to sort integers, strings, names of people, phone numbers, dates, addresses, etc.
at the level of language, the epc speaks only of patent application including then,inter alia, the description and claims together with possible drawings, eg uk and u.s. law uses word specification to cover the same aspects.
people also have a natural tendency to limit the number of items to learn and remember, and hence tend to cluster or abstract more diverse items into one group as the number of items increases.
consequently, there is no reason why the very same sorting algorithm could not sort the appendix of references in a book, a row of integers in lotto, or the chronological schedule of departing flights on the airport.
flowcharts and detailed descriptions of the patented programmes, let alone source code or object code, are often absent.6 the protectable subject-matter may not therefore be the computer programme or its subroutines, as sometimes implied by statutes7 and academic literature.
the correct subject-matter10 is the underlying algorithms or sometimes even logical designs 11 that may cover tens of different types of software as eventually implemented in a given computer programme.
in the original eighth patent claim one samuel morse claimed any use of electromagnetism for printing intelligible signs, characters, or letters at a distance.
this also concludes our exposure to source code.
such disputes will range from trade secret thefts or copyright violations to the determination of the scope of a patent,1 which is the legal focus of the current paper.2 the court responsible for such a decision must find a balance between protection of the intellectual property rights of the claimant on the one hand, and avoidance of a false judgment against the innocent respondent on the other.
an alternative application of divide and conquer would be to perform no work in breaking up the array but instead perform a linear-time subarray merging when combining the sorted subarrays into the whole sorted array.
the broad scope for patenting software currently implies that not only computer programmes but also the underlying algorithms may be patented, and this makes the discourse noteworthy.
while at the infancy and pioneer stages of an industry one sees patents with broad scope, patenting does not taper off later.
an alternative application of divide and conquer would be to perform no work in breaking up the array but instead perform a linear-time subarray merging when combining the sorted subarrays into the whole sorted array.
computer scientists and software engineers may colloquially call two algorithms equivalent if they produce the same output for the same input, possibly with attention also to the required memory and computing times.
assuming the physical devices were readily available, s/he will regard the sorting of a deck of cards or a herd of cattle according to weight as equally obvious, void of any inventive step.
in its abstract formulation, the sorting operates through a series of arithmetic operations that are mathematical but the sorting algorithm can subsequently beapplied to many different ordering tasks, starting from alphabetic ordering and proceeding to numerous everyday and professional or industrial sorting operations in which the underlying mathematical principle is more distant from the relevant, concrete task such as sorting letters in mail, scheduling flights, or indexing a book.
