instead of examples of specific code macros (general or not) it would be nice to see common programming practices using macros.
the book was published byno starch press and they were kind enough to provide me a copy for review.
if we want a simple-vector, the macro will expand to use the correct type declaration and svref.
ccl chooses the pivot with a median-of-3 method and always sorts the smaller partition to ensure a worst-case stack depth of o(lgn).
with 6 comments zsort is a library that i started working on as a simple hobby project.
if we want a simple-vector, the macro will expand to use the correct type declaration and svref.
to conclude, the tangled web is a solid book, full of interesting and useful information.
moreover, we keep the algorithm in a single place, making it easier to maintain.
this can be very useful in situations where we want to optimize code since it becomes easy to add the proper type declarations to the input arguments of an algorithm.
even if for most situations the standard functions are more than enough, thezsort library could be a useful complement.
the only source file i could find with a sort implementation wassort.d and it looks like it contains an implementation of tree sort with a self-balanced binary tree, which also gives this algorithm an average and worst-case performance of o(nlgn).
unless you know your input data has some special properties that you can take advantage of, the provided sort should be enough for your needs and probably is more efficiently implemented.
although the book is not very thick (around 300 pages) it addresses too many important issues to completely absorb them in a single reading.
the only source file i could find with a sort implementation wassort.d and it looks like it contains an implementation of tree sort with a self-balanced binary tree, which also gives this algorithm an average and worst-case performance of o(nlgn).
there is still a lot of work to be done, but i think the library as it is can already be a little useful.
in addition, we might also want the possibility of using a key to access the vector elements.
the used grammar has the ability to guide the learning of novel architectures, by rearranging components regularly found on manually designed variants (for example, the elitist ant-system, the ant colony system or the max-min ant system).
the main goal of zsort is to be a collection of portable sorting algorithms.
the macro contains the algorithm (in this simple case the mean) and the arguments allow us to configure the multiple versions we need.
in the first one, the author tells us the story of the inception of the web until today and discusses all the important technologies, protocols, etc.
if a key function is needed it will also include it.
quicksort has a worst-case performance of o(n2) but it can be optimized in several ways so that it also gives an expected worst-case performance of o(nlgn).
quicksort has a worst-case performance of o(n2) but it can be optimized in several ways so that it also gives an expected worst-case performance of o(nlgn).
this is a problem that exists in the current1.0.1 release but i’ve sent a bug report with a quick fix to the maintainers.
so, for a lack of a better expression name, let’s call themmacros design patterns.
these sheets alone make the book worthwhile having.
the plan is to add more algorithms, for example,bucket sort and timsort.
i think there is still room for improvement in some implementations but knowing now the strengths and weaknesses of the sorts in cl is already good enough.
the main goal of zsort is to be a collection of portable sorting algorithms.
according to each implementation, which can make an application unportable if you rely on a specific type of sorting.
the plan is to add more algorithms, for example,bucket sort and timsort.
this can be very useful in situations where we want to optimize code since it becomes easy to add the proper type declarations to the input arguments of an algorithm.
i was curious about it and went to check the source forabcl, ccl, clisp, cmucl, ecl and sbcl.
however, the main thing on the todo list is adding the possibility ofexternal sorting (to handle large amounts of data) and parallel versions of some sorting algorithms.
the book is a very engaging narrative, full of details and impressive war stories.
the book is a very engaging narrative, full of details and impressive war stories.
written by jorge tavares february 2, 2012 at 9:45 posted in programming tagged with common lisp, lisp, sorting algorithms, survey« older entries blog at wordpress.com.
also, the standard functions might not be the best for a certain situation and as such you might need a specialized sort.
apparently, all implementations are bottom-up merge sorts with the exception of ccl and ecl.
these sheets alone make the book worthwhile having.
if one knows the properties of the data, it is possible to understand if the provided sort can or will pose a problem.
also, the standard functions might not be the best for a certain situation and as such you might need a specialized sort.
ccl chooses the pivot with a median-of-3 method and always sorts the smaller partition to ensure a worst-case stack depth of o(lgn).
i am very happy with this distinction since eurogp is the leading conference on genetic programming attended by the best researchers in the field.
if they can be fast, even better.
in the same way a programmer shouldn’t implement a sorting algorithm every time it needs to sort something, the programmer should also be aware of the limitations/advantages of the system sort.
i’ve learned what algorithms are actually used and enjoyed seing how they were implemented.
the book was published byno starch press and they were kind enough to provide me a copy for review.
while reading the source code of the implementations, i realized that abcl was using quicksort in stable-sort for all non-list sequences.
common lisp provides thesort and stable-sort functions but these can have different algorithms implemented according to each implementation, which can make an application unportable if you rely on a specific type of sorting.
i am very happy with this distinction since eurogp is the leading conference on genetic programming attended by the best researchers in the field.
the event was great with an excellent organization lead bycarlos cotta.
i’ve learned what algorithms are actually used and enjoyed seing how they were implemented.
moreover, we keep the algorithm in a single place, making it easier to maintain.
i find it very useful.
unless you know your input data has some special properties that you can take advantage of, the provided sort should be enough for your needs and probably is more efficiently implemented.
another interesting thing is that merge sort is also used for lists in sort, in most of the implementations.
for example, at the end of each chapter we can find a “security engineering cheat sheet”, which presents us a summary of things to consider/do.
in this paper, a grammatical evolution approach is used for the automatic design ofant colony optimization algorithms.
this approach was tested with thetsp and the results show that the evolved algorithmic strategies are effective, exhibit a good generalization capability and are competitive with human designed variants.
instead of examples of specific code macros (general or not) it would be nice to see common programming practices using macros.
in addition, we might also want the possibility of using a key to access the vector elements.
in ecl (and abcl) quicksort implements a partition scheme which deals better with duplicate elements (although is not the three-way partitioning) but it always picks as pivot the first element.
i think there is still room for improvement in some implementations but knowing now the strengths and weaknesses of the sorts in cl is already good enough.
to conclude, the tangled web is a solid book, full of interesting and useful information.
in the same way a programmer shouldn’t implement a sorting algorithm every time it needs to sort something, the programmer should also be aware of the limitations/advantages of the system sort.
if one knows the properties of the data, it is possible to understand if the provided sort can or will pose a problem.
even if for most situations the standard functions are more than enough, thezsort library could be a useful complement.
however, i found it surprising to find quicksort in the stable-sort column because it is not a stable algorithm.
the used grammar has the ability to guide the learning of novel architectures, by rearranging components regularly found on manually designed variants (for example, the elitist ant-system, the ant colony system or the max-min ant system).
in ecl (and abcl) quicksort implements a partition scheme which deals better with duplicate elements (although is not the three-way partitioning) but it always picks as pivot the first element.
however, i found it surprising to find quicksort in the stable-sort column because it is not a stable algorithm.
in this paper, a grammatical evolution approach is used for the automatic design ofant colony optimization algorithms.
another interesting thing is that merge sort is also used for lists in sort, in most of the implementations.
for the rest of us it is an enjoyable reading.
the event was great with an excellent organization lead bycarlos cotta.
this exploration of the sorting algorithms used in the open source implementations was very educational and interesting to me.
however, the main thing on the todo list is adding the possibility ofexternal sorting (to handle large amounts of data) and parallel versions of some sorting algorithms.
apparently, all implementations are bottom-up merge sorts with the exception of ccl and ecl.
these kind of threads are always enjoyable because each time you learn something new and see really interesting things.
if you want to share, feel free to drop a line.
the difference between the two is that the second function sorts in a way that guaranteesstability, i.e., two elements that are equal remain in the same position after sorting is completed.
the use of sort and stable-sort requires some care (see the section sort pitfalls) but lets focus on the algorithms and not on its usage.
for example, at the end of each chapter we can find a “security engineering cheat sheet”, which presents us a summary of things to consider/do.
in the first one, the author tells us the story of the inception of the web until today and discusses all the important technologies, protocols, etc.
this is a problem that exists in the current1.0.1 release but i’ve sent a bug report with a quick fix to the maintainers.
as expected, most of the implementations use merge sort to implement stable-sort since it is a stable sort with average and worst-case performance of o(nlgn).
while reading the source code of the implementations, i realized that abcl was using quicksort in stable-sort for all non-list sequences.
if you want to share, feel free to drop a line.
as expected, most of the implementations use merge sort to implement stable-sort since it is a stable sort with average and worst-case performance of o(nlgn).
these kind of threads are always enjoyable because each time you learn something new and see really interesting things.
this exploration of the sorting algorithms used in the open source implementations was very educational and interesting to me.
the difference between the two is that the second function sorts in a way that guaranteesstability, i.e., two elements that are equal remain in the same position after sorting is completed.
the macro contains the algorithm (in this simple case the mean) and the arguments allow us to configure the multiple versions we need.
i enjoy reading about topics outside my main field and interests.
the book can be very useful for web developers and those interested in security.
this approach was tested with thetsp and the results show that the evolved algorithmic strategies are effective, exhibit a good generalization capability and are competitive with human designed variants.
so, for a lack of a better expression name, let’s call themmacros design patterns.
the book can be very useful for web developers and those interested in security.
there is still a lot of work to be done, but i think the library as it is can already be a little useful.
