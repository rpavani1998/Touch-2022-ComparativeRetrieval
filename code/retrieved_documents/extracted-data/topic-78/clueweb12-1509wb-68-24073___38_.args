if the benefits of good choices outweigh the costs of bad choices, a random selection of good and bad choices can yield an efficient algorithm.in spite of this slow worst-case running time, quicksort is often the best practical choice for sorting because it is remarkably efficient on the average: its expected running time is(n lgn), and the constant factors hidden in the (n lg n) notation are quite small.we noted in section 8.2 that a mixture of good and bad splits yields a good running time for quicksort, and thus it makes sense that randomized versions of the algorithm should perform well.8.4-4 the running time of quicksort can be improved in practice by taking advantage of the fast running time of insertion sort when its input is "nearly" sorted.it also has the advantage of sorting in place (see page 3), and it works well even in virtual memory environments.if the partitioning is balanced, the algorithm runs asymptotically as fast as merge sort.this modification does not improve the worst-case running time of the algorithm, but it does make the running time independent of the input ordering.if the partitioning is unbalanced, however, it can run asymptotically as slow as insertion sort.by modifying the partition procedure, we can design another randomized version of quicksort that uses this random-choice strategy.thus, with a 9-to-1 proportional split at every level of recursion, which intuitively seems quite unbalanced, quicksort runs in(n lg n ) time--asymptotically the same as if the split were right down the middle.this technique, called tail recursion, is provided automatically by good compilers.the randomized algorithm performs badly only if the random-number generator produces an unlucky permutation to be sorted.if many of the alternatives are good, simply choosing one randomly can yield a good strategy.8-5 median-of-3 partition one way to improve the randomized-quicksort procedure is to partition around an elementx that is chosen more carefully than by picking a random element from the subarray.the randomized algorithm based on randomly permuting the input array also works well on average, but it is somewhat more difficult to analyze than this version.