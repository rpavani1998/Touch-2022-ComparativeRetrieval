because of the way most algorithms work (comparing and swapping pairs of items) sorting often takes precious time.with multi-core architectures like the ps3 it makes sense to parallelize this operation to maximize the use of these cores.this represents a 1.5x speed-up over execution on ppu, however sorting integers results in 0.6x slowdowns.in the first three parts we have implemented the quicksort, merge and merge sort algorithms, as well as optimized them on the ps3's ppu.this could be used to sort non-opaque polygons by depth.the first step for sorting in parallel is to offload sorting an array chunk on a spu using offload.for example, sorting transparent objects before rendering or sorting objects by state attribute (e.g. texture) to improve batching.the latter is similar except that the execution of the function containing the offload block is stopped until the block has finished executing.ms 1.2 ms – – in the next part in the series we will see how to run our sort functions on multiple spus in parallel to build a parallel sort implementation and work around the current arrays size limitation.similarly merge sort sees 2-2.4x speed-up for floats and 1.9-2.1x speed-ups for integers.in this part we will start running these implementations on a spu to improve performance even further.the former spawns a thread on a spu and runs the code inside of the block (see code below).the user-defined structure used ('face') contains one floating point (depth value) and three integer indices.for now we will use the latter as we are using only one spu and not doing any processing on the ppu.speed-up for floats and 1.9-2.1x speed-ups for integers.