the exec list and system list operations now produce warnings on tainted data and in some future release they will produce fatal errors.it is now implemented using a windows message loop, and is therefore less prone to random crashes.the system function and backticks operator have improved functionality and better error handling.self-ties of arrays and hashes are not supported and fatal errors will happen even at an attempt to do so.this means that they will be more robust and hopefully faster.so the 5.8 quicksort scrambles large arrays before sorting them, as a statistical defence against quadratic behaviour.for very small lists this may result in slightly slower sorting times, but in general the speedup should be at least 20%.the behavior in earlier versions of perl 5 was that arrays would interpolate into strings if the array had been mentioned before the string was compiled, and otherwise perl would raise a fatal compile-time error.map() could get pathologically slow when the result list it generates is larger than the source list.modules may fail to compile at all, or they may compile and work incorrectly.additional bonuses are that the worst case behaviour of sort() is now better (in computer science terms it now runs in time o(n log n), as opposed to quicksort's theta(n**2) worst-case run time behaviour), and that sort() is now stable (meaning that elements with identical keys will stay ordered as they were before the sort).[561] the perl parser has been stress tested using both random input and markov chain input and the few found crashes and lockups have been fixed.this algorithm is reasonably fast while producing a much better spread of values than the old hashing algorithm (originally by chris torek, later tweaked by ilya zakharevich).the quicksort divide and conquer strategy works well on platforms with relatively small, very fast, caches.quicksort has a worst case run time that can grow like n**2, so-called quadratic behaviour, and it can happen on patterns that may well arise in normal use.