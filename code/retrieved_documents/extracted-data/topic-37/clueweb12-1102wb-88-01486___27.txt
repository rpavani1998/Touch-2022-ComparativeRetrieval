having tests depend on each other will cause chains of failing tests, making it  difficult to track the problem down to the source.
two tips that helped us apply tdd to high-level code: tests as a measure of progress software developers have been struggling for a long time to find a good measure of progress or work done.
it is  common sense and a good software engineering practice to keep all the  graphics-related code in one library or module, and make the rest of the game  independent of the platform graphics api and hardware.
one thing that should be clear and is important to stress is that tdd is not just writing unit tests.
the input system deals with getting input values from gamepads and other controllers.
paulius maruška hello.
for example,  a mock object could record what functions were called and what values were  passed, or could be set up to return a set of fixed values when one of its  functions is called.
maybe if we were working on a  commercial graphics rendering middleware it would be worth the effort.
code can get too complex for its own good.
see how doing something so apparently backwards as writing unit tests  before any code can help with all those problems.
we have found that in codebases that are developed with tdd, comments have almost disappeared, being used only to explain why something was done in a particular way, or to document what paper an algorithm we implemented came from.
i return false from the above function as true is the signal to try and hook into the debugger, which i don’t want when running automated tests.
having an agile mindset fits very well with the idea of finding the design through tests.
that depends on your situation and experience, and the type of code you’re writing.
after all, an api is just a list of classes or functions, and you have a lot of control over how and when they get called.
the rest is done automatically.
its only job is to  check the non-test code, so it’s keeping an eye out for us, helping us,  and letting us know when something breaks.
that’s actually even more complicated than what we want for our small testing steps, so let’s start with an even simpler test that requires the least amount of effort: if we have a player and a powerup, and the player isn’t anywhere near the powerup, his amount of health doesn’t change.
the most important thing is to make sure your tests run automatically (remember the postbuild trick).
any decent unit test framework should support fixtures, so use them whenever they’re needed.
because of that, our unit tests on platforms other than windows are only executed manually, and by the build server.
that way we could make any graphics api calls that we needed  without having to worry about the underlying hardware.
one thing that should be clear and is important to stress is that tdd is  not just writing unit tests.
mockpp, at least in  my opinion, is a too straitforward port from java and c#, and is not suitable  for c/c++ (similar to what happend with cppunit).
keeping that in mind helps to write true unit tests and not  functional tests for the api.
in addition to running tests locally, the build server also runs all the  unit tests at the same time it does code builds.
in your game binary you can link a library containing your (perhaps platform specific) assert handler, for a dialog box, or whatever your preference is in that case.
when doing this, it can be extremely useful to have somebody on board with previous tdd experience who can help guide the process, set up the environment, and avoid common early mistakes.
on the positive side, because the tests are exercising the graphics api and hardware directly, we catch things that the first approach wouldn’t have caught (for example, sending incorrect parameters to a function).
backwards is forward: making better games with  test-driven development one thing that should be clear and is important to stress is that tdd is  not just writing unit tests.
it was also discouraging us from using new api functions just because they hadn’t been wrapped before.
so if this is made clear, people will be much more likely to be strict about applying tdd and not falling back on writing code without tests.
keep the engine architecture as flat as possible.
paul  mendoza agile game development
we pass the mocked rendering canvas to the hud renderer and make the render call.
in our particular case, not only were we doing tdd, but we were doing  all the extreme programming practices (pair programming, continuous  integration, collective code ownership, etc).
as you can see, it can’t get much easier than that.
however, it’s the same facility to weave code out of thin air that can become our greatest danger.
how does tdd help us deal with the complexity of software, and, more specifically, how does it solve some of the problems listed in the introduction?
as with other aspects of software development, it is difficult to make an  objective study and measure exactly the effects of tdd versus a control group.
let’s assume we already have a game up and  running, and our task is to implement health powerups.
i dont have any good ideas about how to implement tdd for them.
we can easily set up a world with a couple of enemies, call that function, and verify that it returns the enemy entity we expected.
not everybody has that luxury, so it is important to learn how to apply tdd even with an existing legacy codebase.
the most important  reason to minimize the amount of code involved in a test is to keep things  simple.
in our case, since the tests are a postbuild step, there was nothing special we had to do in the build server, and a failed test would be reported just as code that didn’t compile correctly.
the minimum support that we needed was the ability to run an executable through the command line and capture the output and, ideally, the return code.
i will try to put it somewhere at sourceforge when i come back from my recent business trip (in two weeks).
the testing layer could be removed  in the final build and the functions would call directly into the graphics api  so there would be no performance penalties.
functional tests are a great complement to unit tests, so it’s important not to forget about them.
additionally, since the test executable returns a value with the number of  failed tests, a failing test will return a non-zero value, which is interpreted  by the build chain as a failed build.
here we make a function call, and we want to test that the object under test did a sequence of actions with other objects.
now with regard to your comment about mocks and flat object structure i think i see where does the argument lay.
you have to format your message like so: std::cout  0 check  somewhere).
the test program should know whether any tests failed or not  without any ambiguity, that way it can be easily integrated into the build  process.
a good start is to label each test clearly with a name that describes  exactly what the test is supposed to do.
code can get too  complex for its own good.
we are hoping that as tdd becomes more common in the games industry,  middleware providers will make their apis more tdd friendly and even ship with  their unit tests.
probably by writing some code like  this: world world; const initialhealth = 60; player player(initialhealth);  world.
a fixture is a set of common code that is executed before and after each test that uses that fixture.
no problem seems too large as long as you’re taking small steps in its direction and getting feedback that you’re in the correct track.
there is no doubt that the best situation to roll out tdd is with a fresh new codebase.
notice the trade-off between slightly slower short-term speed vs. massive gains later on.
if some tests involve a large  amount of the codebase, they will constantly break for unrelated reasons.
unit tests are supposed to be simple and fast, so any loops in a test are usually very suspect.
that means you can be merciless about refactoring your code, and you can still be confident that it will work if all the tests continue to run.
graphics, middleware, and other apis probably the biggest barrier that people see to doing unit testing and tdd  with games is how to deal with graphics.
because this is the most complex form of testing, we recommend using it only when the other two forms of testing are not possible.
this is where test-driven development comes in.
we don’t really care about state, just that a certain number of function calls happened.
in our groups, we have a test chart, which is updated every day and shows the  total count of tests.
even though at high  moon we develop console games, we use windows as our primary development  environment because of the good development tools and the fast iteration time.
working with a full game engine, you might end up writing a small module that is fully surrounded by the engine code.
at high moon, we are working on several projects with the unreal engine 3, and we’re using tdd on them.
the check_equal macro is the part that performs the actual check, and it takes as parameters the expected value and the actual value.
we also found that limiting each unit test to a single check statement or  two resulted in tests that were the easiest to understand.
that means that making any changes to the  library or tests and triggering a compile will also run all the tests.
gethealth()); and that’s exactly what the test will look like, only we’ll have to surround it with a macro to take care of all the bookkeeping and to give it a descriptive name.
not that i was present to see it further proof agile is turning the corner i love to find information that backs up my belief that agile development practices are gaining wider acceptance, such as this article describing how to do tdd game programming in c++.
as a general rule,  whenever a set of unit tests goes over two seconds, it means something is wrong  and we try to fix it (even if a unit test takes a full ms, which is a huge  amount for a unit test, you can still run 1000 of them in a single second).
he builds his castles in the air, from air, creating by exertion  of the imagination.
randomness and games most games involve a fair amount of randomness: the next footstep sound you play can be any one of a set of sounds, the next particle emitted has a random speed between a minimum and a maximum, etc.
here we make a function call, and we  want to test that the object under test did a sequence of actions with other  objects.
bookmark the permalink.
what was a pleasant surprise is that broken builds are much easier to fix.
because this is the most complex form of testing, we recommend using it  only when the other two forms of testing are not possible.
sometimes that means  you’ll have to write some duplicate setup code between two tests, but  it’s a small price to pay to keep the tests as simple as possible.
http://www.cnicholson.net charles nicholson btw, the full subversion checkout command is this: svn co https://svn.sourceforge.net/svnroot/unittest-cpp/unittest++ if anyone’s interested in an unpackaged sneak preview.
best practices this is a set of best practices we have found to be particularly important  for all of our development with tdd.
let me highlight a point where i hold a different opinion, namely using mocks for tdd.
with bmock a mock version of a function is just a simple idl-like  annotation: bmock_function(int,f,1,(in(int,x))).
i’ve been  lazy and haven’t updated the cpptestharness homepage yet, but unittest++  has many notable improvements already.
it will probably come as no surprise to anybody that writing code with tdd results in more code being written.
you can browse through them to see what kind  of use a class is intended to have, you can look up a particular test to see  what kind of assumptions a function makes about its parameters, or you can even  comment out some code that makes no sense and see what tests break to give an  idea of what it does.
it flags errors by parsing the output window!
however, it was quite  labor-intensive, especially for the direct3d api because it uses classes and  not just plain functions like opengl.
one of the drawbacks of this approach is that we’re  working directly with the hardware, so tests actually do initialize and  shutdown the graphics system every time (except for those platforms out there  that can only initialize the graphics system once), so they can be more time  consuming.
write the simplest amount of code that will make the test compile and pass.
because this is the easiest and most straightforward  way of testing, we should use this approach whenever possible.
then you repeat the process with  another, very small piece of functionality that will get you closer to the full  feature you’re trying to implement.
because a lot of the high-level game engine is written in unrealscript, we had little choice but to use it to write most of the game code.
we have all experienced how development slows down to a crawl towards the  end of a project.
test-driven development
we do not want a assert-dialog  here.
you should be  able to use it with practically no changes.
if you want to take a look at its documentation gmail me a line using my first name, dot, last name as an address (a naive anti-spam measure).
this  approach made for extremely thorough tests.
we all know how easy it is for comments to get out of date, yet there is very little we can do about it.
in “object interactions” you wrote: “using mocks  frequently could be an indication that the code relies too much on heavy  objects with complex interactions …” i do not think it’s  true.
i think part of the reason is that mocks are much easier to create in unrealscript than in c++.
we started with the first approach, wrapping the api as we were using it,  but the amount of extra work we had to do to wrap complex apis like direct3d  and opengl quickly became overwhelming.
for this to happen, it’s important to let the  tests guide the code and not the other way around.
there are too many things i  fully agree with to be mentioned in this short comment.
the test code has been written so it’s extremely simple, so its complexity is minimal.
the key to working with tdd is to realize that refactoring is an integral part of the development process and should happen regularly every few tests.
its only job is to check the non-test code, so it’s keeping an eye out for us, helping us, and letting us know when something breaks.
but i’ll fix all that up tonight.
for the guy asking about visual studio return codes: yes, visual studio ignores error codes.
build stability as we expected, having almost full code coverage with unit tests greatly improves the code stability.
then you repeat the process with another, very small piece of functionality that will get you closer to the full feature you’re trying to implement.
however, that severely limits the  amount of large-scale refactorings we can do to keep things as testable as  possible, so it’s a tough trade-off.. one unique aspect of the unreal engine is that it makes heavy use of its  scripting language, unrealscript.
the most important thing to do in this situation is to separate the code we  write as much as possible from the engine code.
there are too many things i fully agree with to be mentioned in this short comment.
imagine then how  useful tdd can be on a full engine developed with tdd from the start.
then we can examine that the list in our mocked canvas matches our expectations.
theworld object can be a very lightweight  container for game entities without any other dependencies.
as in maybe later today?
some projects use code line counts to determine progress, others use features completed, while others just look at the number of hours spent at the office.
creating an object in a test and reusing it in a different test is asking for trouble for the same reasons as we discussed earlier: when a test fails, you want to be able to zero in on the failing test and the problem that is causing it to fail.
the larger the team and the more complex the problem, the more tdd saves time  in the long run.
test only code under test
add(&player, transform(axisy, 0, vector3(10,0,10))); healthpowerup powerup; world.
even though we find refactoring to be an extremely important part of the development process, the safety net goes way beyond refactoring.
not only does visual studio indicate this in the output log, but it will also fail any automated builds in your build server without having to do any extra checks.
applying it on a small scale initially was very useful in many different ways.
not only does this allow us to unit-test our code in isolation, but we also keep future merges with epic’s codebase as simple as possible.
i think the problem is that for c++ we do not have one.
the test program should know whether any tests failed or not without any ambiguity, that way it can be easily integrated into the build process.
we’re not doing tdd because it’s a “good” thing to do, but because we want to ship a better-quality product faster and cheaper than we did before.
update(0.1f); check_equal(initialhealth, player.
if you want to take a look at its  documentation gmail me a line using my first name, dot, last name as an address  (a naive anti-spam measure).
in the end, we ended up settling for a combination for the second and third approaches: testing the state whenever possible, and isolating the calls the rest of the time.
– ash paulius: unittest++ actually started as a copy of cpptestharness.
in our system, we have an interface named gamecontroller with a sample() function.
for example, instead of just having a playfootstep() function that takes care of computing a random footstep and then playing it, we can break it into int computenextfootstep() which is just a random function call, and a playfootstep(int index), which we can now test very easily.
you may  use fakes as michael feathers suggests, but manual creation of fakes could very  soon turn to be too burdensome.
also, since opengl is so state-based, it was important for most  functions to clean up after themselves, so it was often very hard to check for  any state.
see how doing something so apparently backwards as writing unit tests before any code can help with all those problems.
sometimes the test code is as large as the code under test itself.
even if you have “many, loosely coupled, simpler objects” you need somehow to break dependencies in order to test them in isolation.
when are you going to release something (there are no releases on sourceforge project page)?
- errors: although we do not use exceptions in our final build, they are used everywhere in our normals builds.
even though we  find refactoring to be an extremely important part of the development process,  the safety net goes way beyond refactoring.
it is possible to simply write code faster than it is to write the tests  first, but as soon as that code needs to be refactored, debugged, used by  somebody else, or simply gets more complex, any time savings quickly disappear.
you also need something to deal with system api as you described in “graphics, middleware, and other aips”.
simple, right? ideally, how would we like to test that?
let’s assume we already have a game up and running, and our task is to implement health powerups.
not everybody has that luxury, so it is important to learn how to  apply tdd even with an existing legacy codebase.
prentice hall, 2003 beck, kent, and cynthia andres, extreme programming explained:  embrace change (2nd edition), addison-wesley, 2004 very useful mailinglists and web sites: testdriven.com resources dealing with tdd and agile game development: noel’s blog, games from within clinton keith’s blog, agile game development c++ unit-testing frameworks: unittest++.
we have hooked  up running the executable itself as the post-build step in visual studio (or as  the last command in a make file).
the answer depends on your  priorities and game.
that’s actually really important, because it allows us to run  $(targetpath) in the postbuild step and have the executable return the number  of failed tests.
maybe you run through a level, checking that  feature and making sure nothing else looks obviously broken, or maybe you even  step in the debugger to make sure your code is getting called and doing what  it’s supposed do.
but even more  importantly, tests should run very frequently, and a failed test should be  treated the same way as a failed build.
after we wrote those small utility programs, we were able to run unit tests on the consoles just like we did under windows.
at high moon, every library has a separate test project that creates an  executable that links with the library and runs all the tests.
even though the engine is not tdd-friendly at all, we still find more benefit from doing tdd with it.
build stability as we expected, having almost full code coverage with unit tests greatly  improves the code stability.
the unit tests created through tdd serve as a very effective form of documentation.
it is common sense and a good software engineering practice to keep all the graphics-related code in one library or module, and make the rest of the game independent of the platform graphics api and hardware.
as with other aspects of software development, it is difficult to make an objective study and measure exactly the effects of tdd versus a control group.
these are the benefits, listed roughly in our order of importance: better code design what is the first thing you do when writing some code with tdd?
applying it on a small scale initially was very useful in many different  ways.
we pass the mocked rendering canvas to the hud  renderer and make the render call.
asher sterkin noel, the bmock library is not published yet.
milestone pressures, a fluctuating game industry, growing teams and budgets, and the breakneck pace of hardware change don’t help an already difficult situation.
the unit tests provide you with instant feedback up to several times per minute.
gethealth()); } the macros test and check_equal are part of a unit testing framework.
- assertions: we provide a hooking mechanism, so every assertion that gets fired inside a test result in failing the test.
the assert system works identically to cpptestharness.
especially when tests are developed through tdd, they deal less with corner cases and more with program features.
we tried three different approaches, from most involved to least  involved: catch all graphics function calls.
for us,  after doing that for a few weeks, we realized that the benefits we were  deriving from it weren’t worth the time we were spending.
also, code at that level is often writ ten by designers in a  game-specific scripting language, so tdd might not be a viable option.
when writing unit tests, there are three main ways of testing your code: return value make a function call, and check the return value.
once we had that  organization, we were able to test any part of the game or engine without  having to worry about graphics.
our castles in the air can quickly become snowballs that are too large to be moved and shaped to fit our needs.
it also makes any bad practices apparent early on and they can be dealt with before rolling it out (making overly complex tests or functional, rather than unit tests).
the reason we have macros like check_equal is that unit tests need to be fully automated.
so i suppose there’s a chance the  unittest++ assert system will work in a similar way.
great article, especially like the air-castle reference one little tip for people who dedice to hook things up in visual studio, it took us a little headscratching to realize that visual studio doesn’t do result !
at high moon, we are working on several projects with the unreal engine 3,  and we’re using tdd on them.
how about game-specific script code?
we have hooked up running the executable itself as the post-build step in visual studio (or as the last command in a make file).
this paper will be presented at the 2006 game developers conference noel llopis and sean houghton high moon studios printer-friendly format.
for example, we could send an event of nearby noise to an ai in “idle” state and check that its state changes to “alert” in response.
even though at first glance it might seem like the whole system is  about making system calls to poll the data, there is a lot of common code that  is totally platform independent: button mappings, edge detection, filtering,  plugging/unplugging controllers, etc.
by the way, just a quick announcement to say that the first release of unittest++ is out.
we had seen in practice from previous projects that we can certainly do tdd to create low-level and intermediate-level libraries (math, collision, messaging, etc).
an example of some code that we would not use tdd for is trigger code: when  the player goes around the corner, wake up two ais and trigger a different  background music.
test diagnostics (could be easily integrated with any other unit testing  framework – i did it for cunit!).
we have found that in codebases that are developed  with tdd, comments have almost disappeared, being used only to explain why  something was done in a particular way, or to document what paper an algorithm  we implemented came from.
another approach is to actually work on  the graphics hardware and check that things are working correctly by querying  the graphics ap i state.
we have wrestled with somebody else’s code, just to give up or fully re-write it in despair.
because a lot of the high-level game engine  is written in unrealscript, we had little choice but to use it to write most of  the game code.
using mock objects frequently could be an indication that the code relies too much on heavy objects with complex interactions instead of many, loosely-coupled, simpler objects.
this is quite subjective, but the constant  feedback has a surprising morale-boosting effect.
by default,  all functions are virtual, so overriding behaviors and creating mocks is  simpler than c++.
for example, a function called getnearestenemy() would be a perfect candidate to be tested this way.
sometimes that means you’ll have to write some duplicate setup code between two tests, but it’s a small price to pay to keep the tests as simple as possible.
we had seen in practice from previous projects  that we can certainly do tdd to create low-level and intermediate-level  libraries (math, collision, messaging, etc).
i’ll definitely  put up an announcement here when we release the first version.
refactor the code and/or tests.
that’s why tdd’s benefits deal with better code design and structure, ease of refacto…
it also had the effect of creating new evangelists for the new technique.
keeping each unit test to just a handful of lines makes it much easier to  understand at a glance.
tdd is a development methodology, not a testing one.
well: int main() { return 0; } // visual reports as success int main() { return 1; } //
that  depends on your situation and experience, and the type of code you’re  writing.
the rest of the input system works through the gamecontroller interface, but for all the tests we provide a mockgamecontroller() which allows us to control what input values we feed to the tests.
in fact it was initially developed  for internal use only, but then i realised it might be useful for a wider  audience.
even if you have “many, loosely coupled, simpler objects” you  need somehow to break dependencies in order to test them in isolation.
however, it’s the same facility to weave code out of thin air that  can become our greatest danger.
that means we always have a version of our engine and tools that runs under windows, which makes running unit tests very easy and convenient.
- errors: although we do not use exceptions in our final build, they are  used everywhere in our normals builds.
in test projects) you get failed  tests, in the case of assertion errors, or you can use check_assert to verify a  particular expression does assert.
btw, the full subversion checkout command is this: svn co https://svn.sourceforge.net/svnroot/unittest-cpp/unittest++ if anyone’s interested in an unpackaged sneak preview.
right now, the idea of writing code without writing tests first feels quite alien to most of us, and we treat tdd like the scaffolding in building construction: a necessary tool that will not be shipped to the customer but that helps tremendously during development.
run tests frequently being able to write tests easily is a requirement for successfully rolling out tdd.
it’s a matter of just a few seconds, but it was too long to run the unit tests automatically as a postbuild step after every compilation.
even though this can initially sound like a scary proposition, it really isn’t a problem.
sometimes it might force you to expose some state that would otherwise be  private, but if it’s something that you need to test from the user point  of view, then making it public is probably not a bad idea anyway.
ideally, when something breaks, you want only a small number of tests failing so you can quickly pinpoint the problem.
but would it really work for high-level code that would build on low-level code?
gdc2006 presentations links game developers conference 2006 closed its doors last week.
nobody wants to spend extra time writing unit tests when they can be  implementing the features that are due for this milestone.
tdd is a development methodology, not a testing  one.
continuing with the health powerup example, notice that the test involved a world object, a player object, and a healthpowerup object.
we are using tdd here too.
in oo we indeed have a best practices recommendation to avoid deep inheritance hierarchy since it typically leads to a very fragile and overcomplicated structure.
i’ll have a more detailed announcement up tomorrow  explaining the rational for the new unit testing framework and what i think its  unique selling points are.
members of that team were then moved on to other teams, where they became the resident tdd expert.
the minimum support that we needed was the ability to run an  executable through the command line and capture the output and, ideally, the  return code.
tdd and high-level code one of the questions we had when we jumped into tdd is whether it was going to hold for high-level code.
if a library has 500 tests associated with it, we can say that it’s roughly half as complex as a library with 1000 tests.
slowly, other people  might see how useful the tests are, or how much easier it is to refactor that  code, and eventually the time might be right to roll out tdd.
when doing this, it can be  extremely useful to have somebody on board with previous tdd experience who can  help guide the process, set up the environment, and avoid common early mistakes.
a few people can have a hard time switching over to the tdd mentality, but  to take full advantage of tdd, it is best to let the design emerge from the  tests and the refactoring rather than trying to plan everything up front.
for example, a mock object could record what functions were called and what values were passed, or could be set up to return a set of fixed values when one of its functions is called.
in our case, it is unusual to have unit tests that are more than 15 lines long.
i dont have any good ideas about how to  implement tdd for them.
as a bonus, that layer  could report which functions were called and with what parameters.
graphics, middleware, and other apis probably the biggest barrier that people see to doing unit testing and tdd with games is how to deal with graphics.
not only  does visual studio indicate this in the output log, but it will also fail any  automated builds in your build server without having to do any extra checks.
bunch o’links on agile/testing topics titus suggested i post some of the links i keep sending him, so here they are agile game development
http://www.tilander.org/aurora
automated functional tests can be extremely  useful catching high-level problems, gathering performance and memory  utilization data, and removing some of the mechanical testing from qa and  letting them concentrate on issues such as gameplay balance and flow.
tdd fits best with other agile development practices.
he builds his castles in the air, from air, creating by exertion of the imagination.
maybe you run through a level, checking that feature and making sure nothing else looks obviously broken, or maybe you even step in the debugger to make sure your code is getting called and doing what it’s supposed do.
the cycles are very short, perhaps only a minute or two.
this is the trickiest aspect to test.
as a general rule, we find that if any other part of the game is going to depend on the code we are writing, then it’s probably worth doing it with tdd and having a full set of unit tests for it.
a good example of this approach is how we wrote our input system with tdd.
keep tests independent unit tests should be completely independent of each other.
additionally, the tdd approach results in much simpler, decoupled code.
also, because the code was first created  by testing it in isolation from the rest of the code, you will end up with a  much more modular, simpler design.
code with outdated comments.
especially when tests are developed through tdd, they deal  less with corner cases and more with program features.
object state make a function call, then check that the state of the object or some part  of the system has changed correctly.
frederick p. brooks, jr. part of the appeal of programming is that, as brooks describes, it allows us to build ornate castles in the air, where our imagination is the only limit.
because of  that, our unit tests on platforms other than windows are only executed  manually, and by the build server.
even though the engine is not tdd-friendly  at all, we still find more benefit from doing tdd with it.
you can browse through them to see what kind of use a class is intended to have, you can look up a particular test to see what kind of assumptions a function makes about its parameters, or you can even comment out some code that makes no sense and see what tests break to give an idea of what it does.
is it the same cppunitlite2  with the changed title?
needing to write overly long unit tests is usually a sign that the test is involving too much code and could probably be re-written in a better way.
if at any point you thought tests should be passing and they  aren’t, you know something has gone wrong: not an hour ago, not ten  minutes ago, but sometime in the last minute.
after we wrote those small utility programs, we were able to run unit tests  on the consoles just like we did under windows.
regarding hooking up assert, i’m currently using charles  nicholson’s cpptestharness
functional tests are extremely useful, especially if they are fully automated, but they fill a very different role than unit tests.
cppunit comparison of c++ unit-test frameworks this entry was posted in test-driven development by noel.
as an added benefit, people tend to behave based on how they think they are being measured.
for example, it can test that a health pack  doesn’t add more health past the player’s maximum, or it can test  that a particular effect disables depth writes.
you are forced to use that code in a test.
we tried three different approaches, from most involved to least involved: we started with the first approach, wrapping the api as we were using it, but the amount of extra work we had to do to wrap complex apis like direct3d and opengl quickly became overwhelming.
i use them quite a bit in the project  i’m working on.
sample code from presentation.
this is the most direct way of testing, and it works great for functions that do computations and return the computed value.
beware of testing functions that return boolean results indicating if the function failed or succeeded.
in your game binary you can link a library  containing your (perhaps platform specific) assert handler, for a dialog box,  or whatever your preference is in that case.
test-driven development can be a very effective development technique.
this tests that state changes directly, so it’s also a very straightforward form of testing.
for example, a test named playerhealth is not very helpful.
notice the trade-off between slightly  slower short-term speed vs. massive gains later on.
maybe if we were working on a commercial graphics rendering middleware it would be worth the effort.
ideally, tdd and refactoring can flatten out the classical cost-of-change  over time curve into something like this.
but even if it’s broken down into libraries or  modules, keep them as independent of each other as possible instead of as one  long list of dependencies.
i’m not sure it’s the  same with regrad to an object composition structue, which could be quite deep.
we are hoping that as tdd becomes more common in the games industry, middleware providers will make their apis more tdd friendly and even ship with their unit tests.
is it the same cppunitlite2 with the changed title?
sometimes it just takes a little bit of  refactoring of the existing code and it becomes a lot easier to add new tests.
i’ve been looking at various software development methodologies lately and i’ve found some pretty interesting blogs on one type that is very exciting.
conclusion test-driven development can be a very effective development technique.
as a general rule, whenever a set of unit tests goes over two seconds, it means something is wrong and we try to fix it (even if a unit test takes a full ms, which is a huge amount for a unit test, you can still run 1000 of them in a single second).
sean maceij, noel and i differ a bit on mocks.
so inter-object communication and thus a need for mocks is supposed to  be a norm rather than an exception.
several companies working with the unreal engine are currently using ununit for their game projects.
it might lead to larger interfaces than absolutely necessary, but it also sometimes shows that a class really should be split into two, and one of the classes should contain the other one.
by following our best practices for unit tests, it becomes  really obvious when something breaks, and we can usually check in a fix right  away.
we’re  not doing tdd because it’s a “good” thing to do, but because  we want to ship a better-quality product faster and cheaper than we did before.
all of  that makes tdd with unrealscript not just possible, but very effective.
not only does this allow us to  unit-test our code in isolation, but we also keep future merges with  epic’s codebase as simple as possible.
similarly, changing functionality or  adding new feature towards the end of the development cycle suddenly becomes a  lot less risky and scary.
nobody wants to spend extra time writing unit tests when they can be implementing the features that are due for this milestone.
then we can examine that the list in our  mocked canvas matches our expectations.
on platforms in which the internals of the graphics api are more  open, you might be able to examine more states by looking at the graphics  command buffer.
otherwise, if it’s a  one-shot deal with the highest-level code, then it’s probably fine  without tdd.
for example, we could render a mesh, but we  wouldn’t be able to find out how many triangles were sent to the  hardware.
in our case, we prefer to discuss very rough concepts of where we expect something to go, what it should do in the future, and maybe some very, very rough organizational structure.
clearly, none of those approaches are  ideal.
how does tdd help us deal with the complexity of software, and, more  specifically, how does it solve some of the problems listed in the  introduction?
that simple fact makes it so all code is  created with the user of the code in mind, not the implementation details.
specifically, in this context, each  unit test deals with something almost trivially small, which can probably be  done in less than a minute.
our full test looks like this: test (playershealthdoesnotincreasewhilefarfromhealthpowerup) { world world; const initialhealth = 60; player player(initialhealth); world.
you are  forced to use that code in a test.
just because we have twice as much code it doesn’t mean we have twice the complexity.
finally, another very good  reason to avoid involving extra code is that tests that only work on a small  set of code are typically much faster than tests that involve large systems and  complex initialization/shutdown sequences.
it also makes any bad  practices apparent early on and they can be dealt with before rolling it out  (making overly complex tests or functional, rather than unit tests).
michael feathers’ book working effectively with legacy code, explains exactly that situation and gives some very good guidelines on how to go about unit testing with a codebase without existing unit tests.
finally, another very good reason to avoid involving extra code is that tests that only work on a small set of code are typically much faster than tests that involve large systems and complex initialization/shutdown sequences.
the first thing to realize is that graphics are just part of a game.
the first thing we had to do was to create a unit-testing framework for unrealscript.
it’s not something you’re going to deliver to your customer, but it’s an absolute necessity, it needs some time commitment to set it up, and you wouldn’t dream of doing any complex building without it.
we can easily set up a world with a  couple of enemies, call that function, and verify that it returns the enemy  entity we expected.
there is no doubt that the best situation to roll out tdd is with a fresh  new codebase.
few media of creation are so flexible, so easy to polish and rework, so readily capable of realizing grand conceptual structures.
maciej very nice article.
so if this is made clear, people will be much more likely to be  strict about applying tdd and not falling back on writing code without tests.
we  have hundreds or thousands of tests per library, so that means they have to run  blazingly fast or they’ll get in the way.
http://citym.org/blog/archives/2006/03/backwards_is_fo.html citym.org “backwards is forward: making better games with test-driven  development” one of my coworkers alerted me to the presence of a fantastic article by  noel llopis on the games from within site entitled backwards is forward: making  better games with test-driven development.
there should be no need for visual inspection or reading some text.
the programmer, like the poet, works only slightly removed from pure thought-stuff.
the main difference was that  running any program on the consoles had a noticeable startup time delay.
ideally, when something breaks, you want only a small number of tests  failing so you can quickly pinpoint the problem.
we have developed a full codebase doing tdd from the start, and we had no difficulty writing high-level code with tdd.
as a bonus, unittest++ formats the failed test message so it can be parsed by visual studio and it is easy to navigate to the location of the test.
having tests depend on each other will cause chains of failing tests, making it difficult to track the problem down to the source.
probably by writing some code like this: world world; const initialhealth = 60; player player(initialhealth); world.
what is test-driven development?
this tests that state changes directly, so  it’s also a very straightforward form of testing.
not that i was present to see it… http://jroller.com/page/obie?entry=further_proof_agile_is_turning obie  fernandez further proof agile is turning the corner i love to find information that backs up my belief that agile development  practices are gaining wider acceptance, such as this article describing how to  do tdd game programming in c++.
also, compilation is very fast, which keeps iteration times low (large, badly organized c++ codebases can take a long time to link).
in general, the less known or more likely to change something is, the less design we do.
but would it really work for  high-level code that would build on low-level code?
you should be able to use it with practically no changes.
also, compilation is very fast, which keeps iteration times  low (large, badly organized c++ codebases can take a long time to link).
then tests can count on a specific sequence  of numbers being generated and check the results accordingly.
by following our best practices for unit tests, it becomes really obvious when something breaks, and we can usually check in a fix right away.
our  castles in the air can quickly become snowballs that are too large to be moved  and shaped to fit our needs.
test diagnostics (could be easily integrated with any other unit testing framework – i did it for cunit!).
does this mean you shouldn’t do any design ahead of time?
frederick p. brooks, jr. 1.
when working on high-level code, it can be  tempting to let tests degenerate into functional tests that involve the whole  game engine.
run it and see it fail (in c++, it’s likely that it won’t even  compile).
that part is fully untested.
let’s have a more detailed look at the tdd cycle: write a single unit test for a very small piece of functionality.
the very concept of cohesion and delegation assumes that every object concentrates on its own responsibilities and delegates the rest to other objects.
this is the most direct  way of testing, and it works great for functions that do computations and  return the computed value.
things like character state machines, game flow, or specific game entities were  done through tdd without any problems, and greatly benefited from the tdd  approach.
code has a tendency to grow beyond initial  expectations, quickly surpassing our capacity to fully understand it.
we do not want a assert-dialog here.
not useing mocks would lead to more complex  tests and fixtures.
also, as noel mentions, if you design your code to be horizontal  you need them less.
we have all experienced how development slows down to a crawl towards the end of a project.
the reason we have macros like check_equal is that unit tests  need to be fully automated.
i use them quite a bit in the project i’m working on.
let’s start by looking at the traditional programming process.
this makes it so everybody is running unit tests for all code all the time, which greatly improves the build stability.
still, some initial studies have some interesting initial findings (http://collaboration.csc.ncsu.edu/laurie/papers/tddpaperv8.pdf), even if the study was not very rigorous and had a very small sample.
we  have successfully applied it to game development in a variety of situations,  and we’re convinced of the many benefits it has provided us.
in our case, we prefer to discuss very rough concepts of where we expect  something to go, what it should do in the future, and maybe some very, very  rough organizational structure.
one of the drawbacks of this approach is that we’re working directly with the hardware, so tests actually do initialize and shutdown the graphics system every time (except for those platforms out there that can only initialize the graphics system once), so they can be more time consuming.
a few people can have a hard time switching over to the tdd mentality, but to take full advantage of tdd, it is best to let the design emerge from the tests and the refactoring rather than trying to plan everything up front.
you really want to test that the function does  things correctly, not just that it reports it did them.
a good analogy to tdd is scaffolding in a building construction.
this is very interesting article.
needing to write overly long unit tests is usually a  sign that the test is involving too much code and could probably be re-written  in a better way.
a test that involves a lot of code across many different systems is usually  referred to as afunctional test(also called a customer test).
another interesting read, i’m sure it will go down well at gdc.
a good situation for using a mock object could be testing hud rendering.
in fact it was initially developed for internal use only, but then i realised it might be useful for a wider audience.
it is  very interesting to note though, that most programmers at high moon quickly  accepted tdd, and soon became very enthusiastic about it and started using it  in all their code, including their home projects.
if you’re interested in applying tdd but you don’t have a commitment from your manager or lead, it is possible to start doing it on the side on your assigned tasks.
so inter-object communication and thus a need for mocks is supposed to be a norm rather than an exception.
still, some  initial studies have some interesting initial findings  (http://collaboration.csc.ncsu.edu/laurie/papers/tddpaperv8.pdf), even if the  study was not very rigorous and had a very small sample.
another approach is to take control over the random number generator at the beginning of the test and rig the output so we know what sequence of numbers is going to come up.
- assertions: we provide a hooking mechanism, so every assertion that gets  fired inside a test result in failing the test.
broken builds happen much less frequently, and they’re usually caused by a missing file or a different platform not compiling correctly.
as our target platforms increase in power and memory, our castles become larger and more intricate.
safety net with tdd, just about every bit of code has some associated tests with it.
once we had that organization, we were able to test any part of the game or engine without having to worry about graphics.
few media of creation are so flexible, so easy to polish  and rework, so readily capable of realizing grand conceptual structures.
should tdd be used for every single line of code?
let’s put tdd in practice by following the normal practice and writing our first test.
you can confidently apply obscure performance optimizations to squeeze that last bit of performance out of the hardware and know that nothing is broken.
“backwards is forward: making better games with test-driven development” one of my coworkers alerted me to the presence of a fantastic article by noel llopis on the games from within site entitled backwards is forward: making better games with test-driven development.
at high moon, every library has a separate test project that creates an executable that links with the library and runs all the tests.
the very concept of cohesion and delegation assumes that every object  concentrates on its own responsibilities and delegates the rest to other  objects.
the same three approaches can be used for any middleware or external api.
we prefer to let the tests guide us, and if at some point we’re going away from what we had in mind at the beginning, we can stop to reconsider if we’re heading in the right direction.
the best thing about unit tests as documentation: they  can never get out of date.
the first thing we had to do was to create a unit-testing  framework for unrealscript.
i’m not sure it’s the same with regrad to an object composition structue, which could be quite deep.
surprisingly, none of the game console environments we develop for supports that simple operation, so we were forced to write a small set of programs using the system api to do exactly that.
if unit tests are only dealing  with the minimum amount of code, they should be able to run really fast.
that’s why tdd’s benefits deal with better code design and  structure, ease of refactoring, etc, and not with correctness.
a unit test is a test that verifies a single, small behavior of  the system (also called a developer test).
this is required reading before you start doing any tdd: these other books will also come in handy: very useful mailinglists and web sites: resources dealing with tdd and agile game development: c++ unit-testing frameworks: hello.
i’ll definitely put up an announcement here when we release the first version.
an example of some code that we would not use tdd for is trigger code: when the player goes around the corner, wake up two ais and trigger a different background music.
if unit tests are only dealing with the minimum amount of code, they should be able to run really fast.
test  time: 0 seconds.
test-driven development (tdd) turns the programming process around: as  before, you break down a problem mentally into smaller problems (or at least a  single smaller problem), but now you write a unit test for that small feature,  see it fail (since you still haven’t implemented anything), and then  write the code to make that test pass.
it can be disconcerting to  always be looking only a few minutes into the future and implementing the  “simplest thing that could possibly work,” but it really works.
as a bonus, unittest++ formats the failed test  message so it can be parsed by visual studio and it is easy to navigate to the  location of the test.
but even more importantly, tests should run very frequently, and a failed test should be treated the same way as a failed build.
we have sat in frustration, unable to  do any work for several hours while the game build is broken.
i think part of the reason is that mocks are much easier  to create in unrealscript than in c++.
by default, all functions are virtual, so overriding behaviors and creating mocks is simpler than c++.
then tests can count on a specific sequence of numbers being generated and check the results accordingly.
it’s certainly not the textbook-perfect example you’ll read about in tdd books, but it’s certainly possible.
we’ll see an example of a simple test in the next section.
{ cpptestharness::reportassert(_description, _file, _line); } return false; } whenever the test library is linked (ie.
we  all know how easy it is for comments to get out of date, yet there is very  little we can do about it.
should tdd be used for every single line of  code?
development speed this is the million-dollar question: does tdd slow development?
the unit test is wrapped with a catch so  that any error is correctly redirected to a unit-test fail.
in general, the less known or more likely to change something is, the  less design we do.
this makes it so everybody is running  unit tests for all code all the time, which greatly improves the build  stability.
using fixtures can cut down tremendously on  the amount of test code you have to write.
after a while, you might have written enough code that you can run the game and try to see if the feature works.
the best thing about unit tests as documentation: they can never get out of date.
it’s very important to not fall for the temptation of skipping tdd for a very short-term gain (aka milestone of the month).
the important thing to remember is to make sure you’re testing your code, not the api itself.
there was no graphics system initialization, databases, etc.
a few times we caught ourselves starting  to write a unit test that called a function many times in a loop and then  averaged the result, but that’s totally the wrong way to go.
the check_equal macro is the part that performs the actual  check, and it takes as parameters the expected value and the actual value.
addison-wesley, 1999 astels, david, test driven development: a practical guide.
a better approach is to separate the random decision from the code that  uses it.
for that reason i developed a small library, called bmock, which is more or  less in line with jmock and nmock, but realistically takes into account c/c++  specifics.
the programmer, like the poet, works only slightly removed from pure  thought-stuff.
pair programming can be extremely helpful, especially at the beginning while rolling out tdd and getting everybody on board.
addison-wesley,  2002 these other books will also come in handy: fowler, martin, refactoring: improving the design of existing code.
if tests aren’t going up, or they’re going up more slowly than other times, we know something is wrong and we’re not making much progress.
because this is the easiest and most straightforward way of testing, we should use this approach whenever possible.
in our particular case, not only were we doing tdd, but we were doing all the extreme programming practices (pair programming, continuous integration, collective code ownership, etc).
http://www.gamesfromwithin.com
now with regard to your comment about mocks and flat object structure i  think i see where does the argument lay.
this test-driven development (tdd) paper was presented yesterday at gdc  (the game developers conference).
it’s not  yet packaged as separate library & test-app projects and it’s only  vs.net 2005 just now
so whenever any test fails, the whole build fails.
there should be no need for visual inspection or  reading some text.
as our target platforms increase in power and memory, our castles become larger  and more intricate.
on the positive side, because the tests are exercising the graphics  api and hardware directly, we catch things that the first approach  wouldn’t have caught (for example, sending incorrect parameters to a  function).
the most common testing pattern for this situation is a mock object.
you have to format your message like so: std::cout  0 check somewhere).
just because we have twice as much code it doesn’t mean we have twice  the complexity.
it’s very important to not fall for the temptation of  skipping tdd for a very short-term gain (aka milestone of the month).
once you’re happy with it, you check it into source control and move on to another task.
it’s not yet packaged as separate library & test-app projects and it’s only vs.net 2005 just now
introduction part of the appeal of programming is that, as brooks describes, it allows  us to build ornate castles in the air, where our imagination is the only limit.
in general, we prefer not to even think of  classes or draw uml diagrams on whiteboards before starting, because such  discussions can then lead implementation too much.
that’s actually really important, because it allows us to run $(targetpath) in the postbuild step and have the executable return the number of failed tests.
we have wrestled with somebody else’s code, just to  give up or fully re-write it in despair.
cpptestharness is pretty much final (bugs and all) because i’m spending  my unit test framework-writing time on unittest++ these days.
isolate graphics calls.
in the worst case, you can just revert your changes and start over.
soon or later  most of the presentations will be published in the official site.
another approach is to take control over the random number generator at the  beginning of the test and rig the output so we know what sequence of numbers is  going to come up.
let me highlight a  point where i hold a different opinion, namely using mocks for tdd.
this is a set of best practices we have found to be particularly important for all of our development with tdd.
if the engine was not developed with tdd, it can be very difficult to use your code in isolation or figure out how to break things up so they can be tested.
you may use fakes as michael feathers suggests, but manual creation of fakes could very soon turn to be too burdensome.
the most important reason to minimize the amount of code involved in a test is to keep things simple.
imagine then how useful tdd can be on a full engine developed with tdd from the start.
as a general rule, we find that if any other part of the game is going to  depend on the code we are writing, then it’s probably worth doing it with  tdd and having a full set of unit tests for it.
the input system deals with getting input values from gamepads and other  controllers.
we have seen first-hand the difficulty of squashing insidious many-headed bugs.
this is quite subjective, but the constant feedback has a surprising morale-boosting effect.
in “object interactions” you wrote: “using mocks frequently could be an indication that the code relies too much on heavy objects with complex interactions …” i do not think it’s true.
unit tests  are supposed to be simple and fast, so any loops in a test are usually very  suspect.
in fact there many system things you would like to have a control over  within your test environment: random numbers, clock, file system,  communication, even threads.
it let the team become more comfortable with tdd and get to the point where they are as productive as they were before.
overall, the complexity of the codebase is greatly reduced with tdd.
members of that team were then moved on to other teams, where they became the  resident tdd expert.
the world object can be a very lightweight container for game entities without any other dependencies.
also, because the code was first created by testing it in isolation from the rest of the code, you will end up with a much more modular, simpler design.
now we compile this code and we get the following output: running unit tests... 1 tests run there were no test failures.
resources this is required reading before you start doing any tdd: beck, kent, test driven development:
once you’re happy with it, you check it into  source control and move on to another task.
even if it takes a few more minutes to make  an enemy character testable in isolation, it is well worth it in the long run.
in our groups, we have a test chart, which is updated every day and shows the total count of tests.
while that comes, i will be posting here links to papers and presentations (only about programming) made public… good article games from within: backwards is forward: making better games with test-driven development one thing that should be clear and is important to stress is that tdd is not just writing unit tests.
we recommend unittest++, which is a  lightweight c++ unit-test framework that supports multiple platforms, is easy  to adapt and port, and was created after using tdd in games for several years.
for us, after doing that for a few weeks, we realized that the benefits we were deriving from it weren’t worth the time we were spending.
that means they shouldn’t be talking to the hardware, they shouldn’t be initializing and shutting down expensive systems, and they most definitely should not be doing any file i/o. all our unit tests are timed (another feature of unittest++), and the overall time for the test run is printed after it runs.
we inserted a layer  between the graphics renderer and the graphics api that exactly mimicked the  platform api.
the  key to working with tdd is to realize that refactoring is an integral part of  the development process and should happen regularly every few tests.
tests as a measure of progress software developers have been struggling for a long time to find a good  measure of progress or work done.
object state make a function call, then check that the state of the object or some part of the system has changed correctly.
the most important thing is to make sure your  tests run automatically (remember the postbuild trick).
we can do this either by mocking the random number generator  object or by setting some global state on the random number generator,  depending on how it is implemented.
a test that involves a lot of code across many different systems is usually referred to as afunctional test(also called a customer test).
a much better name would be playerhealthgoesupwhenrunningoverhealthpowerup.
keeping that in mind helps to write true unit tests and not functional tests for the api.
what does  this mean in practice?
try setting something like that in your current engine and you might be surprised by how many implicit dependencies you find in different parts of the engine.
i return false from the above  function as true is the signal to try and hook into the debugger, which i  don’t want when running automated tests.
however, that severely limits the amount of large-scale refactorings we can do to keep things as testable as possible, so it’s a tough trade-off.. one unique aspect of the unreal engine is that it makes heavy use of its scripting language, unrealscript.
the framework is intended to make the task for writing and running unit tests as simple as possible.
you want a test to check one thing and only one thing; that way, when something breaks, it’s immediately clear what went wrong.
in the meanwhile, you can get it from here: http://sourceforge.net/project/showfiles.php?group_id=158151 noeal, sean, a good article, i really enjoyed reading it.
add(&player, transform(axisy, 0, vector3(10,0,10))); healthpowerup  powerup; world.
some projects use code line counts to  determine progress, others use features completed, while others just look at  the number of hours spent at the office.
the very first thing we  want to implement is that if the pl ayer walks over a health powerup, he  receives some amount of health.
setting expectations is also very simple: bmock_expect_return(12,f(35)); the bmock library is built on the top of the c++ boost library and uses its boost.
broken builds happen much less frequently, and  they’re usually caused by a missing file or a different platform not  compiling correctly.
failure int main() { return -1; } // success !?!
so after another trip to san jose, i must say that the sessions were hit  and miss.
if you’re working on the 10th iteration of a well-known sports game franchise, for a known platform, and you know exactly what you’re going to do, up front design can be more beneficial.
a mock object is an object that implements the interface  of another object, but its only purpose is to help with the test.
so i suppose there’s a chance the unittest++ assert system will work in a similar way.
for this to happen, it’s important to let the tests guide the code and not the other way around.
a good start is to label each test clearly with a name that describes exactly what the test is supposed to do.
as per standard unix error code parsing when you hook stuff up to the postbuild step, instead it seems to flag errors as result > 0.
mockpp, at least in my opinion, is a too straitforward port from java and c#, and is not suitable for c/c++ (similar to what happend with cppunit).
not useing mocks would lead to more complex tests and fixtures.
the unit test is wrapped with a catch so that any error is correctly redirected to a unit-test fail.
functional tests are extremely useful, especially if they are fully automated,  but they fill a very different role than unit tests.
applying tdd to game development has its own unique challenges that are not usually discussed in the tdd literature.
clearly, avoid having your engine as one  big, intertwined module.
any decent unit test framework  should support fixtures, so use them whenever they’re needed.
whenever you have some common code in two or more tests, you can use a  fixture.
a few times we caught ourselves starting to write a unit test that called a function many times in a loop and then averaged the result, but that’s totally the wrong way to go.
even though this can initially sound like a scary  proposition, it really isn’t a problem.
jim tilander great article, especially like the air-castle reference one little tip for people who dedice to hook things up in visual studio, it  took us a little headscratching to realize that visual studio doesn’t do  result !
rabin’s gpg article, so by providing a definition in the test harness  library of: bool customassertfunction( /* … */ ) cpptestharness::reportassert(_description, _file, _line); return false; whenever the test library is linked (ie.
extracting an interface, renaming everything and worrying about virtual function overhead can put a damper on the whole process.
this paper will be presented at the 2006 game developers conference noel llopis and sean houghton high moon studios presentation slides.
what was a pleasant surprise is that broken builds are  much easier to fix.
i’ve been lazy and haven’t updated the cpptestharness homepage yet, but unittest++ has many notable improvements already.
the test code has been written so  it’s extremely simple, so its complexity is minimal.
different platforms most game developers today need to develop for a variety of platforms: pcs (windows, macs, or linux), game consoles, handhelds, etc.
that means we always have a version of our engine and tools that runs under  windows, which makes running unit tests very easy and convenient.
backwards is forward: making better games with test-driven development posted on march 12, 2006  by noel
once the  team is over the hump, and given the right tools and development environment,  the impact of tdd on development speed is minimal.
as you can see, it can’t  get much easier than that.
it is very interesting to note though, that most programmers at high moon quickly accepted tdd, and soon became very enthusiastic about it and started using it in all their code, including their home projects.
in the worst case, you can just  revert your changes and start over.
surprisingly, none of the game console environments we develop for  supports that simple operation, so we were forced to write a small set of  programs using the system api to do exactly that.
i have an assert macro that calls customassertfunction as per steve
otherwise, if it’s a one-shot deal with the highest-level code, then it’s probably fine without tdd.
our experience is that tdd, like any other new development technique, slows  development down at the beginning while the team is learning it and becoming  familiar with it.
that’s why tdd’s benefits deal with better code design and structure, ease of refactoring, etc, and not with correctness.
pair programing also has the added  advantage of making programmers less likely to skip writing tests, which can be  a common reaction early on.
we don’t really care about state, just that a certain number of  function calls happened.
setting expectations is also very simple:  bmock_expect_return(12,f(35)); the bmock library is built on the top of the c++ boost library and uses its  boost.
the  resulting code is much easier to work with as a result, and it directly solves  the problems it was intended to fix.
it can be disconcerting to always be looking only a few minutes into the future and implementing the “simplest thing that could possibly work,” but it really works.
it’s a matter of just a few seconds, but it was too long to run the unit  tests automatically as a postbuild step after every compilation.
the larger the team and the more complex the problem, the more tdd saves time in the long run.
tdd and game development applying tdd to game development has its own unique challenges that are not  usually discussed in the tdd literature.
gethealth()); and that’s exactly what the test will look like, only we’ll  have to surround it with a macro to take care of all the bookkeeping and to  give it a descriptive name.
working with a full  game engine, you might end up writing a small module that is fully surrounded  by the engine code.
for example, there’s no reason the ai module  needs to know anything about graphics or sound, but it will need to know about  a world representation and have access to the messaging system.
we want to verify that the hud elements are rendered in a specific order, so we create a mock for the rendering canvas which will keep an ordered list of the elements that get passed to it.
having a good mocks library would help here drammatically.
it is not ideal, but the large majority of  the problems show up in the windows tests, so as long as those continue being  run all the time, we catch most problems on time.
using mock objects  frequently could be an indication that the code relies too much on heavy  objects with complex interactions instead of many, loosely-coupled, simpler  objects.
we recommend unittest++, which is a lightweight c++ unit-test framework that supports multiple platforms, is easy to adapt and port, and was created after using tdd in games for several years.
the important thing to remember is to make sure you’re testing your code,  not the api itself.
after a while, you might have written enough code that you can run the game and  try to see if the feature works.
if  they are different, it will mark the test as failed, and output a message with  as much information as possible.
unrealscript is a surprisingly good language for unit testing.
let’s have a more detailed look at the tdd cycle: a unit test is a test that verifies a single, small behavior of the system (also called a developer test).
clearly, none of those approaches are ideal.
ash henstock another interesting read, i’m sure it will go down well at gdc.
also, if you are able to use the code under test with a minimal amount of other code or libraries, it means you are creating very modular, self-contained code, which will help with the overall design.
builds are rarely broken for more than a few minutes at a time, which can completely change how you organize your code in source control.
also, code at that level is often writ ten by designers in a game-specific scripting language, so tdd might not be a viable option.
two tips that helped us apply tdd to high-level code: keep tests as true unit tests.
what i’m lacking in texts about tdd are multiplayer (server-client) games, tho.
in addition to being an excellent  introduction to… http://chanson.livejournal.com/140114.html chris hanson making better games with test-driven development noel llopis (games from within) and sean houghton, backwards is forward:  making better games with test-driven development: one of the questions we had  when we jumped into tdd is whether it was going to hold for high-level code.
once you decide to implement a specific piece of functionality, you break the problem down mentally into smaller problems, and you start implementing each of them.
test-driven development (tdd) turns the programming process around: as before, you break down a problem mentally into smaller problems (or at least a single smaller problem), but now you write a unit test for that small feature, see it fail (since you still haven’t implemented anything), and then write the code to make that test pass.
i’ll have a more detailed announcement up tomorrow explaining the rational for the new unit testing framework and what i think its unique selling points are.
right now,  the idea of writing code without writing tests first feels quite alien to most  of us, and we treat tdd like the scaffolding in building construction: a  necessary tool that will not be shipped to the customer but that helps  tremendously during development.
ideally, tdd and refactoring can flatten out the classical cost-of-change over time curve into something like this.
if tests aren’t going up, or they’re going up  more slowly than other times, we know something is wrong and we’re not  making much progress.
there are a variety of freely-available unit-test frameworks for c++ and other languages.
soon or later most of the presentations will be published in the official site.
extracting an interface, renaming  everything and worrying about virtual function overhead can put a damper on the  whole process.
in oo we indeed have a best practices  recommendation to avoid deep inheritance hierarchy since it typically leads to  a very fragile and overcomplicated structure.
keeping each unit test to just a handful of lines makes it much easier to understand at a glance.
things change too much from project to project and team to team.
as an added benefit, people tend to behave based on how they think they are  being measured.
we’ll see an example of a  simple test in the next section.
if a library has 500  tests associated with it, we can say that it’s roughly half as complex as  a library with 1000 tests.
noel llopis i addition to what charles said, we’re planning on releasing  unittest++ imminently.
that means you can be merciless about refactoring your code, and you can still  be confident that it will work if all the tests continue to run.
the answer depends on your priorities and game.
if tdd doesn’t help with this, then there’s very little point to it  (other than keeping programmers happy).
we have seen first-hand the difficulty of squashing insidious  many-headed bugs.
ideally, we wanted to develop the graphics renderer library with tdd as  well, and there’s no way to avoid dealing with platform-specific graphics  calls.
remember, what we really want to test is that our code behaves  correctly, not that the graphics api works as documented.
slowly, other people might see how useful the tests are, or how much easier it is to refactor that code, and eventually the time might be right to roll out tdd.
if you’re interested in applying tdd but you don’t have a  commitment from your manager or lead, it is possible to start doing it on the  side on your assigned tasks.
sometimes it might force you to expose some state that would otherwise be private, but if it’s something that you need to test from the user point of view, then making it public is probably not a bad idea anyway.
randomness and games most games involve a fair amount of randomness: the next footstep sound you  play can be any one of a set of sounds, the next particle emitted has a random  speed between a minimum and a maximum, etc.
we can do this either by mocking the random number generator object or by setting some global state on the random number generator, depending on how it is implemented.
i want to know a little more about unittest++.
after all, an api is just a list of classes or functions, and you  have a lot of control over how and when they get called.
additionally, the tdd approach  results in much simpler, decoupled code.
as a general rule, you want to  remove the randomness from your tests.
if the engine was not developed with tdd, it can be very  difficult to use your code in isolation or figure out how to break things up so  they can be tested.
good  design will come up through those refactorings as needed by the tests we have  written and the code we have implemented.
keep tests very fast the unit tests we write are compiled and executed as a postbuild step.
functional tests are a great complement to unit tests, so it’s  important not to forget about them.
creating an  object in a test and reusing it in a different test is asking for trouble for  the same reasons as we discussed earlier: when a test fails, you want to be  able to zero in on the failing test and the problem that is causing it to fail.
we have found that counting the number of unit tests is a really good  measure of progress.
a mock object is an object that implements the interface of another object, but its only purpose is to help with the test.
for example, instead of just having aplayfootstep() function that takes care of computing a random footstep and then playing it, we  can break it into intcomputenextfootstep() which is just a random  function call, and aplayfootstep(int index), which we can now test  very easily.
tdd ensures that  your code does whatever you wanted it to do, not that it does it correctly.
it flags errors by parsing the  output window!
in our system, we have an interface named gamecontroller with  a sample() function.
we have found that counting the number of unit tests is a really good measure of progress.
i have an assert macro that calls customassertfunction as per steve rabin’s gpg article, so by providing a definition in the test harness library of: bool customassertfunction( /* … */ ) { if(_expression_evaluation) //
we also wanted to run the unit tests in each platform we develop for, but we had to make a few changes to compensate for the shortcomings of those platforms.
if at any point you thought tests should be passing and they aren’t, you know something has gone wrong: not an hour ago, not ten minutes ago, but sometime in the last minute.
specifically, in this context, each unit test deals with something almost trivially small, which can probably be done in less than a minute.
there was no graphics system initialization,  databases, etc.
most of the time we are, and we simply hadn’t thought things  through enough at the beginning (or thought through them too much and we simply  didn’t need that level of flexibility).
our full test looks like this: test (playershealthdoesnotincreasewhilefarfromhealthpowerup) { world  world; const initialhealth = 60; player player(initialhealth);  world.
the do make many tests much simpler and orthagonal gdc -> fun + motivation
in the end, we ended up settling for a combination for the second and third  approaches: testing the state whenever possible, and isolating the calls the  rest of the time.
the extra code does not take significantly longer to write initially, and it allows us to move a lot faster once we have accumulated more code and we need to refactor or optimize the code in any way.
once  you decide to implement a specific piece of functionality, you break the  problem down mentally into smaller problems, and you start implementing each of  them.
automated functional tests can be extremely useful catching high-level problems, gathering performance and memory utilization data, and removing some of the mechanical testing from qa and letting them concentrate on issues such as gameplay balance and flow.
we have seen countless hours of work go up in smoke as code is thrown away and started from scratch for the next project.
different platforms most game developers today need to develop for a variety of platforms: pcs  (windows, macs, or linux), game consoles, handhelds, etc.
things like character state machines, game flow, or specific game entities were done through tdd without any problems, and greatly benefited from the tdd approach.
no problem seems too large as  long as you’re taking small steps in its direction and getting feedback  that you’re in the correct track.
http://entland.homelinux.com/blog/2006/03/29/gdc2006-presentations-links/ entblog gdc2006 presentations links game developers conference 2006 closed its doors last week.
several  companies working with the unreal engine are currently using ununit for their  game projects.
it is possible to simply write code faster than it is to write the tests first, but as soon as that code needs to be refactored, debugged, used by somebody else, or simply gets more complex, any time savings quickly disappear.
sample code from  presentation.
using fixtures can cut down tremendously on the amount of test code you have to write.
we also wanted to run the unit tests in each platform we develop for, but  we had to make a few changes to compensate for the shortcomings of those  platforms.
for some of us, tdd has rekindled the  same joy of programming that we discovered in the 8-bit computers we cut our  teeth on.
third-party game engines if dealing with apis was not straightforward, working with a full  third-party game engine that was not developed with tdd is even more  challenging.
also, if you are able to use the code under test with a minimal amount of  other code or libraries, it means you are creating very modular, self-contained  code, which will help with the overall design.
the do make many tests much simpler and orthagonal http://adruab.net/?p=20 adruab.net gdc -> fun + motivation
we prefer to let the tests  guide us, and if at some point we’re going away from what we had in mind  at the beginning, we can stop to reconsider if we’re heading in the right  direction.
even though at first glance it might seem like the whole system is about making system calls to poll the data, there is a lot of common code that is totally platform independent: button mappings, edge detection, filtering, plugging/unplugging controllers, etc.
what i’m lacking in texts about tdd are  multiplayer (server-client) games, tho.
presentation slides.
all of that makes tdd with unrealscript not just possible, but very effective.
the answer is an unconditional yes.
implementing tdd let’s put tdd in practice by following the normal practice and  writing our first test.
for example, a function called getnearestenemy() would be a  perfect candidate to be tested this way.
if some tests involve a large amount of the codebase, they will constantly break for unrelated reasons.
beware of testing functions that return boolean results indicating if the  function failed or succeeded.
noel, the bmock library is not published yet.
one thing not described here is how you should  adapt your error-reporting mechanism (errors and asserts) inside an unit-test.
adopting tdd we started with tdd by first trying it with a small group on a separate  project.
in our case, since the tests  are a postbuild step, there was nothing special we had to do in the build  server, and a failed test would be reported just as code that didn’t  compile correctly.
pair programing also has the added advantage of making programmers less likely to skip writing tests, which can be a common reaction early on.
that’s why tdd’s benefits deal with better code design and  structure, ease of refacto… proudly  powered by wordpress
milestone pressures, a  fluctuating game industry, growing teams and budgets, and the breakneck pace of  hardware change don’t help an already difficult situation.
so after another trip to san jose, i must say that the sessions were hit and miss.
the unit tests provide you with instant feedback up to several times per  minute.
code has a tendency to grow beyond initial expectations, quickly surpassing our capacity to fully understand it.
the main difference was that running any program on the consoles had a noticeable startup time delay.
if tdd doesn’t help with this, then there’s very little point to it (other than keeping programmers happy).
having a good mocks library would help here  drammatically.
michael feathers’ book working effectively with legacy code, explains exactly that situation  and gives some very good guidelines on how to go about unit testing with a  codebase without existing unit tests.
additionally, since the test executable returns a value with the number of failed tests, a failing test will return a non-zero value, which is interpreted by the build chain as a failed build.
while that  comes, i will be posting here links to papers and presentations (only about  programming) made public… http://pinkpucker.net/articles/2006/04/15/good-article anonymous http://www.sinowish.com/?p=110 sinowish 发现之旅 games from within:
once the team is over the hump, and given the right tools and development environment, the impact of tdd on development speed is minimal.
builds are rarely broken for more than a few minutes at a time, which can  completely change how you organize your code in source control.
if they are different, it will mark the test as failed, and output a message with as much information as possible.
of course, if you hook this up to regular make or something else that is slightly more sane, you won’t have these problems… /j nice article.
in the meanwhile, you can get  it through sourceforge.net subversion server if you want.
similarly, changing functionality or adding new feature towards the end of the development cycle suddenly becomes a lot less risky and scary.
by the way, just a quick announcement to say that the first release of  unittest++ is out.
http://agiletesting.blogspot.com/2006/03/bunch-olinks-on-agiletesting-topics.html agile testing bunch o’links on agile/testing topics titus suggested i post some of the links i keep sending him, so here they  are http://www.crazysalsadancer.com/2006/03/agile-game-development.html
as a general rule, you want to remove the randomness from your tests.
the extra code does not take  significantly longer to write initially, and it allows us to move a lot faster  once we have accumulated more code and we need to refactor or optimize the code  in any way.
even though at high moon we develop console games, we use windows as our primary development environment because of the good development tools and the fast iteration time.
a c++ unit-testing framework designed with game development in  mind.
for that reason i developed a small library, called bmock, which is more or less in line with jmock and nmock, but realistically takes into account c/c++ specifics.
that’s actually even more complicated  than what we want for our small testing steps, so let’s start with an  even simpler test that requires the least amount of effort: if we have a player  and a powerup, and the player isn’t anywhere near the powerup, his amount  of health doesn’t change.
th is can take as long as a couple of months.
cpptestharness is pretty much final (bugs and all) because i’m spending my unit test framework-writing time on unittest++ these days.
it is not ideal, but the large majority of the problems show up in the windows tests, so as long as those continue being run all the time, we catch most problems on time.
the rest of the input system works through the gamecontroller interface, but for all the tests we provide a mockgamecontroller() which allows us to control what input values we  feed to the tests.
that simple fact makes it so all code is created with the user of the code in mind, not the implementation details.
each platform implements a platform-specific version of the gamecontroller (for example d3dcontroller) and does  the raw sampling of all buttons and axis through platform-specific api calls.
we have hundreds or thousands of tests per library, so that means they have to run blazingly fast or they’ll get in the way.
most of the time we are, and we simply hadn’t thought things through enough at the beginning (or thought through them too much and we simply didn’t need that level of flexibility).
a better approach is to separate the random decision from the code that uses it.
our experience is that tdd, like any other new development technique, slows development down at the beginning while the team is learning it and becoming familiar with it.
the framework is intended to make the task for writing  and running unit tests as simple as possible.
try setting  something like that in your current engine and you might be surprised by how  many implicit dependencies you find in different parts of the engine.
what’s worse than uncommented code?
besides, we  don’t yet have one dev kit for every developer station, so we  couldn’t count on always having a target platform available.
we have seen  countless hours of work go up in smoke as code is thrown away and started from  scratch for the next project.
besides, we don’t yet have one dev kit for every developer station, so we couldn’t count on always having a target platform available.
tdd ensures that your code does whatever you wanted it to do, not that it does it correctly.
third-party game engines if dealing with apis was not straightforward, working with a full third-party game engine that was not developed with tdd is even more challenging.
in our case, it is unusual to have unit tests that are  more than 15 lines long.
whenever you have some common code in two or more tests, you can use a fixture.
test time: 0 seconds.
good design will come up through those refactorings as needed by the tests we have written and the code we have implemented.
you write code, and you compile it to know whether things are going well.
regards, charles i addition to what charles said, we’re planning on releasing unittest++ imminently.
http://jgiors.wordpress.com/2006/03/23/test-driven-development  john’s rambles test-driven development
isolate an api  function call or a group of api function calls into a single function, and test  that your function is called at the right time.
in addition to being an excellent introduction to… making better games with test-driven development noel llopis (games from within) and sean houghton, backwards is forward: making better games with test-driven development: one of the questions we had when we jumped into tdd is whether it was going to hold for high-level code.
that means that making any changes to the library or tests and triggering a compile will also run all the tests.
ideally, we wanted to develop the graphics renderer library with tdd as well, and there’s no way to avoid dealing with platform-specific graphics calls.
what does this mean in practice?
this approach is much simpler, but there were  some things we couldn’t test.
in general, we prefer not to even think of classes or draw uml diagrams on whiteboards before starting, because such discussions can then lead implementation too much.
the resulting framework is called ununit and is freely available for download through udn (unreal developer network).
tdd and high-level code one of the questions we had when we jumped into tdd is whether it was going  to hold for high-level code.
adopting tdd we started with tdd by first trying it with a small group on a separate project.
you can confidently apply obscure  performance optimizations to squeeze that last bit of performance out of the  hardware and know that nothing is broken.
i will try to put it somewhere at sourceforge when i come back from  my recent business trip (in two weeks).
of course, if you hook this up to regular make or something else that is  slightly more sane, you won’t have these problems… /j http://entland.homelinux.com/blog ent nice article.
in addition to running tests locally, the build server also runs all the unit tests at the same time it does code builds.
it will probably come as no surprise to anybody that writing code with tdd  results in more code being written.
if you’re working on the 10th iteration of a  well-known sports game franchise, for a known platform, and you know exactly  what you’re going to do, up front design can be more beneficial.
in test projects) you get failed tests, in the case of assertion errors, or you can use check_assert to verify a particular expression does assert.
we have sat in frustration, unable to do any work for several hours while the game build is broken.
keep tests simple this is related to the previous best practice.
for example, it can test that a health pack doesn’t add more health past the player’s maximum, or it can test that a particular effect disables depth writes.
we have successfully applied it to game development in a variety of situations, and we’re convinced of the many benefits it has provided us.
lessons learned design and tdd one of the most important benefits we get from tdd is the better code  design that it creates.
one thing not described here is how you should adapt your error-reporting mechanism (errors and asserts) inside an unit-test.
when are you going to release something (there are no  releases on sourceforge project page)?
having an agile  mindset fits very well with the idea of finding the design through tests.
pair  programming can be extremely helpful, especially at the beginning while rolling  out tdd and getting everybody on board.
gethealth()); } the macros test and check_equal are part of a  unit testing framework.
when all else fails, this is a  useful technique for dealing with calls into external apis.
the unit tests created through tdd serve as a very  effective form of documentation.
we  want to verify that the hud elements are rendered in a specific order, so we  create a mock for the rendering canvas which will keep an ordered list of the  elements that get passed to it.
how to test when writing unit tests, there are three main ways of testing your code: return value make a function call, and check the return value.
design and tdd one of the most important benefits we get from tdd is the better code design that it creates.
this is a general good  practice, but it is more so with tdd.
the function that calls into  the graphics api itself won’t be tested, but all it does it make some  straight calls.
as per standard unix error code parsing when you hook stuff up to  the postbuild step, instead it seems to flag errors as result > 0.
it might lead  to larger interfaces than absolutely necessary, but it also sometimes shows  that a class really should be split into two, and one of the classes should  contain the other one.
asher maceij, noel and i differ a bit on mocks.
with bmock a mock version of a function is just a simple idl-like annotation: bmock_function(int,f,1,(in(int,x))).
we have developed a full codebase doing  tdd from the start, and we had no difficulty writing high-level code with tdd.
for some of us, tdd has rekindled the same joy of programming that we discovered in the 8-bit computers we cut our teeth on.
high-level game scripts how far is it worth taking tdd?
it’s  not something you’re going to deliver to your customer, but it’s an  absolute necessity, it needs some time commitment to set it up, and you  wouldn’t dream of doing any complex building without it.
regards, charles http://www.gamesfromwithin.com
for example, rendering a certain mesh should set  a specific vertex declaration.
it was also  discouraging us from using new api functions just because they hadn’t  been wrapped before.
run tests and see them pass.
the resulting code is much easier to work with as a result, and it directly solves the problems it was intended to fix.
run tests frequently being able to write tests easily is a requirement for successfully rolling  out tdd.
the resulting framework is called ununit and is  freely available for download through udn (unreal developer network).
the most important thing to do in this situation is to separate the code we write as much as possible from the engine code.
the very first thing we want to implement is that if the pl ayer walks over a health powerup, he receives some amount of health.
this is a key practice for writing good unit tests.
that  means they shouldn’t be talking to the hardware, they shouldn’t be  initializing and shutting down expensive systems, and they most definitely  should not be doing any file i/o. all our unit tests are timed (another feature of unittest++), and the  overall time for the test run is printed after it runs.
i’ve been looking at various software development methodologies  lately and i’ve found some pretty interesting blogs on one type that is  very exciting.
add(&powerup, transform(axisy, 0, vector3(-10,0,20))); world.
the rest is done  automatically.
there are a variety of freely-available unit-test  frameworks for c++ and other languages.
– ash http://www.cnicholson.net charles nicholson paulius: unittest++ actually started as a copy of cpptestharness.
in the meanwhile, you can get it through sourceforge.net subversion server if you want.
you also need something to deal with system api  as you described in “graphics, middleware, and other aips”.
a fixture is a set of common code that is executed before and after  each test that uses that fixture.
overall, the complexity of the  codebase is greatly reduced with tdd.
the cycles are very short, perhaps  only a minute or two.
we also found that limiting each unit test to a single check statement or two resulted in tests that were the easiest to understand.
sometimes it just takes a little bit of refactoring of the existing code and it becomes a lot easier to add new tests.
it’s certainly not the  textbook-perfect example you’ll read about in tdd books, but it’s  certainly possible.
you want a test to check one  thing and only one thing; that way, when something breaks, it’s  immediately clear what went wrong.
sometimes the test code is as large as the  code under test itself.
you really want to test that the function does things correctly, not just that it reports it did them.
in fact there many system things you would like to have a control over within your test environment: random numbers, clock, file system, communication, even threads.
this test-driven development (tdd) paper was presented yesterday at gdc (the game developers conference).
for example, we could send an event of nearby noise to an ai in  “idle” state and check that its state changes to  “alert” in response.
in the meanwhile, you can get it from here: http://sourceforge.net/project/showfiles.php?group_id=158151 asher sterkin noeal, sean, a good article, i really enjoyed reading it.
each platform implements a platform-specific version of the gamecontroller (for example d3dcontroller) and does the raw sampling of all buttons and axis through platform-specific api calls.
regarding hooking up assert, i’m currently using charles nicholson’s cpptestharness
asher http://www.mungosmash.com
it let the team become more comfortable with tdd and get to the point  where they are as productive as they were before.
also, as noel mentions, if you design your code to be horizontal you need them less.
add(&powerup, transform(axisy, 0, vector3(-10,0,20)));  world.