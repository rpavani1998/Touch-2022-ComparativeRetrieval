theclean action causes all generated files to  be deleted.
options can accept a value, such as--dotnet=mono or act  as a flag, like--with-opengl.
ifplain is true, no pattern matching will be performed (faster).
os.chdir("path") path is the file system path to the new working directory.
newoption { trigger = "outdir", value = "path",  description= "output directory for the compiled executable" }
if you have a solution that builds on  windows, and you want to a binary for the xbox 360, you would call: premake4 --platform=xbox360 vs2005 the files generated by this call will include the default win32 build  normally present in visual studio solutions, plus a new set of configurations  which target the xbox 360.
when in doubt, feel free to post a questionover in the forums.
the os.isfile function checks for the existence of file.
action is one of: embed all png image files into the target binary.
in addition to these project generation capabilities, premake also provides  a completelua scripting environment, enabling the automation of complex  configuration tasks, such as setting up new source tree checkouts or creating  deployment packages.
haystack is the string to check.
embedding the scripts in release builds, premake uses a copy of the scripts embedded into static  strings: seesrc/host/scripts.c.
you can use the /scripts command line argument, like so: premake4 /scripts=~/code/premake4/src gmake or set a premake_path environment variable: premake_path=~/code/premake4/src you need to specify the location of the premake src/ directory, the one containing_premake_main.lua.
solutions are defined using the solution function.
prefix is the new file name prefix.
debugargs { "args" } note that this settings is not implemented for xcode 3, which requires a per-user configuration file in order to make it work.
if you've got any  ideas on how i might explain it better please leave a comment.
if you don't need them, just don't call theplatforms function at all, in which case the toolset's default behavior will be used.
"**.h", ["sources/*"]
premake provides an ever-growing list of build settings that you can tweak; the following table lists some of the most common configuration tasks with a link to the corresponding function.
the _options global variable lists the current set of command line options and their values, if any.
implibprefix "" the implibsuffix function specifies a file name suffix for the import library base file name.
premake will look for a file named premake4.lua by default, much like make looks for a file named makefile.
this feature requires premake 4.1 or later.
on windows, you may use a semicolon-delimited list if drive letters might be included.
premake also provides conventions for defining and  handling command line options and actions, allowing you to build sophisticated  configuration scripts.
solutions define a common set ofconfigurations and encapsulate one or more  projects (see below).
this is a string value, set to one ofc, c++, or c#.
path is the output directory for the library, relative to the currently executing script file.
kind "consoleapp" set the project to generate a shared library (dll).
if you just have a question you want answered, stop by the forums and start a new discussion.
configuration {} each call to configuration function creates a new configuration block object.
imagine yourself the owner of an open source software project.
normally you would include the native platform, and list it first to make it the default.
"force the use of opengl for rendering, regardless of platform" } note the commas after each key-value pair; this is required lua syntax for a table.
this  variable will be nil.
p = path.getextension("path")
user guide the official premake documentation.
solutions, projects, and configurations.
options is a list of compiler flags and options, specific to a particular compiler.
the includedirs function specifies the include file search paths.
the actual code to be executed when the action if fired should be placed in  theexecute() function.
as you can see, theflags function provides  most of the features, and is a good place to start if you aren't sure how to  make something go.
premake also provides conventions for defining and handling command line options and actions, allowing you to build sophisticated configuration scripts.
the path.getabsolute function converts a relative path an absolute path.
$ hg pull -u $ premake4 embed see debug vs. release modes below for an explanation (and maybe eventually i'll think of a better way to do this).
language "c++" kind 'consoleapp'
note that a solution must exist to contain the project.
targetprefix "" the targetsuffix function specifies a file name suffix for the compiled binary target.
libdirs { "libs", "../mylibs" } if you need to discover the location of a library, use the os.findlib  function.
so, by default, it will configure your windows  applications to call the standardmain() entry point instead of the  windows-specificwinmain().
configuration "opengl" links { "opengldrv" }    configuration"direct3d" links { "direct3ddrv" }    configuration"software" links { "softwaredrv" }
if the makefile is executed without any arguments, the first build configuration (in the example above,debug) will be used.
a table of values: the os.uuid function returns a universally unique identifier.
each project specifies a kind which determines what kind of output is generated, such as a console or windowed executable, or a shared or static library.
feel free to leave your ideas in the comments.)
i'll see your comment and fix it up, and the in meantime others can benefit from your input.
configuration "debug" flags { "symbols" } configuration"release" flags { "optimize" }
setting the location for a project works the same way.
this section is very much a work in progress, which i hope to gradually build up over time.
if you are having trouble building your project, start by contacting the project manager.
names is a list of configuration names.
for example, you can define a symbol across all configurations of all  projects by setting it at the solution level, before any filters are enabled.
the wildcard* will match files in one directory; the wildcard ** will match files in one directory and also recurse down into any subdirectories.
the solution name, provided as a parameter to the function, is used as the  file name of the generated solution file.
it uses only a handful of platform  dependent routines (directory management, mostly).
table.implode(arr, "before", "after", "between") arr is the array to be converted into a string.
premake can be built in either "release" (the default) or "debug" modes.
this is best illustrated with some examples.
if you haven't already, read the documentation.
for those of you unfamiliar with visual  studio i will try to provide to provide the synonyms used by other toolsets; if  i miss any let me know
to build a different configuration supply theconfig argument: make config=release most projects provide debug and release configurations; to see the available targets and configurations, type: make help remove all generated binaries and intermediate files with: make clean premake generated makefiles do not support a make install step.
condition is the logical condition to test.
os.matchdirs("src/**") -- recursive match matches =
because of the descriptive nature of the lua language, your build scripts  will often look more like static configuration files than mini-programs.
in this case, the help text will appear like  this: --gfxapi=api choose a particular 3d api for rendering; one of:  opengl opengl direct3d direct3d (windows only) software software renderer
you can change the output location using the location function.
unlike the example above, you now use the value as a keyword in your configuration blocks.
as an example, if this command line was used to launch premake... $ premake4 vs2005 ...then _action will be set to "vs2005".
targetdir targetextension targetprefix targetsuffix targetname "mytarget" the targetprefix function specifies the file name prefix for the compiled binary target.
project "myproject" kind "consoleapp" language  "c++" locations by default, premake will place generated solution and project files in the  same directory as the script which defined them.
this is only used by visual studio.
the following table lists the available sources for keywords.
premake tries hard to make all build tools on all platforms perform as  similarly as possible.
name is the new base file name.
the source code is hosted on bitbucket; file  downloads are hosted onsourceforge.
configuration "debug" defines { "_debug" } define a symbol only when targeting visual studio 2005.
os.rmdir("path") path is the file system path to be removed.
the string.findlast function finds the last instance of a pattern within a string.
configuration { "linux", "gmake" } buildoptions { "`wx-config --cxxflags`", "-ansi", "-pedantic" }
path.iscppfile("path")
ides like visual studio provide their own mechanism for switching build  configurations.
true if the array contains the value, false otherwise.
file paths should be specified relative to the location of the script file.
from within your script, you can identify the current action with the _action global variable, a string value.
os.matchdirs("src/*") -- non-recursive match matches =
for more information on lua programming, see the lua website or programming in lua.
in addition to configurations, you can also target multiple hardware platforms, such as a 32-bit build and a 64-bit build.
the tutorial below will show you how to use these example files to get started on your own actions.
local sln = solution() you can the global variable _solutions to list out all of the currently defined solutions.
sometimes it is important to know which platform you are targeting; you  might need to define specific symbols or link to different libraries.
in the world of make, you can think of projects as a makefile for one particular library or executable; a solution is a meta-makefile that calls each project as needed.
describe your c, c++, or c# software project usinga simple, easy to read syntax and let premake generate the project files for: version 4.1 of premake added experimental support for cross-compiling, targeting: premake allows you to manage your project configuration in one place and still support those pesky ide-addicted windows coders and/or cranky linux command-line junkies.
p = path.getdirectory("path")
when linking against system libraries, do not include any prefix or file extension.
if not, go ahead and create a new ticket.
it is followed by a list of arguments to be substituted into the format string.
the * will match against a single directory,** will recurse into subdirectories as well.
trueval is the condition evaluates true, falseval otherwise.
premake is a "plain old c" application, distributed as a single executable file.
if you are having trouble using premake to generate build files for a  particular project, your best bet is to contact the manager of the project  first.
in general, it is better to include the full (relative) path to the assembly inlinks instead.
the platform is just another configuration axis, which you can mix and  match with any other selectors.
the pchheader function sets the main header file for precompiled header support.
"clean" then -- do something end   -- use an option value in a  configuration targetdir ( _options["outdir"] )
path.iscfile("path")
for instance, the dotnet option is used to change which .net compiler set is used in the generated files.
so, by default, it will configure your windows applications to call the standardmain() entry point instead of the windows-specificwinmain().
the project function creates a new project and makes it active.
this is a common mistake; i still make it myself every once in a while.
the path.iscppfile function returns true if the specified path represents a c++ source code file, based on its file extension.
it uses only a handful of platform dependent routines (directory management, mostly).
the source code is  available under thebsd license.
targetname targetdir targetprefix targetextension -- add "-d" to debug versions of files configuration "debug" targetsuffix "-d" the uuid function sets the universally unique identifier (uuid) for a project.
it isn't rocket science, and  you probably already have the gist of it from the example above, so feel free  to skip around.
if you are interested in developing more complex  actions, for instance to add support for a new toolset, seecreate a new  action in the extending premake section.
if no build action is specified for a file a default action will be used, based on the file's extension.
a solution contains projects, and defines the available configurations  solution"myapplication" configurations { "debug",  "release" }   -- a project defines one build target project  "myapplication" kind "consoleapp" language "c++"  files{ "**.h", "**.cpp" }   configuration  "debug" defines { "debug" } flags { "symbols" }    configuration"release" defines { "ndebug" } flags {  "optimize" } the indentation in this sample is arbitrary, this is the way i happen to  like it.
instead,  usean existing copy of premake to generate the files for your particular  toolset and environment.
target platforms are part of the solution, just like  configurations: solution "mysolution" configurations { "debug",  "release" } platforms { "native", "universal" } not all tools will support all of the possible targets (currently only  visual studio supports the xbox 360 platform).
the actual code to be executed when the action if fired should be placed in theexecute() function.
if you've found a bug in the software, or if you want to request a new feature please visit thepremake trackers on sourceforge.
define two library file search paths.
if you get stuck, if something isn't clear, or you want to see a demonstration of something that isn't covered by the exampledrop a note in the forums and i'll try to help you out.
the same goes with a single  list argument: defines({"debug", "trace"}) defines {"debug" ,"trace"}
use theinclude() function or lua's dofile() to link all the files together.
why is my windows program trying to call main() instead of winmain()?
or maybe you just want an easy way to reconfigure your project for  different situations or environments, pulling in different source code or  libraries, switches and options.
adding files you add files—source code, resources, and so on—to your project
premake tries hard to make all build tools on all platforms perform as similarly as possible.
solution "mysolution" configurations { "debug", "release" } language "c++" project "myproject" kind "consoleapp" files "**.cpp" links { "mytool" } prebuildcommands { "mytool --dosomething" } project"mytool" kind "consoleapp" files "**.cpp" the location function sets the destination directory for a generated solution or project file.
the key is the option identifier ("dotnet"), which references the command line value ("mono") or an empty string for valueless options.
you must create a solution and list the available configurations before creating the first project.
a windows executable project named "myproject" will produce a binary namedmyproject.exe.
includedirs { "../includes/
so you could, for instance, put all header files in a group called "headers", no matter where they appeared in the source tree.
i try to check them daily and respond personally to most  posts.
all terms must be present for the block to be applied.
targetprefix ("prefix") by default, the system naming convention will be used: a "lib" prefix for posix libraries (as inlibmyproject.so), and no prefix elsewhere.
when defining a list of values you need to surround them in curly brackets, lua's syntax for a list.
implibprefix ("prefix")
links { "png", "zlib" } when specifying libraries, system-specific decorations, such as prefixes or  file extensions, should be omitted.
files { "hello.h", -- you can specify exact names  "*.c", -- or use a wildcard... "**.cpp" -- ...and recurse  into subdirectories } you can use wildcards in the file patterns to match a set of files.
in this case you want to put the libraryproject name, not the library file name, in the list of links for the dependent project.
you could place a bit of code like this  anywhere in your script.
if you are storing the generated visual studio project files in a version control system, this will create a lot of unnecessary deltas.
the os.outputof function runs a shell command and returns the output.
true if the path matches a well-known c++ file extension, false otherwise.
options can accept a value, such as--dotnet=mono or act as a flag, like--with-opengl.
i am using my own homegrown testing framework, which is defined in tests/testfx.lua.
have you ever been stuck using an old version of visual studio because it was too difficult to upgrade the entire team?
premake4 embed this command embeds all of the scripts listed in _manifest.lua into src/host/scripts.c.
if you think something should be possible and you can't figure out how to  do it, feel free topost a question in the forums and someone will help you out.
the implibextension function allows you to change this default.
name is a unique name for the project.
you can change this behavior by adding the winmain build flag to your package, like so: flags { "winmain" } i love code contributions!
str is the string to be split.
the os.mkdir function creates a new directory.
pchsource pchheader "afxwin.h" pchsource "afxwin.cpp" the pchsource function sets the main source file for precompiled header support.
pattern is the separator pattern at which to split; it may use lua's pattern matching syntax.
debug # build in debug mode, when generated with premake 3.x
using the example and script above, the generated files will be placed inc:\code\myproject\build.
iif(x ~= nil, "x is " ..
build options are always linker specific and should be targeted to a particular toolset.
keywords is a list of identifiers (see below).
thelocation function allows you to change this location.
matches = os.matchfiles("pattern")
it saves the time that would otherwise be spent manually  keeping several different toolsets in sync.
you now have a solution/makefile/workspace that you can load and build.
the targetname function specifies the base file name for the compiled binary target.
look at the other folders at that location, you'll get the idea.
this example will apply the symbol only for debug builds on mac os x. configuration { "debug", "macosx" } defines { "debug_macosx" } multiple terms must use lua's curly bracket list syntax.
skip ahead to the next section to learn about the important differences between the build configurations.
the project name will be used as the file name of the generated solution file.
table.contains(arr, value) arr is the array to test; value is the value being tested for.
at the top level of every build is a solution, acting as a container and meta-project (other tools use the termworkspace).
files { "**.c" } excludes { "tests/*.c" }
you may also use the modifiersnot and or to build more complex conditions.
configuration "debug" debugdir "bin/debug" the defines function adds preprocessor or compiler symbols to a project.
scripting with premake
by using premake, software developers can save time and support more tools and users.
project "myproject" objdir "objects" set object directories per configuration.
it may contain single (non-recursive) or double (recursive) asterisk wildcard patterns.
a list of substrings.
most builds will need  only a single solution, but you are free to create more if needed.
make config=debug64
the configuration block object contains the following values: the configurations function specifies the set of build configurations, such as "debug" and "release", for a solution.
path is the file system path to check.
a sample script premake is built on lua, a powerful, fast, light-weight scripting language.
so avoid special characters; spaces are okay.
platforms { "x32", "x64" } platform settings like any other configuration-specific value, platform-specific settings are  set withconfiguration filters.
premake will use the appropriate naming conventions for the current platform.
some things you should know before you digging into the premake internals, in no particular order: before you begin, you should be able to build and run the debug configuration of premake.
see the examples below for a more complete explanation.
to learn how to use premake for your own software projects see scripting  with premake.
the path containing the library file, if found.
generating the project files
links { "png", "zlib" } when specifying libraries, system-specific decorations, such as prefixes or file extensions, should be omitted.
the path.getextension function returns the file extension portion of a path.
symbols specifies a list of symbols to be defined.
as before, this new option will be integrated into the help text, along  with a description of each of the allowed values.
targetname ("name") by default, the project name will be used as the file name of the compiled binary target.
files may be set on the solution, project, and configuration level.
newoption { trigger = "gfxapi", value =
once added to your script, the option will appear in the help text,  and you may use the trigger as a keyword in your configuration blocks.
if there are no arguments this array will be empty.
" the implibname function specifies the import library base file name.
it may be specified with (libx11.so) or without (x11) system-specific decorations.
the file extension portion of the path, or an empty string if no extension is present.
files located in other directories should be specified relative to the  script file.
these platforms can be quickly switched between from within  your ide, or with a command-line parameter on the generated makefile.
if you downloaded a prebuilt binary package you can skip this page, which discusses how to build the premake source code.
files { "hello.h", -- you can specify exact names "*.c", -- or use a wildcard... "**.cpp" -- ...and recurse into subdirectories } you can use wildcards in the file patterns to match a set of files.
you can specify multiple flags.
you now have a  solution/makefile/workspace that you can load and build.
in this example, myproject uses a build dependency to ensure that mytool gets built first.
at the top level of every build is a solution, acting as a  container and meta-project (other tools use the termworkspace).
i love code contributions!
vpaths { ["headers"] =
these string values may be  delimited with single (') or double (") quotes.
someone may have asked the  same question before.
specify source code files files, excludes define  compiler or preprocessor symbols defines locate include files includedirs link against libraries, frameworks, or sibling projects links, libdirs enable debugging information flags optimize for size or speed flags turn compiler or linker features on or off flags, buildoptions, linkoptions set the name or location of the compiled target file targetname, targetextension , targetprefix, targetdir
values at the same level are  evaluated in the order in which they are encountered in the script.
retrieve version information for the host operating system.
if you've got any ideas on how i might explain it better please leave a comment.
the most common  configuration set, which is usually provided by default by most ides, is  "debug" and "release".
the current working directory.
configuration "debug" objdir "../obj_debug" configuration"release" objdir "../obj_release" the os.chdir function changes the current working directory.
link against some system libraries.
the string.startswith function returns true if the given string starts with the provided sequence.
libdirs { os.findlib("x11") } a configuration is a collection of flags and options to apply to a build, including build flags, header file and library search directories, and more.
removing this file (which is done by premake's clean action) will restore the default settings.
unsupported platforms are silently ignored; they simply will not appear in the generated build scripts.
the _premake_command global variable stores the full path to the premake executable.
a new uuid, a string value with the format 74cfc033-fa4d-4b1e-a871-7dc48fa36769.
this is how i can ship a single binary, rather than the whole source tree.
when calling a function with a single string constant for an argument, lua allows you to drop the parenthesis that would normally appear around the argument list.
an option modifies the behavior of the action.
image options are currently only supported for xbox 360 targets.
the prelinkcommands function specifies shell commands to run after the source files have been compiled, but before the link step.
if a project with the given name already exists, it is made active and returned.
if you have any questions, ask them over in the forums and i'll try to help you out.
from within your script, you can identify the current action with the  _action global variable, a string value.
there are also functions that only accept a single value, such as solution and project names, the project kind and language, and so on.
source is the file system path to the file to be copied.
these scripts will run on any platform, ending batch/shell script duplication.
it is a good idea to run a quick search first to make sure your issue hasn't already been reported.
if you modify any of the core lua scripts (anything ending in.lua), you must also update these embedded strings before your changes will appear in the release mode build.
so if i have a library project called "mylibrary"... project "mylibrary" kind "sharedlib" ...i can link against it like this.
if you can't figure out how to make a patch, get it to me however you can.
implibextension ("ext") by default, the toolset static library file extension will be used (.lib with windows tools, .a
theobjdir function allows you to change this location.
the simplest premake command is: premake4 action
resincludedirs { "../lua/include", "../zlib" }
the one exception to the rule is mac os x frameworks, where the file extension is required to identify it as such.
this example creates a functionbar in the namespace premake.foo.
this is best illustrated with some  examples.
flags { "flag_list" } if a project includes multiple calls to flags the lists are concatenated, in the order in which they appear in the script.
the native platform, in contrast, does not addany flags to the command line and lets gcc use its default behavior to target the current platform.
yes, using lua's os.execute() function.
the path.getdrive function returns the drive letter portion of a path, if present.
path.isresourcefile("path") path is the file system path to check.
an action is what gets triggered when you run premake; the command premake4 vs2008 triggers the visual studio 2008 action, while premake4 clean triggers the clean action.
you can see a complete list of actions and other options by typing: premake4 --help
configuration { "debug" } defines "_debug" -- this symbol will appear in settings for all platforms if a specific platform identifier is listed, the settings will be applied only when that platform is specifically selected by the user.
solution "mysolution" configurations { "debug",  "release" }   project "myproject" the project name, like the solution name, is used as the file name for the  generated project file so avoid special characters.
note that when working against the mercurial sources it is a good idea to  refresh the embedded scripts after each update.
the following sections of this guide will walk you through all of the features of premake in a somewhat logical fashion.
premake is a build configuration tool.
premake will generate a build script with the right instructions for a 64-bit or an xbox build, but that build will only succeed if the corresponding tools and libraries have been installed on the developer machine.
configuration { "keywords" }
import libraries are generated for windows dll projects.
this will save you the trouble of embedding the scripts and recompiling with each change, and will greatly speed up development.
if there is  no action (for instance, if the command waspremake4 /help)
below is my best take so far; feedback and  suggestions for improvement are very much appreciated.
implibname implibdir implibextension implibsuffix implibprefix "plugin" the prefix may also be set to an empty string for no prefix.
libdirs { "paths" } library search directories are not well supported by the .net tools.
getting premake if you don't have premake already, you can download it now.
if you are interested in developing more complex actions, for instance to add support for a new toolset, seecreate a new action in the extending premake section.
you can check for an option using the _options table, which contains a list of key-value pairs.
i will do my best to make sense of it.
file is the name of the source file, specified relative to the currently executing script file.
"windows" then -- do something windows-specific end
debug builds load the scripts dynamically at startup and so can skip this step.
i personally like to use just one file for simple projects, and one-file-per-project for more complex builds.
it allows you to generate project files for tools that you do not own.
path is the directory where the generated files should be stored, specified relative to the currently executing script file.
this example writes out simple "solution" and "project" files, showing how to get out the project information using the premake apis.
see platforms for more information.
the _working_dir global variable stores the current working directory at the time premake was launched.
adding support for  additional toolsets and languages is straightforward.
these scripts will run on any platform, ending batch/shell  script duplication.
this example sets the build action for all png image files.
enter premake premake is a build configuration tool.
unlike the example above, you now use the value as a keyword in  your configuration blocks.
solution "mysolution"   project  "mylibraryproject" -- ...project settings here...
you can use the or modifier to match against multiple, specific terms.
sometimes it is important to know which platform you are targeting; you might need to define specific symbols or link to different libraries.
when built in debug mode, premake will read its lua scripts from the disk at startup, enabling compile-less code/test iterations, and therefore faster development.
you can specify a different file name using the file argument, like so: premake4 --file=myfilename.lua you can define your entire project in one script file if you want, or you can split up the projects into their own files, or any other organization you can dream up.
see below for some usage examples.
build options are always compiler specific and should be targeted to a particular toolset.
theimplibname function allows you to change this default.
configuration "not windows" defines { "not_windows" } finally, you can reset the configuration filter and remove all active keywords by passing the function an empty table.
the _script global variable stores the full path of the currently executing script.
however, spaces are allowed in  configuration names.
actions and options premake recognizes two types of arguments: actions and options .
premake will deduce the correct library path and name based  on the current platform and configuration.
the path.isabsolute function returns true if the specified path is an absolute path.
in this case you want to put the libraryproject  name, not the library file name, in the list of links for the dependent  project.
format is a formatting string containing c printf() style formatting codes.
in addition to the terms listed above, you may use the * and ** wildcards to match more than one term or file.
note that lua syntax requires parenthesis around the function parameters in this case.
in this case, the help text will appear like this: --gfxapi=api choose a particular 3d api for rendering; one of: opengl opengl direct3d direct3d (windows only) software software renderer
links { "references" } if a project includes multiple calls to links the lists are concatenated, in the order in which they appear in the script.
not working cross-platform?
solution "mysolution" configurations { "debug", "release" } language "c++" project "myexecutable" kind "consoleapp" files "**.cpp" links{ "mylibrary" } project "mylibrary" kind "sharedlib" files "**.cpp" you may also create links between non-library projects.
configuration "**.png" buildaction "embed" if multiple keywords are specified, they will be treated as a logical and.
the path.rebase function takes a relative path and makes it relative to a different location.
if you don't need them, just  don't call theplatforms function at all, in which case the toolset's default  behavior will be used.
configurations are specified using theconfigurations function; see the next section for more information.
debug # build in debug  mode, when generated with premake 3.x
for release builds (the  default) this has no impact, just build as normal and go.
is it possible to invoke external tools?
the path.translate function converts the file separators in a path.
your users  are asking for a visual studio 2008 solution, but you don't have visual studio!
implibname implibdir implibprefix implibsuffix implibextension ".mpi
true if a matching directory is found; false is there is no such file system path, or if the path points to a file instead of a directory.
project "myproject" defines { "trace" } -- this will be applied to every configuration configuration "debug" defines { "debug" } -- this will only be applied to debug builds when values are supplied at multiple levels, list fields (like defines above) areconcatenated while single-value fields (like language) are overridden.
options is a list of deployment tools flags and options.
premake recognizes two types of arguments: actions and options .
define two include file search paths.
flags { "symbols", "extrawarnings", "fatalwarnings" } the framework function selects a .net framework version.
premake adds the ability to define solutions, projects,  and configurations, as well as functions useful for build configuration tasks.
it is small, weighing in at around 200k. it does not require any additional libraries or runtimes to be installed, and should build and run pretty much anywhere.
paths specifies a list of library search directories.
references is a list of library and project names.
a list of directories which match the specified pattern.
define a symbol for all versions of visual studio.
gcc users may need  to install thegcc multilib packages.
if you frequently target several different platforms, and want to switch between them without regenerating your project files, you can add them directly to your script.
usually you would like premake to generate project files for a particular toolset, in which caseaction is one of these toolset identifiers:vs2010 visual studio 2010 (or express)
so you can change the build order by rearranging the order of the projects in your script.
if you have a solution that builds on windows, and you want to a binary for the xbox 360, you would call: premake4 --platform=xbox360 vs2005 the files generated by this call will include the default win32 build normally present in visual studio solutions, plus a new set of configurations which target the xbox 360.
most toolsets require extra configuration to target multiple platforms.
premake's mercurial repository does not contain any project files.
the path.getname function returns the file name and extension, with any directory information removed.
for i, sln in ipairs(_solutions)
you can update these strings by using the embed action, which is  part of premake's own build script.
if you downloaded a  prebuilt binary package you can skip this page, which discusses how to build  the premake source code.
the tracker makes sure your request  gets the visibility and attention it deserves, with no chance of it slipping  through the cracks.
buildaction the buildaction function specifies how a file or set of files should  be treated during the compilation process.
if you find a problem in the documentation, leave a comment describing the problem on that page.
instead, usean existing copy of premake to generate the files for your particular toolset and environment.
as an example, if this command line was used to launch premake... $ premake4 vs2005 alpha beta ...then _args[1] will be set to "alpha" and _
$ hg pull -u $ premake4 embed see debug vs. release modes below for an explanation (and maybe  eventually i'll think of a better way to do this).
libdirs { os.findlib("x11") } configurations a configuration is a collection of flags and options to apply to a  build, including build flags, header file and library search directories, and  more.
"api",  description= "choose a particular 3d api for rendering", allowed = { { "opengl", "opengl" }, { "direct3d",  "direct3d (windows only)" }, { "software", "software  renderer" } } }
paths should be specified relative to the currently running script file.
once you have a working premake installed, embed the scripts by opening a  console or terminal to the source code directory and running the command premake4 embed now generate the project files with a command like: premake4 gmake # for gnu makefiles using gcc premake4 vs2008 # for a  visual studio 2008 solution use the --help option to see all of the available targets.
the project files generated by premake will maintain the order of the projects as they appear in your script.
lang is the language identifier.
libdirs { "../lua/libs", "../zlib" } you can also use wildcards to match multiple directories.
path is the full path for the image file, relative to the currently executing script file.
any values returned by the included script are passed through to the caller.
language ("lang") premake currently supports c, c++, and c#.
it may contain the following fields: command line arguments register a new action to install the software project.
any new script file you create must be listed in the manifest if you want it to run.
your questions will help me improve this documentation and premake itself and are very much appreciated.
newoption { trigger = "outdir", value = "path", description= "output directory for the compiled executable" } actions are defined in much the same way as options, and can be as simple as this: newaction { trigger = "install", description =
files { "*.c" } excludes { "a_file.c", "another_file.c" } excludes may also use wildcards.
sometimes you may want to exclude all the files in a particular directory, but aren't sure where that directory will fall in the source tree.
someone may have asked the same question before.
if a project includes multiple calls to includedirs the lists are concatenated, in the order in which they appear in the script.
i'll continue to use the original file names (like _example.lua) through this explanation.
project values take precedence over solution values, and will appear after the solution values in lists.
the directory portion of the path, with any file name removed.
unless you really know what you are doing, you should treat this object as read-only, and use the premake api to make any changes.
solution "mysolution" configurations { "debuglib", "releaselib", "debugdll", "releasedll" } project"myproject" configuration "*lib" kind "staticlib" configuration "*dll" kind "sharedlib" the language function sets the programming language used by a project.
by default, solution and project files are generated into the same directory as the script that defines them.
a solution contains projects, and defines the available configurations solution"myapplication" configurations { "debug", "release" } -- a project defines one build target project "myapplication" kind "consoleapp" language "c++" files{ "**.h", "**.cpp" } configuration "debug" defines { "debug" } flags { "symbols" } configuration"release" defines { "ndebug" } flags { "optimize" } the indentation in this sample is arbitrary, this is the way i happen to like it.
an important caveat: i don't target multiple platforms in my own day to day work.
premake is built on lua, so everything in the lua reference manual applies to a premake script.
you can add new test files in tests/premake4.lua.
premake will check the option  value at startup, and raise an error on invalid values.
© 2002-2010 jason perkins and the  premake project.
if any of the identifiers is not the current environment the settings will be ignored.
os.mkdir("path") path is the file system path to be created.
the path.getbasename function returns the base file portion of a path, with the directory and file extension removed.
prebuildcommands prelinkcommands configuration "windows" postbuildcommands { "copy default.config bin\\project.config" } configuration "not windows" postbuildcommands { "cp default.config bin/project.config" } the prebuildcommands function specifies shell commands to run before each build.
first, check the frequently asked questions.
p = os.pathsearch("fname", "path1", ...)
virtual paths, like files, may be set on the solution, project, and configuration level.
you can specify a different file name using the file argument, like  so: premake4 --file=myfilename.lua you can define your entire project in one script file if you want, or you  can split up the projects into their own files, or any other organization you  can dream up.
solution "mysolution" configurations { "debug", "release" } platforms { "native", "universal" } provide 32- and 64-bit specific build targets.
flags that are not supported by a particular platform or toolset are ignored.
if you are having a problem with premake, or need help with your project  scripts, you have some choices.
if a project includes multiple calls to libdirs the lists are concatenated, in the order in which they appear in the script.
os .matchdirs("src/test*") -- may also match partial names
use an option value in a configuration targetdir ( _options["outdir"] ) new command-line options are created using the newoption function, passing a table which fully describes the option.
build settings premake provides an ever-growing list of build settings that you can tweak;  the following table lists some of the most common configuration tasks with a  link to the corresponding function.
however, when people ask this question they are really asking how to link against a library project.
or maybe you just want an easy way to reconfigure your project for different situations or environments, pulling in different source code or libraries, switches and options.
files { "file_list" } if a project includes multiple calls to files the lists are concatenated, in the order in which they appear in the script.
i'll be glad to help you out.
if you get stuck, post a question over in the forums and i will do my best to help you out.
for instance, a list of source code files, or defined symbols, or build flags.
here is an example of a fairly typical premake script for a c++ executable.
the os.findlib function scans the well-known system locations looking for a library file.
premake knows which scripts to load and run by reading the file src/_manifest.lua.
configurations { "names" } a configuration encapsulates a collection of build settings, allowing the developer to easily switch between them.
each solution defines its own list of configurations.
configuration { "debug", "sharedlib or staticlib" } targetsuffix"_d" -- ...or... configuration { "debug", "*lib" } targetsuffix "_d" although support is currently quite limited (only buildaction works so far), you may also apply settings to a particular file or set of files.
framework "3.0" the iif function implements an immediate "if" clause, returning one of two possible values.
files without the leading underscore contain the actual implementation of the action.
to this, premake adds functions for defining solutions, projects, and configurations as well as support for common build configuration tasks.
visual studio and other ides provide  facilities to quickly switch between configurations; premake-generated  makefiles allow the configuration to be specified with a command-line parameter.
kind "sharedlib" you can also set different kinds for each configuration.
the excludes function removes files, added with the files function, from a project.
os.copyfile("source", "destination")
as shown above, just put the project name in the list of links for the dependent project.
once you have defined a list of platforms, you may use those identifiers to set upconfiguration filters and apply platform-specific settings.
working_dir the _working_dir global variable stores the current working  directory at the time premake was launched.
local p = os.pathsearch("mysystem.config", "./config:/usr/local/etc:/etc")
prelinkcommands postbuildcommands configuration "windows" prebuildcommands { "copy default.config bin\\project.config" } configuration "not windows" prebuildcommands { "cp default.config bin/project.config" }
**" } the resoptions function passes arguments directly to the resource compiler command line without translation.
configuration "x64" defines "is_64bit" --
the imageoptions function passes arguments directly to the image tool command line without translation.
uuid ("project_uuid") uuids are synonymous (for premake's purposes) with globally unique identifiers (guid).
you can also mix platforms with other configuration selectors configuration { "debug", "x64" } defines "is_64bit_debug" the postbuildcommands function specifies shell commands to run after build is finished.
if you try to pass  a list to these function you'll get an error.
the table.implode function merges an array of items into a single, formatted string.
options is a list of linker flags and options, specific to a particular linker.
running make with no options will build all targets using the default configuration.
this is just an overview of configuration filtering.
how do i get my cool new feature/bug fix included in premake?
it isn't rocket science, and you probably already have the gist of it from the example above, so feel free to skip around.
resincludedirs { "../includes/
vpaths { ["headers/*"] =
configuration "vs2005" defines { "visual_studio_2005" } wildcards can be used to match multiple terms.
files located in other directories should be specified relative to the script file.
target platforms are part of the solution, just like configurations: solution "mysolution" configurations { "debug", "release" } platforms { "native", "universal" } not all tools will support all of the possible targets (currently only visual studio supports the xbox 360 platform).
the file name and extension, with no directory information.
"**.txt" } a collection of how-to articles on extending and improving premake.
feel free to leave your ideas in  the comments.)
name is a unique name for the solution.
let me start with a bit of general information that you will need to know to begin scripting.
the path.iscfile function returns true if the specified path represents a c source code file, based on its file extension.
each solution contains one or more projects, which it turn contain the settings to generate a single binary target.
taking gcc as an example, premake'sx32 flag adds -m32 to the gcc command line, and thex64 flag adds -m64.
the string.endswith function returns true if the given string ends with the provided sequence.
targetname targetdir targetprefix targetsuffix targetextension ".zmf"
normally you would include the native platform, and list it first to make  it the default.
adding support for additional toolsets and languages is straightforward.
assuming that you have the proper development tools installed and your software is portable enough, you can now build an xbox 360 binary.
path sets match the format of the path environment variable: a colon-delimited list of paths.
true if a matching file is found; false is there is no such file system path, or if the path points to a directory instead of a file.
in the case of files you may also use the ** wildcard, which will recurse into subdirectories.
a table, containing the following key-value pairs:majorversion
these functions set up the project state and take care of error checking and the like.
your questions will help me improve these instructions.
you may also want to check out luaforge for a wide assortment of lua add-on modules.
if the existing flags are not sufficient, you can also pass tool-specific arguments directly to the compiler or linker usingbuildoptions and linkoptions.
pattern is the pattern to search for; it may use lua's pattern matching syntax.
these are intended for folks who want to add new actions or api functions to premake.
vpaths { ["group"] = "pattern(s)" } note that lua tables do not maintain any ordering between key-value pairs, so there is no precedence between the supplied rules.
pchheader pchheader "afxwin.h" pchsource "afxwin.cpp" platform support is a new, experimental feature which will be introduced inpremake 4.1.
the solution name, provided as a parameter to the function, is used as the file name of the generated solution file.
if you do not supply a config argument, release mode will be used.
for a comprehensive list of available settings and functions, see the  scripting reference page.
platforms { "native", "x32", "x64" }
premake provides a great deal of flexibility when it comes to configuring your build: you can apply settings across an entire solution, a project, or to a targeted combination of configuration and toolset.
it is usually paired with a  configuration filter to select a file set.
you can also refer to thereference section or the lua reference  manual for information on a particular function or variable.
true if the host system has a 64-bit processor, false otherwise.
true if the specified path is absolute, false otherwise.
commands is one or more shell commands.
thelanguage function is used to set this value.
i'll  see your comment and fix it up, and the in meantime others can benefit from  your input.
visual studio and other ides provide facilities to quickly switch between configurations; premake-generated makefiles allow the configuration to be specified with a command-line parameter.
kind is the project kind identifier, and must be one of: set the project to generate a console executable.
the one exception to the rule is  mac os x frameworks, where the file extension is required to identify it as  such.
q. is it possible to invoke external tools?
the inclusion of the lua scripts throws a wrench in things, and i certainly understand if you have questions.
if you  spot any problems, or think something is unclear, feel free to leave a comment.
so if you wanted your code to "just build" on windows or unix,  32- or 64-bit systems, and you also wanted to allow folks to cross-compile for  the xbox 360 or mac os x universal binaries, you could do: platforms { "native", "xbox360", "universal" }
it reads a description of a software project and  generates the files for one of several different toolsets.
pchsource "file" if no source file is set, the toolset default settings will be used.
the next release build will include the updated scripts.
for instance, if your project can be built as both as both static or shared libraries, you might use this instead: configurations { "debuglib", "debugdll", "releaselib", "releasedll" } some features of premake, such as selecting a configuration from the command line, are easier if you avoid spaces.
so if you wanted your code to "just build" on windows or unix, 32- or 64-bit systems, and you also wanted to allow folks to cross-compile for the xbox 360 or mac os x universal binaries, you could do: platforms { "native", "xbox360", "universal" }
the source code is hosted on bitbucket; file downloads are hosted onsourceforge.
note that the project name is used to specify the link; premake will automatically figure out the correct library file name and directory and create a project dependency.
below is my best take so far; feedback and suggestions for improvement are very much appreciated.
for example, if the script is located atmyproject/build and  the source files are atmyproject/src, the files should be specified as files { "../src/*.cpp" } paths should always use the forward slash / as a separator; premake  will translate to the appropriate platform-specific separator as needed.
if you get stuck, post a question over in the forums and i will do my  best to help you out.
local prj = project() you can retrieve the list of projects associated with a solution using the projects field on the solution object, which may then be iterated over.
the buildaction function specifies how a file or set of files should be treated during the compilation process.
includedirs { "../lua/include", "../zlib" }
i try to check them daily and respond personally to most posts.
premake is a small (around 200k) command line executable, delivered as a  single file.
supply the --platform option to premake, and then build using the corresponding configuration.
scripting reference this section describes the functions and variables available to premake  scripts.
true if haystack starts with needle.
_premake_command the _premake_command global variable stores the full path to  the premake executable.
theconfiguration function is used to apply settings to a particular build environment.
the platform is just another configuration axis, which you can mix and match with any other selectors.
configuration "**.png" buildaction "embed" the buildoptions function passes arguments directly to the compiler command line without translation.
when linking against another project in the same solution, specify the project name here, rather than the library name.
premake is built on lua, so everything in the lua reference manual applies  to a premake script.
premake.foo = { } function premake.foo.bar() -- do something useful end i have begun moving all of premake's internals into the premake namespace, but it is a work in progress.
thekind function is used to specify this value.
you can also use wildcards to match multiple directories.
files { "src/**.cpp" } the flags function specifies build flags to modify the compiling or linking process.
trueval is the value to return if the condition evaluates to true,falseval if the condition evaluates false.
local p = platforms()
kind ("kind") solutions, projects, and configurations.
the objdir function sets object and intermediate file directory for a project.
info = os.stat("path")
solution "mysolution" configurations { "debug",  "release" } location "build"   project  "myproject" location "build" the path provided for location should be specified relative to the  script file.
in that  case, use theexcludes function to mask out those few exceptions.
the syntax and behavior described here might change as we sort out the details.
gcc users may need to install thegcc multilib packages.
platform support is a new, experimental feature introduced in premake 4.1.
if os.is64bit() then print("this is a 64-bit system") else print ("this is not a 64-bit system") end the os.isdir function checks for the existence of directory.
each project specifies a kind which determines what kind of output  is generated, such as a console or windowed executable, or a shared or static  library.
please see the platforms section of the user guide for a lot more information on platforms and how they are used by premake.
files { "**.c" } excludes { "tests/*.c" } the files function adds files to a project.
the list of configurations must be specified before any projects are defined, and once a project has been defined the configuration list may no longer be changed.
path.join("leading", "trailing")
instead, project owners are encouraged toadd an install action to their premake scripts, which has the advantage of working with any toolset on any platform.
any settings that appear after this function in the script will be applied only in those environments that match all of the listed keywords.
"**.h" } any directory information explicitly provided in the pattern will be removed from the replacement.
location ("../build/" .. _action)
if you find a problem in  the documentation, leave a comment describing the problem on that page.
and it provides an easy upgrade  path as new versions of your favorite tools are released.
as an example, if this command line was  used to launch premake... $ premake4 vs2005 ...then _action will be set to "vs2005".
jump ahead to quick start to begin learning how to use  and develop with premake.
-- delete a file if the clean action is running if _action ==
to learn how to use premake for your own software projects see scripting with premake.
added in premake 4.4.
leave a notein  the forums (the preferred approach), join the mailing list, or contact me  directly.
in visual studio, this file can be overridden by a per-user configuration file (such asprojectname.vcproj.mydomain-myusername.user).
the os.copyfile function copies a file from one location to another.
files { "hello.cpp", "goodbye.cpp" } add all c++ files from the src/ directory to the project.
configuration "with-opengl" links { "opengldrv" }    configuration"not with-opengl" links { "direct3ddrv"  }
libname is name of the library to locate.
see the premake cookbook for more examples of common configuration tasks.
premake will recognize it as an  executable and create the build dependency, but skip the link dependency.
you add files—source code, resources, and so on—to your project using thefiles function.
so that's the name you want to give your project script files, generally.
or perhaps you are a cross-platform game developer struggling to keep projects, solutions, and makefiles in sync.
p = path.getdrive("path")
premake will check the option value at startup, and raise an error on invalid values.
so that's the name you want  to give your project script files, generally.
to this, premake adds functions for defining  solutions, projects, and configurations as well as support for common build  configuration tasks.
solution "mysolution" configurations { "debug", "release" } add additional configurations for a dynamic link library version.
the base name portion of the supplied path, with any directory and file extension removed.
once the files have been generated you can load the solution or workspace  into your ide and build as you normally would.
once added to your script, the option will appear in the help text, and you may use the trigger as a keyword in your configuration blocks.
solution "mysolution" configurations { "debug",  "release" }   configuration "debug" defines {  "my_symbol" } the same rules hold true at the project level.
how  do i get my cool new feature/bug fix included in premake?
specify debug and release configurations for a solution.
you can define build-wide settings at the solution level; these will apply to all of the projects contained by that solution.
if a solution with the given name already exists, it is made active and returned.
configuration { "linux", "gmake" } linkoptions { "`wx-config --libs`" } the links function specifies a list of libraries and projects to link against.
when built in debug mode, premake will read its lua scripts from the disk  at startup, enabling compile-less code/test iterations, and therefore faster  development.
you can use the /scripts command line argument, like so: premake4 /scripts=~/code/premake4/src gmake or set a premake_path environment variable: premake_path=~/code/premake4/src you need to specify the location of the premake src/ directory, the  one containing_premake_main.lua.
the solution object contains the following values.
you must create a solution  and list the available configurations before creating the first project.
targetsuffix ("suffix") solutions, projects, and configurations.
just leave off the list  of allowed values.
you can use the visual studioguidgen tool to create new uuids, orthis website, or run premake once to generate visual studio files and copy the assigned uuids.
the table.contains function determines if an array contains a particular value.
project  "myexecutableproject" -- ...project settings here... links {  "mylibraryproject" } finding libraries you can tell premake where to search for libraries with the libdirs  function.
implibsuffix ("suffix") solutions, projects, and configurations.
a significant portion of premake is written in lua.
os.getversion() introduced in premake 4.4, this function has not yet been implemented for all platforms.
path is the relative path to be converted.
ext is the new file extension, including the leading dot.
string.explode("str", "pattern")
its a common problem for open and  cross-platform projects: restrict yourself to a single, potentially sub-optimal  build tool--driving away potential contributors--or manually maintain two,  three, or more sets of build scripts.
postbuildcommands { "commands" } solutions, projects, and configurations.
p = os.findlib("libname")
os.isfile("path") path is the file system path to check.
id = os.uuid() none.
create a new solution named "mysolution".
finally, post any questions you might have over in the forums and i will be delighted (yes, delighted) to help you out.
there is a fairly comprehensive set of automated tests in the tests/ folder.
most builds will need only a single solution, but you are free to create more if needed.
solution "mysolution" configurations { "debug", "release" } project "myproject" the project name, like the solution name, is used as the file name for the generated project file so avoid special characters.
path is the filesystem path to file for which to retrieve information.
pchheader "file" if no header file is set, the toolset default settings will be used.
defines { "debug", "trace" } -- defines multiple values defines "ndebug" -- defines a single value
i created an example action, available in the source code packages at src/actions/example, to help you get started.
jump ahead to quick start to begin learning how to use and develop with premake.
the indentation is for readability and is optional.
the matching pattern, if found, or nil if there were no matches.
a list of key/value pairs, specified with lua's standard syntax, which map file patterns to the group in which they should appear.
add your new files (and any others you create later) to the script manifest atsrc/_manifest.lua.
for instance, you may want to build an executable to use in the prebuild step for another project.
for more information, see the description of the links function.
= {"**.c", "**.cpp"}, ["docs"] =
an important caveat: i don't target multiple platforms in my own  day to day work.
see theplatforms function documentation for a full list of supported platforms.
true if successful, otherwise nil and an error message.
args the _args global variable stores any arguments to the current  action.
project "myexecutable" kind "consoleapp" links { "mylibrary" } premake will automatically figure out the library file name and directory and create a dependency between the two projects to ensure a proper build order.
creating new actions actions are defined in much the same way as options, and can be as simple  as this: newaction { trigger = "install", description =
using configurations premake provides a great deal of flexibility when it comes to configuring  your build: you can apply settings across an entire solution, a project, or to  a targeted combination of configuration and toolset.
the value is not case sensitive.
the major version number local ver = os.getversion() print(string.format(" %d.%d.%d (%s)" , ver.majorversion, ver.minorversion, ver.revision, ver.description)) --
premake will generate a build script with the right instructions for a 64-bit  or an xbox build, but that build will only succeed if the corresponding tools  and libraries have been installed on the developer machine.
the os.is64bit function determines if the host is using a 64-bit processor.
the os.matchdirs function performs a wildcard match to locate one or more directories.
you could place a bit of code like this anywhere in your script.
skip ahead to the next section to learn about the  important differences between the build configurations.
just about every ide uses the term "project" for this.
or perhaps you are a cross-platform game developer struggling to keep projects,  solutions, and makefiles in sync.
an action indicates what premake should do on any given run.
string.startswith("haystack", "needle") haystack is the string to check.
if you wish to call a file other than premake4.lua, use the dofile function instead.
prebuildcommands postbuildcommands configuration "windows" prelinkcommands { "copy default.config bin\\project.config" } configuration "not windows" prelinkcommands { "cp default.config bin/project.config" }
suffix is the new filename suffix.
the newaction function registers a new command-line action argument.
string.endswith("haystack", "needle")
configuration "windows" links { "user32", "gdi32" } configuration "linux" links { "m" ,"png" } configuration "macosx" -- os x frameworks need the extension to be handled properly links { "cocoa.framework", "png" }
if your premake script is in c:\code\myproject then the generated files will also be in c:\code\myproject.
by default, the project will use the system's normal naming conventions: .exe
-- runs "src/myapplication/premake4.lua" include "src/myapplication" -- runs "src/mylibrary/premake4.lua" include "src/mylibrary"
spaces are allowed, but may make using certain premake features, such as a command-line configuration selection, more difficult.
the os.getcwd function gets the current working directory.
project values take precedence over solution values, and will  appear after the solution values in lists.
configuration { "xbox360" } defines "is_xbox360_build" -- this will only get applied when user chooses the xbox 360 build
excludes { "file_list" } if a project includes multiple calls to excludes the lists are concatenated.
create a debug build of premake and then, in this tests directory, run the command: ../bin/debug/premake4 test
the path.getrelative function computes a relative path from one directory to another.
file is the name of the header file, as it is specified in your source file#include statements.
they know their project better than i will, and may have seen the same  problem before.
in the  world of make, you can think of projects as a makefile for one particular  library or executable; a solution is a meta-makefile that calls each project as  needed.
you can change this behavior by adding the  winmain build flag to your package, like so: flags { "winmain" } q.
command line arguments premake provides the ability to define and handle new command-line  arguments from within your project script using thenewaction and newoption  functions.
flags_list is a list of string flag names; see below for a list of valid flags.
each project also specifies which programming language it uses, such as c++ or c#.
configuration "opengl" links { "opengldrv" } configuration"direct3d" links { "direct3ddrv" } configuration"software" links { "softwaredrv" }
define two new symbols in the current project.
and it provides an easy upgrade path as new versions of your favorite tools are released.
patterm is the file system path to search.
include "directory" this is equivalent to: dofile "directory/premake4.lua" this allows you to specify each project in its own premake4.lua file, and then easily include them into a solution, or multiple solutions.
local prjs = solution().projects for i, prj in ipairs(prjs) do print( prj.name) end each project is represented in lua as a table of key-value pairs.
it is currently being tested and used on windows, mac os  x, linux, and other posix environments.
path is the file system path to the directory where the compiled target file should be stored.
starting with premake 4.0 i am following the visual studio naming conventions for build components.
and of course, you can specify more than one rule at a time.
links { _options["gfxapi"] .. "drv" } in this example, you would also want to provide a default behavior for the  case where no option is specified.
vpaths { ["headers"] = {
configuration "*.png" buildaction "embed"
imageoptions { "options" } if a project includes multiple calls to imageoptions the lists are concatenated, in the order in which they appear in the script.
(single dot) current directory is returned.
theconfiguration function  is used to apply settings to a particular build environment.
configuration { "xbox360" } defines "is_xbox360_build" -- this will only get applied when user chooses the xbox 360
there are two ways: re-order the projects in the script, and create link dependencies.
how do i build a universal/64-bit/xbox binary?
deployment options are currently only supported for xbox 360 targets.
it then uses mytool as part of its build process.
solution "mysolution" location "../build
the function returns the active project object; see the project object below for more information on the structure of this object.
theclean action causes all generated files to be deleted.
i am relying on those of you that do, and the community at large, to help me shape this feature.
links { "cocoa.framework" } to link to a sibling project (a project in the same solution) use the project name.
for instance, the dotnet option is used to change which .net compiler set is used in the  generated files.
the syntax and behavior described here might change along the way.
local cfgs = configurations() the debugargs function specifies a list of arguments to pass to the application when run under the debugger.
path is the directory where the object and intermediate files should be stored, specified relative to the currently executing script file.
the path.getdirectory function returns the directory portion of a path, with any file name removed.
it may contain the following fields: command line arguments register a new option to select a rendering api for a 3d application.
solution "mysolution" configurations { "debug", "release" } configuration "debug" defines { "my_symbol" } the same rules hold true at the project level.
if no platform is specified to the filter, the  subsequent settings will apply to all platforms.
links { _options["gfxapi"] .. "drv" } in this example, you would also want to provide a default behavior for the case where no option is specified.
targetname targetdir targetextension targetsuffix targetprefix "plugin" the prefix may also be set to an empty string for no prefix.
path.isabsolute("path")
newaction (description) description is a table describing the new action.
these functions set up the project state and  take care of error checking and the like.
newaction { trigger = "install", description =
the drive letter portion of the path, if one is specified.
there are two ways: re-order the projects in the script, and create link  dependencies.
args is a lua list of arguments to provide to the executable while debugging.
the function returns the current list of target platforms for the active solution.
this is not supported by xcode.
it serves as a simple flag, and does not take any value.
note that when working against the mercurial sources it is a good idea to refresh the embedded scripts after each update.
if you try to pass a list to these function you'll get an error.
one more disclaimer: i think this page is confusing.
the easiest way to target a particular platform is to supply the --platform argument to premake.
solutions, projects, configurations options is a list of resource compiler flags and options, specific to a particular compiler.
place all header files into a virtual path called "headers".
or you could be more clever.
an operating system identifier, one of bsd, linux, macosx , solaris, or windows.
for more information on lua programming, see the lua website or programming  in lua.
for more information, seecommand line  arguments.
at the solution level, specify your list of possible configurations by calling theconfigurations function and passing it a list of names.
these platforms can be quickly switched between from within your ide, or with a command-line parameter on the generated makefile.
before is a string to be inserted before each item.after is a string to be inserted after each item.between is a string to be inserted between items.
the current project uuid, or nil if no uuid has been set.
using the same example as above, this rule will appear in the ide as headers/src/lua/lua.h.
thetargetextension function allows you to change this default.
this rule will appear in the ide as headers/lua/lua.h.
os.is64bit() introduced in premake 4.4.
your users are asking for a visual studio 2008 solution, but you don't have visual studio!
if you are having a problem with premake, or need help with your project scripts, you have some choices.
files and file names premake will look for a file named premake4.lua by default, much like make looks for a file named makefile.
instead, project owners are encouraged toadd an install action to their  premake scripts, which has the advantage of working with any toolset on any  platform.
the following sections of this guide will walk you through all of the  features of premake in a somewhat logical fashion.
not all languages are supported by all of the generators; for instance, sharpdevelop does not (currently) support c or c++ development, and code::blocks does not support the .net languages (c#, managed c++).
if you've found a bug in the software, or if you want to request a new  feature please visit thepremake trackers on sourceforge.
using premake the simplest premake command is: premake4 action
solution "mysolution" configurations { "debug", "release" } defines { "my_symbol" } or, using the configuration function, you can limit it to a particular configuration.
it should take the form "01234567-abcd-abcd-abcd-0123456789ab" (see the examples below for some real uuid values).
in the generated makefiles, platforms and build configurations are paired  up.
the official premake documentation.
if not _options["gfxapi"] then _options["gfxapi"] = "opengl" end
configuration "debug" debugargs { "--append", "somefile.txt" } the debugdir function sets the working directory for the integrated debugger.
return { -- core files "base/os.lua", "base/path.lua", "...and so on...", -- clean action "actions/clean/_clean.lua", -- your new action goes here "actions/example/_example.lua", "actions/example/example_solution.lua", "actions/example/example_project.lua", } order matters a little here: _example.lua defines the namespace for the action and must appear first.
you may also want to check out luaforge for a wide assortment of lua add-on  modules.
premake provides the ability to define and handle new command-line arguments from within your project script using thenewaction and newoption functions.
platforms { "identifiers" }
action the _action global variable stores the name of the action to  be performed on this execution run.
os.matchdirs("pattern") patterm is the file system path to search.
provide a generic build that will work anywhere, as well as a mac os x universal build.
"force  the use of opengl for rendering, regardless of platform" } note the commas after each key-value pair; this is required lua syntax for  a table.
thetargetdir function allows you to change this location.
so these two statements are functionally identical: solution("mysolution") solution "mysolution" i find the latter form a bit more readable.
in addition to 32- and 64-bit builds, premake also supports mac os x universal binaries, the playstation 3, and the xbox 360.
"install the software", execute = function () -- copy files, etc.
keywords are not case-sensitive.
the string.explode function returns an array of strings, each of which is a substring ofs formed by splitting on boundaries formed by pattern.
files { "src/*.cpp" } add all c++ files from the src/ directory, and any subdirectories.
ides like visual studio provide their own mechanism for switching build configurations.
not all platforms are supported on all systems, unsupported platforms will be silently ignored.
if you just want to script your projects, have a look atscripting with premake instead.
if you are using makefiles (as opposed to an ide), you can choose which configuration to build with theconfig argument: make # build in release mode, both versions make config=debug # build in debug mode, when generated with premake 4.x make config=
platforms { "x32", "x64" } like any other configuration-specific value, platform-specific settings are set withconfiguration filters.
the best way is to create a patch (see subversion'sdiff command) against the subversion repository, or if that's not possible, the most recent source code release.
the master list of built-in scripts.
configuration { "debug" } defines "_debug" -- this  symbol will appear in settings for all platforms if a specific platform identifier is listed, the settings will be applied  only when that platform is specifically selected by the user.
resincludedirs { "paths" } if a project includes multiple calls to resincludedirs the lists are concatenated, in the order in which they appear in the script.
project "myproject" configuration "debug" targetdir"bin/debug" configuration "release" targetdir"bin/release" the targetextension function specifies the file extension for the compiled binary target.
p = path.getabsolute("path")
the key is the option  identifier ("dotnet"), which references the command line value  ("mono") or an empty string for valueless options.
once you have a working premake installed, embed the scripts by opening a console or terminal to the source code directory and running the command premake4 embed now generate the project files with a command like: premake4 gmake # for gnu makefiles using gcc premake4 vs2008 # for a visual studio 2008 solution use the --help option to see all of the available targets.
the os.get function identifies the currently targeted operating system.
targetextension ("ext")
vpaths { ["headers/*"] = "src/**.h" } you can also use virtual paths to remove extra directories from the ide.
it does need to actually exist on the file system.
matches = os.matchfiles("src/*.c") -- non-recursive match matches= os.matchfiles("src/**.c") -- recursive match
solution "mysolution" configurations { "debug",  "release" }   defines { "my_symbol" } or, using the configuration function, you can limit it to a particular  configuration.
in addition to these project generation capabilities, premake also provides a completelua scripting environment, enabling the automation of complex configuration tasks, such as setting up new source tree checkouts or creating deployment packages.
some targets require extra configuration of the build tools on the client machine in order to support cross-compilation.
these settings include the list of source code files, the programming language used by those files, compiler flags, include directories, and which libraries to link against.
you can also refer to thereference section or the lua reference manual for information on a particular function or variable.
a new absolute path, calculated from the current working directory.
faqs here are answers to some of the most frequently asked questions about  premake, taken fromthe forums and the mailing list.
that is, you can't write a rule that rewrites the results of an earlier rule, since there is no guarantee in which order the rules will run.
add two files to the current project.
theimplibprefix function allows you to change this default.
solutions and projects starting with premake 4.0 i am following the visual studio naming  conventions for build components.
a quick introduction for people who arrived here directly: premake is a  build configuration tool.
platforms platform support is a new, experimental feature introduced in premake 4.1.
solution "mysolution" you can retrieve the currently active solution object by calling solution with no parameters.
it is currently being tested and used on windows, mac os x, linux, and other posix environments.
linking to external libraries is done with the links function.
i  tried to truncate the platforms to something easy to type.
implibname implibdir implibprefix implibextension -- add "-d" to debug versions of files configuration "debug" implibsuffix "-d" the include function looks for a file named premake4.lua in a specified directory, and includes it in the current script.
project "myexecutable" kind "consoleapp" links {  "mylibrary" } premake will automatically figure out the library file name and directory  and create a dependency between the two projects to ensure a proper build order.
if the makefile is executed without any arguments, the first build  configuration (in the example above,debug) will be used.
buildoptions { "options" } if a project includes multiple calls to buildoptions the lists are concatenated, in the order in which they appear in the script.
the _premake_version global variable stores the current premake version, i.e. "4.2".
supply the --platform option to premake, and then build using the  corresponding configuration.
solution create a new project named "myproject".
the function returns the current configuration object; see the configuration block below for more information on the structure of this object.
if a wildcard matches more files than you would like, you may filter the list using theexcludes function.
solution "mysolution" configurations { "debug", "release" } platforms { "x32", "x64" } you can retrieve the current list of platforms by calling the function with no parameters.
it is usually paired with a configuration filter to select a file set.
projects contain all of the settings necessary to build a single binary target, and are synonymous with a visual studio project.
solution "mysolution" configurations { "debug", "release" }
see the examples below for more information.
any directory information is removed, so a path such assrc/lua/lua.h will appear in the ide asheaders/lua.h.
result = iif(condition, trueval, falseval)
p = path.getrelative("src", "dest") src is the originating directory, dest is the target directory.
only one action may be specified at a time (this is different than premake 3.x).
end each solution is represented in lua as a table of key-value pairs.
for more details,  including a list of the available filter keywords, see the documentation for the configuration function.
it reads a description of a software project and generates the files for one of several different toolsets.
unlike configurations, platforms are optional.
its a common problem for open and cross-platform projects: restrict yourself to a single, potentially sub-optimal build tool--driving away potential contributors--or manually maintain two, three, or more sets of build scripts.
printf("format", ...)
or, if you're in a posix environment, run the ./test shell script.
premake is a "plain old c" application, distributed as a single  executable file.
in addition to the cross-compiling platform targets listed above, there is a special target callednative which preserves the default compiler behavior.
the output of the command.
in this case, premake will generate a build dependency (the linked project will build first), but not an actual link.
you can update these strings by using the embed action, which is part of premake's own build script.
this user guide reflects the current state of the software fairly closely,  but may lag in places, or get a little ahead of the official releases in  others.
the inclusion of the lua scripts throws a wrench in things, and i certainly  understand if you have questions.
this user guide reflects the current state of the software fairly closely, but may lag in places, or get a little ahead of the official releases in others.
defines { "callspec=__dllexport" } the deploymentoptions function passes arguments directly to the deployment tool command line without translation.
string.endswith("str", "pattern", plain) str is the string to be searched.
values at the same level are evaluated in the order in which they are encountered in the script.
imageoptions the implibdir function specifies the import library output directory.
it is equivalent to this lua code: print(string.format(format, unpack(arg))
oldbase is the original base directory, from withpath is relative.
you can check for the existence of an install action by viewing the  help (runpremake4 --help in the project directory).
" if you plan to build with multiple tools from the same source tree you might want to split up the project files by toolset.
thetargetprefix function allows you to change this default.
it is a good idea to  run a quick search first to make sure your issue hasn't already been reported.
imagepath ("path") this value is currently only used by the xbox 360.
"**.h", "**.hxx", "**.hpp" } } it is also possible to include the file's path in the virtual group.
the next example shows an option with a fixed set of allowed values.
premake will synthesize the correct format based on the target platform automatically.
for instance, if your  project can be built as both as both static or shared libraries, you might use  this instead: configurations { "debuglib", "debugdll",  "releaselib", "releasedll" } some features of premake, such as selecting a configuration from the  command line, are easier if you avoid spaces.
by default, the generated project files will place their compiled output in the same directory as the script.
**" } the kind function sets the kind of binary object being created by the project, such as a console or windowed application, or a shared or static library.
options is a list of image tools flags and options.
the _options global variable lists the current set of command line  options and their values, if any.
if you don't have premake already, you can download it now.
uuid "be2461b7-236f-4278-81d3-f0d476f9a4c0" the vpaths function places files into groups or "virtual paths", rather than the default behavior of mirroring the filesystem in ide-based projects.
the tracker makes sure your request gets the visibility and attention it deserves, with no chance of it slipping through the cracks.
specifying configurations at the solution level, specify your list of possible configurations by  calling theconfigurations function and passing it a list of names.
the path.isresourcefile function returns true if the specified path represents a windows resource file, based on its file extension.
building the source code premake can be built in either "release" (the default) or  "debug" modes.
you can define build-wide settings at the solution level;  these will apply to all of the projects contained by that solution.
if you think something should be possible and you can't figure out how to do it, feel free topost a question in the forums and someone will help you out.
leave a notein the forums (the preferred approach), join the mailing list, or contact me directly.
the primary purpose of a solution is to act as a container for projects.
in a solution with two projects, link the library into the executable.
if the path does not include any directory information, the "."
the path to the directory which contains the file, if found.
how do i build a  universal/64-bit/xbox binary?
cwd = os.getcwd() none.
as shown above, just put the project name in  the list of links for the dependent project.
the function returns the active solution object; see the solution object below for more information on the structure of this object.
debugdir "path" note that this settings is not implemented for xcode 3, which requires a per-user configuration file in order to make it work.
thevalue field appears in the help text, and is intended to give the user a clue about the type of value that is expected.
os.outputof("command") command is a shell command to run.
as a last example of options, you may want to specify an option that accepts an unconstrained value, such as an output path.
in the generated makefiles, platforms and build configurations are paired up.
path.rebase("path", "oldbase", "newbase") path is the relative path to conver.
the best way is to create a patch (see  subversion'sdiff command) against the subversion repository, or if  that's not possible, the most recent source code release.
for more details, including a list of the available filter keywords, see the documentation for the configuration function.
file_list specifies one or more file patterns, separated by commas.
premake is built on lua, a powerful, fast, light-weight scripting language.
the most common configuration set, which is usually provided by default by most ides, is "debug" and "release".
creating new options new command-line options are created using the newoption function, passing  a table which fully describes the option.
a list of files which match the specified pattern.
see theplatforms  function documentation for a full list of supported platforms.
it is specified relative to the currently executing script file.
language "c++" set the project language to c# language "c#" the libdirs function specifies the library search paths.
the solution name will be used as the file name of the generated solution file.
usually you would like premake to generate project files for a particular  toolset, in which caseaction is one of these toolset identifiers: vs2010 visual studio 2010 (or express) vs2008 visual studio 2008 (or  express) vs2005 visual studio 2005 (or express), sharpdevelop, or  monodevelop vs2003 visual studio 2003 gmake gnu make (including cygwin and mingw) xcode3 apple xcode 3 you can see a complete list of actions and other options by typing: premake4 --help
© 2002-2010 jason perkins and the premake project.
theimplibdir function allows you to change this location.
buildaction ("action") build actions are currently only supported for .net projects, and not for c or c++.
deploymentoptions { "options" } if a project includes multiple calls to deploymentoptions the lists are concatenated, in the order in which they appear in the script.
by default, the system naming convention will be used: no prefix on windows, a prefix of "lib" (as inlibmyproject.a) on other systems.
sometimes you want most, but not all, of the files in a directory.
the os.pathsearch function searches a collection of paths for a particular file.
as before, this new option will be integrated into the help text, along with a description of each of the allowed values.
the same goes with a single list argument: defines({"debug", "trace"}) defines {"debug" ,"trace"} if you want to use a variable as an argument, or the result of a calculation, then you must use the parenthesis: local lang =
a relative path from src to dest.
if you only want to set a single value, you can leave off the brackets if you like.
true if the path matches a well-known windows resource file extension,false otherwise.
solution "mysolution" configuration { "debug", "release" } project "myproject" you can retrieve the currently active project object by calling project with no parameters.
they know their project better than i will, and may have seen the same problem before.
a quick introduction for people who arrived here directly: premake is a build configuration tool.
using theuuid function, you can assign a fixed uuid to each project which never changes, removing the randomness from the generated projects.
p = path.getbasename("path")
for example, if the script is located atmyproject/build and the source files are atmyproject/src, the files should be specified as files { "../src/*.cpp" } paths should always use the forward slash / as a separator; premake will translate to the appropriate platform-specific separator as needed.
define a new symbol which applies only to debug builds; assumes a configuration named "debug" was defined as part of the solution.
lua allows the creation of namespaces (of a sort) by putting your functions into a table.
if you downloaded one of the official source code release packages, the  project files have already been generated for you, and may be found in the build/ directory.
like  the example above, it is intended to allow the user to specify a 3d api.
a project lists the settings and source files needed to build one binary target.
the  wildcard* will match files in one directory; the wildcard ** will  match files in one directory and also recurse down into any subdirectories.
projects are defined using the project function.
once the files have been generated you can load the solution or workspace into your ide and build as you normally would.
newbase is the new base directory, from where the resulting path should be relative.
for  instance, thevs2005 action indicates that visual studio 2005 project  files should be generated.
solution "mysolution" project "mylibraryproject" -- ...project settings here... project "myexecutableproject" -- ...project settings here... links { "mylibraryproject" } you can tell premake where to search for libraries with the libdirs function.
files { "**.c" } excludes { "**/win32specific/**" }
when calling a function with a single string constant for an argument, lua  allows you to drop the parenthesis that would normally appear around the  argument list.
this variable will be nil.
that's the simple version.
if no build action is specified for  a file a default action will be used, based on the file's extension.
using thefiles function.
this is an optional setting; if it is not provided the toolset's default behavior will be used.
premake adds the ability to define solutions, projects, and configurations, as well as functions useful for build configuration tasks.
here are answers to some of the most frequently asked questions about premake, taken fromthe forums and the mailing list.
premake scripts are really lua programs, so anything you can do in lua can also  be done in a premake script.
when  defining a list of values you need to surround them in curly brackets, lua's  syntax for a list.
configuration { "linux", "gmake" } resoptions { "`wx-config --cxxflags`", "-ansi", "-pedantic" } the solution function creates a new solution and makes it active.
do this only if your software requires knowledge of the underlying architecture at build time, otherwise include "native" to provide a generic build.
it saves the time that would otherwise be spent manually keeping several different toolsets in sync.
-- returns "mysolution/myproject" p = path.join( "mysolution", "myproject") -- returns "/usr/bin", because the trailing path is absolute p = path.join( "mysolution", "/usr/bin") -- tokens are assumed to be absolute; this returns "$(projectdir)" p = path.join( "mysolution", "$(projectdir)")
each project also specifies which programming language it uses, such as c++  or c#.
so avoid special characters; spaces  are okay.
targetname targetextension targetprefix this project separates its compiled output by configuration type.
the source code is available under thebsd license.
fname is the name of the file being searched.
if you are having trouble building or using premake,visit our  support page and i'll try to help you out.
the directory must contain apremake4.lua file, or an error will occur.
for those of you unfamiliar with visual studio i will try to provide to provide the synonyms used by other toolsets; if i miss any let me know
project "myproject" kind "consoleapp" language "c++" by default, premake will place generated solution and project files in the same directory as the script which defined them.
these string values may be delimited with single (') or double (") quotes.
for more information, seecommand line arguments.
path is the file system path to be split.
prebuildcommands { "commands" } solutions, projects, and configurations.
resdefines { "debug", "trace" } symbols may also assign values.
if you downloaded one of the official source code release packages, the project files have already been generated for you, and may be found in the build/ directory.
newoption { trigger = "with-opengl", description =
resdefines { "callspec=__dllexport" } the resincludedirs function specifies the include file search paths for the resource compiler.
for instance, this rule will cause the previous example to appear aslua/lua.h , removing the src part of the path from all files.
how do i control the build order of my projects?
on windows xp: "5.1.3 (windows xp)" --
if newsep is nil, the native path separator for the current environment will be used.
as a last example of options, you may want to specify an option that  accepts an unconstrained value, such as an output path.
post it to thepatch  tracker on sourceforge—i get notified via email, and it provides a good  place to discuss and track it.
for example, you can define a symbol across all configurations of all projects by setting it at the solution level, before any filters are enabled.
there are also functions that only accept a single value, such as solution  and project names, the project kind and language, and so on.
however, only project-level file lists are currently supported.
true if the supplied id matches the current operating system identifier, false otherwise.
resdefines { "symbols" } if a project includes multiple calls to resdefines the lists are concatenated, in the order in which they appear in the script.
specifying platforms the easiest way to target a particular platform is to supply the --platform argument to premake.
if you want to -- build a new script into premake, add it to this list.
if you modify any of the core lua  scripts (anything ending in.lua), you must also update these embedded  strings before your changes will appear in the release mode build.
monodevelop and sharpdevelop do not support search directories at all, using only the gac.
you are not limited to these two standard names.
the flag values arenot case-sensitive.
if not _options["gfxapi"] then _options["gfxapi"] =  "opengl" end
path is the path to the working directory, relative to the currently executing script file.
as you can see, theflags function provides most of the features, and is a good place to start if you aren't sure how to make something go.
configurations are specified using theconfigurations function; see the next  section for more information.
if there is no action (for instance, if the command was premake4 /help)
premake will deduce the correct library path and name based on the current platform and configuration.
paths specifies a list of include file search directories.
the platforms function specifies a set of target hardware platforms for a solution.
like the example above, it is intended to allow the user to specify a 3d api.
defines { "debug", "trace" } -- defines multiple  values defines "ndebug" -- defines a single value
solution "mysolution" configurations { "debug", "release" } location "build" project "myproject" location "build" the path provided for location should be specified relative to the script file.
these commands will be passed to the shell exactly as entered, including path separators and the like.
prelinkcommands { "commands" } solutions, projects, and configurations.
no generic build is provided, so one of these two platforms must always be used.
file patterns may contain the* wildcard to match against files in the current directory, or the** wildcard to perform a recursive match.
set an object directory for a project.
rather than repeating all of that here, i'll just let you go browse through the files and start plugging in the code for your own actions.
the _premake_version global variable stores the current  premake version, i.e. "4.2".
true if haystack ends with needle.
you can also use this method to create a build dependency between  non-libraries.
set the project language to c++.
premake will figure out the correct library to link against for the current configuration, and will also create a dependency between the projects to ensure a proper build order.
this section describes the functions and variables available to premake scripts.
solutions define a common set ofconfigurations and encapsulate one or more projects (see below).
use theinclude() function or lua's dofile() to link all  the files together.
using the example and script above, the generated files will be  placed inc:\code\myproject\build.
for windows executables, .so for linux shared libraries, and so on.
you can check for the existence of an install action by viewing the help (runpremake4 --help in the project directory).
files { "*.c" } excludes { "a_file.c",  "another_file.c" } excludes may also use wildcards.
(i can see where this topic might be a bit confusing for newcomers, and i welcome suggestions for improving this text.
the path.join function joins two path portions together into a single path.
in addition to the cross-compiling platform targets listed above, there is  a special target callednative which preserves the default compiler  behavior.
resoptions { "options" } if a project includes multiple calls to resoptions the lists are concatenated, in the order in which they appear in the script.
for release builds (the default) this has no impact, just build as normal and go.
framework ("version") this value currently is only applied to visual studio 2005 or later, and gnu makefiles using mono.
in release builds, premake uses a copy of the scripts embedded into static strings: seesrc/host/scripts.c.
using the generated makefiles running make with no options will build all targets using the  default configuration.
have you ever been stuck using an old version  of visual studio because it was too difficult to upgrade the entire team?
here is an option intended to force the use of opengl in a 3d application.
if you are having trouble using premake to generate build files for a particular project, your best bet is to contact the manager of the project first.
let me start with a bit of general information that you will need to know  to begin scripting.
the project files generated by premake will maintain the order of the  projects as they appear in your script.
use pkg-config style configuration when building on linux with gcc.
i personally like to use just one file for simple projects, and  one-file-per-project for more complex builds.
this uuid is essentially random and will change each time the project file is generated.
so you can change the build order by  rearranging the order of the projects in your script.
it allows you to generate project files for tools that  you do not own.
premake scripts are really lua programs, so anything you can do in lua can also be done in a premake script.
if you are using makefiles (as opposed to an ide), you  can choose which configuration to build with theconfig argument: make # build in release mode, both versions make config=debug # build in  debug mode, when generated with premake 4.x make config=
describe your c, c++, or c# software  project usinga simple, easy to read syntax and let premake generate the project  files for: microsoft visual studio 2002-2010, including the express editions gnu make, including cygwin and mingw apple xcode version 4.1 of premake added experimental support for cross-compiling,  targeting: 32- and 64-bit builds mac os x 32- and 64-bit universal binaries playstation 3 (visual studio and gnu make) xbox 360 (visual studio only) premake allows you to manage your project configuration in one place and  still support those pesky ide-addicted windows coders and/or cranky linux  command-line junkies.
on platforms where this has not been implemented, it will return zero for all version numbers, and the platform name as the description.
a project lists the settings and source files needed to build one binary  target.
objdir ("path") by default, object and intermediate files are stored in a directory named "obj" in the same directory as the project.
both may be specified as absolute or relative.
configuration "linux or macosx" defines { "linux_or_macosx" }
defines { "symbols" } if a project includes multiple calls to defines the lists are concatenated, in the order in which they appear in the script.
premake is a small (around 200k) command line executable, delivered as a single file.
the_action global variable contains the current toolset identifier, as specified on the command line.
solution ("name") solutions are the top-level objects in a premake build script, and are synonymous with a visual studio solution.
you target a specific configuration using the config argument.
the native  platform, in contrast, does not addany flags to the command line and  lets gcc use its default behavior to target the current platform.
you can also use not to apply the settings to all environments where the identifier is not set.
the _action global variable stores the name of the action to be performed on this execution run.
linkoptions { "options" } if a project includes multiple calls to linkoptions the lists are concatenated, in the order in which they appear in the script.
destination is the path to the copy location.
specify source code files files, excludes for a comprehensive list of available settings and functions, see the scripting reference page.
every project belongs to a solution.
p = path.getname("path")
premake4 --platform=universal gmake make config=releaseuniv clean make  config=releaseuniv best practice is to clean before building a new platform.
"c++" language (lang) -- need the parenthesis here    location("build/" .. _action) -- and here too values and lists many of premake's functions accept a list of values as a parameter.
"debug" and "release" are the most common configurations, the former providing debugging information, and the latter providing optimizations.
thevalue field  appears in the help text, and is intended to give the user a clue about the  type of value that is expected.
set the uuid for a current project.
true if the path matches a well-known c file extension, false otherwise.
however, spaces are allowed in configuration names.
defines { "debug", "trace" } symbols may also assign values.
only one action may be specified at a time (this is different than  premake 3.x).
but it needs a little help finding the scripts.
if trailing is an absolute path, then the leading portion is ignored, and the absolute path is returned instead (see below for examples).
the command premake4 embed copies all of the scripts listed in the manifest into static c buffers in the filesrc/host/scripts.c, which then gets compiled into the final executable.
identifiers is a list of hardware platform identifiers, and may include any of the following.
the printf performs like its c counterpart, printing a formatted string.
solutions and projects.
the configuration function limits the subsequent build settings to a particular environment.
premake will recognize it as an executable and create the build dependency, but skip the link dependency.
project_uuid is the uuid for the current project.
the configuration functions acts as a filter.
if no framework is specified the toolset default is used.
on os x,: "10.6.6 (mac os x snow leopard)" the os.is function checks the current operating system identifier against a particular value.
next steps if you are having trouble building your project, start by contacting the  project manager.
if you frequently target several different platforms, and want to switch  between them without regenerating your project files, you can add them directly  to your script.
if all of these identifiers are present in the current runtime environment, then the settings following theconfiguration call will be applied.
newsep is the new path separator.
if you are having trouble building or using premake,visit our support page and i'll try to help you out.
the leading underscore on_example.lua is optional; it is a convention i use to indicate which file contains the action description (more on that below).
by default, the generated project files will place the import library in the same directory as the compiled binary.
iif(os.is("windows"), "is windows", "is not windows")
premake automatically assigns a uuid to each project, which is used by the visual studio generators to identify the project within a solution.
a common configuration: enable debugging symbols in the debug configuration, and optimize the release configuration.
just leave off the list of allowed values.
"**.h" } you may also specify multiple file patterns using the table syntax.
includedirs { "paths" }
you define your software project by calling a sequence of functions, such as solution, project, and defines.
"api", description= "choose a particular 3d api for rendering", allowed = { { "opengl", "opengl" }, { "direct3d", "direct3d (windows only)" }, { "software", "software renderer" } } }
i tried to truncate the platforms to something easy to type.
implibname ("name") by default, the target name will be used as the import library file name.
for instance, thevs2005 action indicates that visual studio 2005 project files should be generated.
the targetdir function sets the destination directory for the compiled binary target.
the underscore sorts this file to the top of the list making it easy to locate.
if you spot any problems, or think something is unclear, feel free to leave a comment.
this is a potentially large area of development and it may take a few releases to get it just right.
this is also known as cross compiling.
the imagepath function sets the file name of the deployment image produced by the build.
this is a potentially large area of development and it may  take a few releases to get it just right.
for instance, you may want to build an executable to use in the  prebuild step for another project.
as an example, if this command line was used to launch premake... $ premake4 vs2005 alpha beta ...then _args[1] will be set to "alpha" and _args[2] to "beta".
just unpack the download and place the executable on your system  search path or anywhere else convenient.
when you have completed your changes and are ready to roll them out, note that you must runpremake4 embed and recompile in order to see your changes in the release build of premake.
for this reason, it is recommended that you putnative first in the list.
the formatted string.
for this  reason, it is recommended that you putnative first in the list.
i am relying on those of you that do, and the community at  large, to help me shape this feature.
newoption (description) description is a table describing the new option.
project "myproject"   defines { "trace" } --  this will be applied to every configuration   configuration  "debug" defines { "debug" } -- this will only be applied to  debug builds when values are supplied at multiple levels, list fields (like defines  above) areconcatenated while single-value fields (like language) are  overridden.
if no platform is specified to the filter, the subsequent settings will apply to all platforms.
if you defined a solution like this: platforms { "native", "x64", "universal" } there would be six possible configurations: debug, release, debug64, release64, debuguniv, and releaseuniv.
vpaths { [""] = "src" }
in that case, use theexcludes function to mask out those few exceptions.
building premake learn how to compile premake from the source code.
needle is the starting sequence to check against.
i've loaded up the example files, particularly the action description, to help you make sense of them.
files { "*.c" } excludes { "a_file.c" } add an entire directory tree of c files, and then exclude one particular directory.
path.translate("path", "newsep") path is the file system path to translate.
if you want to use a variable as an argument, or the result of a  calculation, then you must use the parenthesis: local lang =
-- get the id for the host processor architecture local proc = os.outputof
configuration "vs*" defines { "visual_studio_2005" } add a suffix to the debug versions of libraries.
the next release build will include the updated  scripts.
libdirs { "libs", "../mylibs" } if you need to discover the location of a library, use the os.findlib function.
premake quick start
if there are no arguments this array will  be empty.
version is one of: use the .net 3.0 framework.
debug vs. release modes a significant portion of premake is written in lua.
see the  premake cookbook for more examples of common configuration tasks.
_script the _script global variable stores the full path of the  currently executing script.
projects the primary purpose of a solution is to act as a container for projects.
however, when people ask this question they are really asking how to link  against a library project.
substitute in your new names.
assuming that you have the proper development tools  installed and your software is portable enough, you can now build an xbox 360  binary.
unsupported platforms are  silently ignored; they simply will not appear in the generated build scripts.
(i can see where this topic might be a bit confusing for newcomers, and  i welcome suggestions for improving this text.
you can also use this method to create a build dependency between non-libraries.
needle is the ending sequence to check against.
the resdefines function specifies preprocessor symbols for the resource compiler.
to build a different configuration supply theconfig argument: make config=release most projects provide debug and release configurations; to see the  available targets and configurations, type: make help remove all generated binaries and intermediate files with: make clean premake generated makefiles do not support a make install step.
learn how to compile premake from the source code.
the translated path.
"c++" language (lang) -- need the parenthesis here location("build/" .. _action) -- and here too many of premake's functions accept a list of values as a parameter.
implibname implibextension implibprefix implibsuffix implibdir "../libraries" the implibextension function specifies the import library file extension.
if you only want to set a single value, you can leave off  the brackets if you like.
id is one of the operating system identifiers bsd, linux , macosx, solaris, or windows.
i keep all of the actions in src/actions, so create a new folder there with an appropriate name.
post it to thepatch tracker on sourceforge—i get notified via email, and it provides a good place to discuss and track it.
directory is the path to the included directory, relative to the currently executing script file.
copy the files from src/actions/example to your new folder and rename them appropriately.
you can check for an option using the  _options table, which contains a list of key-value pairs.
the _args global variable stores any arguments to the current action.
in this section, i'll show you how to create project scripts for premake.
the function returns the current list of configuration names for the active solution.
see the comments in that file for more information.
in this case, the native platform would not be included in the list.
see theconfiguration function for more details.
configuration "with-opengl" links { "opengldrv" } configuration"not with-opengl" links { "direct3ddrv" } the next example shows an option with a fixed set of allowed values.
configurations { "debug", "release", "debugdll", "releasedll" } you can retrieve the current list of configurations by calling the function with no parameters.
here  is an example of a fairly typical premake script for a c++ executable.
"clean" then -- do something end --
introduced in premake 4.4.
configuration { "debug", "x64" } defines  "use_64bit_debug_library" platforms and makefiles i am still working out how the target platforms should be represented in  premake-generated makefiles.
by using premake,  software developers can save time and support more tools and users.
premake4 --platform=universal gmake make config=releaseuniv clean make config=releaseuniv best practice is to clean before building a new platform.
the targetname function allows you to change this default.
this is followed by one or more path sets to be searched.
implibdir implibextension implibprefix implibsuffix implibname "mytarget" the implibprefix function specifies the import library file name prefix.
just unpack the download and place the executable on your system search path or anywhere else convenient.
unless you really know what you are doing, you should treat this object as read-only and use the premake api to make any changes.
if you just have a question you want answered, stop by the forums and start  a new discussion.
the os.rmdir function removes an existing directory as well as any files or subdirectories it contains.
see the lua reference manual  for details.
the syntax and behavior described  here might change along the way.
project functions and arguments you define your software project by calling a sequence of functions, such as solution, project, and defines.
the project object contains the following values.
see the lua reference manual for details.
in addition to 32- and 64-bit builds, premake also supports mac os x  universal binaries, the playstation 3, and the xbox 360.
sometimes you may want to exclude all the files in a particular directory,  but aren't sure where that directory will fall in the source tree.
because of the descriptive nature of the lua language, your build scripts will often look more like static configuration files than mini-programs.
the os.stat function retrieves information about a file.
add all c files in a directory, and then exclude a specific file.
in this  case, the native platform would not be included in the list.
see platforms for  more information.
configuration { "debug", "x64" } defines "use_64bit_debug_library" i am still working out how the target platforms should be represented in premake-generated makefiles.
set the destination directory for a solution.
"install  the software", execute = function () -- copy files, etc.
"install the software", execute = function () os.copyfile( "bin/debug/myprogram", "/usr/local/bin/myprogram") end } the newoption function registers a new command-line option argument.
**" } the linkoptions function passes arguments directly to the linker command line without translation.
premake will synthesize the correct format  based on the target platform automatically.
visual studio will change relative paths to absolute, making it difficult to share the generated project.
note that all expressions are evaluated before the condition is checked; the following expression can not be implemented with an immediate if because it may try to concatenate a string value.
leading is the beginning portion of the path; trailing is the ending portion.
solution "mysolution" configurations { "debug",  "release" }
buildaction ("action") build actions are currently only supported for .net projects, and not for c  or c++. applies to
c/c++ projects do not have this limitation.
it is small, weighing in at around 200k. it does not require  any additional libraries or runtimes to be installed, and should build and run  pretty much anywhere.
os.isdir("path") path is the file system path to check.
for  instance, a list of source code files, or defined symbols, or build flags.