we'll see in the future.
but it's a fact that it took me a long time to actually soak in the concept of generic programming to start taking advantage of it beyond simple function templating.
just like he did a couple of years ago when he decided it was time to go oop  and tackle all the incredible complexity of this new paradigm in c++.
i understand that they dropped them.
maybe they'll include them later.
i may be looking at concepts as easier simply because i understand better now what generic programming is under c++.
arrogance breeds bad code
but i don't see syntax or semantics complexity as such a big problem.
the feature set of direct3d is derived from the feature set of what  hardware provides.
the using keyword doesn't have as much grammatical cruft attached.
is there a single developer out there that knows the entire c# or java standard library?
so i'd give this 3rd point also some consideration.
the language is made  harder for them and it will take a long while until all the new concepts,  semantics and syntax get buried in their brain.
what we have now is a syntax that is somewhat easy  to teach, semantics somewhat easy to learn, but the coder is left alone trying  to understand template related errors messages.
one day, whe, he feels more comfortable with the language and decides to step into more complex areas of software development.
now they're discussing a "nothrow" annotation that is actually part of the type system.
c++ is a  multi-paradigm programming language.
can i be biased by the fact i was already  aware of generic programmingconcept and its advantages when i first  started reading about concepts?
the only thing i didn't like was the added complexity for _compiler-writers_
just another question: can you have mixed initalizer lists (std::initializer_list)?
so you want to do oop programming.
it was in the course of concept integration that they discovered that throwing move constructors (and moving is closely tied with rvalue refs) are completely unsafe - as with throwing destructors, if you have one, you simply cannot write exception-safe code.
especially if you then compare that tostroustrup article.
you mean it's included as a crutch to help ancient programmers limp along without them having to relearn too much.
it would be far better if they incorporated less stuff in less timeframes so new standards can be released more often.
many concepts are great: constexpr, rvalue references, extern templates, initializer lists, auto variable, decltype, the new for-loops, thread_local, regexes, suffixes - a nice "toy" that can be both very fun and useful the things i would reconsider: nullptr - it's not very elegant imo.
so, you want to do generic programming.
so, just typedef instead of using?
it does seem to me that, based on the article, there have been some significant missteps.
this has  also a lot to do with the natural characteristic of c++ of being a modular  programming language, which makes it easy to teach and learn.
and i liked  it because of that.
certainly adding new features to the language while keeping a close eye on complexity is a good goal.
the feature set of direct3d  is derived from the ... linkback posts 1,036 in general, direct3d is designed to be a 3d hardware  interface.
c++ is a multi-paradigm programming language.
i know the internals of only one compiler, but i can tell that while it would be possible to modify it to parse this, it would lead to some very ugly code in the parser.
but then again, switching between languages often isn't good either.
at any  rate, i'm just looking forward to the "auto" keyword.
certainly adding new features to the language while keeping a close eye  on complexity is a good goal.
but it was the interaction with concepts that pointed out that it's not safe, in general, to let rvalue references bind to lvalues.
i  understand that they dropped them.
it would be cheaper to just get a computer which is 25% faster.
anyway, i think concepts are a good idea, but not a great one.
and the possibility of misusing some concepts.
of course, whenever  there is a chance to simplify learning and usage one should take it.
i should not have used that as an example.
comparison of opengl and direct3d - wikipedia, the free encyclopedia you know what date is on this coin?
476 why is this thread turning into "opengl vs direct3d"?
like always using the new function definitions - looks more like pascal.
everything else  is just unnecessary fluff share 6,998 originally posted by brafil seems  like they have understood that they were making the language too complex.
at any rate, i'm just looking forward to the "auto" keyword.
expert programmers should not have to suffer because newbies might have a difficult time grasping all concepts.
this is a discussion on c++0x concepts fall within the general discussions forums, part of the community boards category; in general, direct3d is designed to be a 3d hardware interface.
but inm my defense i'll say that i'm in fact a newcmmer to generic  programming with no more than 1 year on my back and very little to show in  terms of actual work.
but hard to track bugs or hard to understand compiler reports is going to  strain the coder a lot more.
i'm not sure i understand this  argument very well.
and it really surprises me the whole debate around complexity vs. simplicity.
and i don't know who will implement all this i think you have a negative outlook.
joe coder will use concepts yes.
this is particularly damaging  to library developers who suffer the most.
i've played around with it (and i've implemented it) and i find it very intuitive.
よくきくがいい！わらわはてんさいだからね！ ^_^ i don't blame.
originally posted by brafil using instead of typedef.
the fact that the two apis have become so similar in functionality shows how well hardware is converging into user functionality[citation needed].
" - flon's law originally posted by brafil
but hard to track bugs or hard to understand compiler reports is going to strain the coder a lot more.
i may be looking at concepts as  easier simply because i understand better now what generic programming is under  c++.
and i don't know who will implement all this why is this thread turning into "opengl vs direct3d"?
but inm my defense i'll say that i'm in fact a newcmmer to generic programming with no more than 1 year on my back and very little to show in terms of actual work.
so i think it's a real shame they dropped concepts, but i am very positive about every other added feature.
it's a matter of study.
it leaves a foul taste in my mouth that politics and frivolous debate was the real issue.
the language is made harder for them and it will take a long while until all the new concepts, semantics and syntax get buried in their brain.
just a question: isn't it possible to add template typedefs?
no different  from so many other professional areas, from accounting to scientific fields.
i forgot how easy it  was to derail threads simply by mentioning those two words.
the new typedefs and the new function definition types enhances the parts that c++ specializes in.
in my view, this alone makes concepts a feature that reduces programming complexity already.
i  have very personal opinions on that matter which probably aren't very popular.
it leaves a foul taste  in my mouth that politics and frivolous debate was the real issue.
arcane: typedef void (*whyisthenamehere)(int); //
and in c++0x, also into classes, right?
it's my feeling it is the latter.
just like he did a couple of years ago when he decided it was time to go oop and tackle all the incredible complexity of this new paradigm in c++.
the alias declarations with 'using' can do that, yeah.
" - flon's law why is this thread turning into "opengl vs direct3d"?
yeah, but anyone should agree it's not easy to design all that.
what i mean is that usually we strive to learn what it is we want to do and a language provides the facilities to do so.
よくきくがいい！わらわはてんさいだからね！ ^_^ originally posted by brafil the things i would reconsider: nullptr - it's not very elegant imo.
the "c" way is one of the things i truly like about c/c++.
last edited by mario f.; 07-24-2009 at 10:42 am.
there are so many things that are added, and i doubt there will be a complete reference for c++0x -
now, templates are difficult to master.
hard to follow syntax and semantics, or weak error diagnostics?
in general, direct3d is designed to be a 3d hardware interface.
but there's three aspects to concepts that i think make the whole "will joe coder want to use concepts" the wrong debate.
of course, whenever there is a chance to simplify learning and usage one should take it.
code:class a { a(int, float, std::string); }; class b { b(std::initializer_list); }; a a{1, 1, "hello"}; b b{1, 2, 3, 4, 5, 6, 7, 8, 9}; all the buzzt!
and i don't know who will  implement all this share posts 3,242 why is this thread turning into "opengl vs  direct3d"?
this has far more repercussions than just  the admission we can use different tools for different jobs.
being that concepts was primarily aimed at library developers, does it really makes sense to ask "will joe coder use concepts"?
opengl, on the other hand, is designed to be a 3d rendering system that may be hardware accelerated.
initializer lists can be heterogenous, and the compiler will interpret the elements as constructor arguments and do overload resolution.
you can actually have a lot of fun with them.
in my view, this alone makes concepts a  feature that reduces programming complexity already.
last edited by brafil; 07-25-2009 at 02:18 am.
a hard to follow syntax is invariably going to be learned at  some point, the same goes for semantics.
c++ is supposed to be a general purpose programming language, combining multiple paradigms.
i was hoping the new standard would be finalized soon because the longer it takes the longer we have to wait for it to appear in compilers.
seems like they have understood that they  were making the language too complex.
quiet technologies... that make some noise.
this is particularly damaging to library developers who suffer the most.
it made a whole lot of sense to me.
it should also be  the understanding that some jobs simply aren't as easy as others.
i didn't really grasp that.
as i said, it's a grammar problem.
one day, whe, he feels more comfortable with the  language and decides to step into more complex areas of software development.
what do you think are the problems of nullptr?
originally posted by phantomotap "integration, especially with the library, was a very complex task, and uncovered many weaknesses, both of concepts themselves and of other language features, such as rvalue references.
it just seems, with concepts, c++ generic programming would be made easier to teach and learn.
you declare template typedefs the same way you declare namespace aliases.
"simple" is often harder or impossible to achieve... should the  alternative be no feature at all?
and i liked it because of that.
it's my feeling  it is the latter.
and you have to say... call it.
but this can't be the basis for deciding wether a feature is going to be implemented or not.
the fact that the two apis have  become so similar in functionality shows how well hardware is converging into  user functionality[citation needed].
the fact that this is at the core of the decision to abandon concepts  on c++0x, since even the implicit or explicit concept mapping discussion has  its roots on that question, is very disheartening to me.
opengl, on the other hand, is designed to be a 3d rendering  system that may be hardware accelerated.
template: template  using specialvector =
i'm not sure i understand this argument very well.
originally posted by brewbuck: reimplementing a large system in another language to get a 25% performance boost is nonsense.
it is in my view acceptable that generic programming is accepted as being even harder.
why is this thread turning into "opengl vs direct3d"?
how about that: code:template  typedef getter = const type &(*)(void); template  typedef setter = void (*)(const type &); getter isactive; setter setactive;so, just typedef instead of using?
finally, there's the admission  that conceptually c++ templates are irreprehensible, but the theoretic basis on  which they were implemented in c++ is weak.
the feature set of direct3d is derived from the feature set of what hardware provides.
the way typedef works, i think it would be very hard to make template typedefs that don't look absolutely atrocious.
templates are a very important part of c++!
joe coder  will use concepts yes.
i personally don't like the  new function definition types nor the new typedef possibilities.
should we remove them to make the language easier to learn?
but hey, here it is...
it is in my view acceptable  that generic programming is accepted as being even harder.
these two apis are fundamentally  designed under two separate modes of thought.
the reason we have 'using' instead of 'typedef' is, i think, mainly one of grammar.
however theconcept of concepts was  immediately understood.
it is no longer part of the standard for c, but it is nevertheless, included in the very latest pelles c versions.
it already takes a decade to figure out how to implement all this stuff since they meet so "often."
in c++ certain paradigms are definitely harder to grasp than others.
a hard to follow syntax is invariably going to be learned at some point, the same goes for semantics.
but i love static_assert and many others.
a feeling that herb sutter'srecent blog post makes even stronger.
can we tell exactly what adds more to complexity?
however, std::initializer_list can only represent homogenous initializer lists.
i have very personal opinions on that matter which probably aren't very popular.
"the internet treats censorship as damage and routes around it."
but i don't know a better way of doing it.
everything else is just unnecessary fluff originally posted by brafil seems like they have understood that they were making the language too complex.
comparison of opengl and direct3d -  wikipedia, the free encyclopedia share share on facebook twitter you know what date is on this coin? 1958.
" o_o please don't tell me "r-value references" were dropped too!?
so we should rather have called it c++1x.
the current ones for  "normal" c++ are thick enough.
it just seems, with concepts, c++ generic programming would  be made easier to teach and learn.
using instead of typedef.
"simple" is often harder or impossible to achieve... should the alternative be no feature at all?
it's in my opinion a mistake to oversimplify or to aim for simplicity above all else.
but the three aspects... 1.
no different from so many other professional areas, from accounting to scientific fields.
in general, the new syntax is much nicer than the arcane c syntax.
the current ones for "normal" c++ are thick enough.
for a newcommer going from procedural programming to oop is a big step.
it's been travelling twenty two years to get here.
seems like they have understood that they were making the language too complex.
one of concepts primary aim was  exactly to create the necessary groundwork that would help to considerably  improve current template diagnostics.
can i be biased by the fact i was already aware of generic programmingconcept and its advantages when i first started reading about concepts?
these two apis are fundamentally designed under two separate modes of thought.
what we have now is a syntax that is somewhat easy to teach, semantics somewhat easy to learn, but the coder is left alone trying to understand template related errors messages.
よくきくがいい！わらわはてんさいだからね！ ^_^ originally posted by elysia i kinda agree.
in c++  certain paradigms are definitely harder to grasp than others.
outside of your dos world, your header file is meaningless.
it's been travelling  twenty two years to get here.
it's in my  opinion a mistake to oversimplify or to aim for simplicity above all else.
there are so many things that are added,  and i doubt there will be a complete reference for c++0x -
but it's a fact that it took me a long time to actually  soak in the concept of generic programming to start taking advantage of it  beyond simple function templating.
this has far more repercussions than just the admission we can use different tools for different jobs.
one of concepts primary aim was exactly to create the necessary groundwork that would help to considerably improve current template diagnostics.
learn the generic part.
and it really  surprises me the whole debate around complexity vs. simplicity.
c++0x concepts fall c++0x concepts fall
fun: template  struct metafunction { using type = std::string; }; template <> struct metafunction { using type = std::vector; }; template  using stringtype = typename metafunction::type; stringtype this_is_a_std_string; stringtype this_is_a_char_vector;just another question: can you have mixed initalizer lists (std::initializer_list)?
but  i love static_assert and many others.
but the  three aspects... 1.
the fact that this is at the core of the decision to abandon concepts on c++0x, since even the implicit or explicit concept mapping discussion has its roots on that question, is very disheartening to me.
cornedbee "there is not now, nor has there ever been, nor will there ever be, any programming language in which it is the least bit difficult to write bad code.
for a newcommer  going from procedural programming to oop is a big step.
" - flon's law originally posted by brafil why is this thread turning into "opengl vs direct3d"?
i forgot how easy it was to derail threads simply by mentioning those two words.
c++ is already a complex language to learn and use .
however theconcept of concepts was immediately understood.
it should also be the understanding that some jobs simply aren't as easy as others.
code:using int = int; //
being that concepts was primarily aimed at library developers, does it  really makes sense to ask "will joe coder use concepts"?
as far as i know, using is only used for copying data into namespaces.
and it's either heads or tails.
i think that would be nice.
logical: using thisisgood = void (*)(int); //
but hey,  here it is... c++ is already a complex language to learn and use .
but there's three aspects to concepts that i  think make the whole "will joe coder want to use concepts" the wrong  debate.
finally, there's the admission that conceptually c++ templates are irreprehensible, but the theoretic basis on which they were implemented in c++ is weak.
this has also a lot to do with the natural characteristic of c++ of being a modular programming language, which makes it easy to teach and learn.
making it easier and more powerful, even.
this is a discussion on c++0x concepts fall within the general  discussions forums, part of the community boards category; in general,  direct3d is designed to be a 3d hardware interface.
the feature set of direct3d is derived from the ...
but the discussion was about concepts, right?
originally posted by salem
but this  can't be the basis for deciding wether a feature is going to be implemented or  not.
originally posted by adak io.h certainly is included in some modern compilers.
i personally don't like the new function definition types nor the new typedef possibilities.