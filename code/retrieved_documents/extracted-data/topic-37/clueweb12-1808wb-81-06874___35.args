theclean action causes all generated files to be deleted.
options can accept a value, such as--dotnet=mono or act as a flag, like--with-opengl.
ifplain is true, no pattern matching will be performed (faster).
os.chdir("path") path is the file system path to the new working directory.
if you have a solution that builds on windows, and you want to a binary for the xbox 360, you would call: premake4 --platform=xbox360 vs2005 the files generated by this call will include the default win32 build normally present in visual studio solutions, plus a new set of configurations which target the xbox 360.
when in doubt, feel free to post a questionover in the forums.
the os.isfile function checks for the existence of file.
in addition to these project generation capabilities, premake also provides a completelua scripting environment, enabling the automation of complex configuration tasks, such as setting up new source tree checkouts or creating deployment packages.
embedding the scripts in release builds, premake uses a copy of the scripts embedded into static strings: seesrc/host/scripts.c.
you can use the /scripts command line argument, like so: premake4 /scripts=~/code/premake4/src gmake or set a premake_path environment variable: premake_path=~/code/premake4/src you need to specify the location of the premake src/ directory, the one containing_premake_main.lua.
debugargs { "args" } note that this settings is not implemented for xcode 3, which requires a per-user configuration file in order to make it work.
if you don't need them, just don't call theplatforms function at all, in which case the toolset's default behavior will be used.
implibprefix "" the implibsuffix function specifies a file name suffix for the import library base file name.
premake will look for a file named premake4.lua by default, much like make looks for a file named makefile.
on windows, you may use a semicolon-delimited list if drive letters might be included.
premake also provides conventions for defining and handling command line options and actions, allowing you to build sophisticated configuration scripts.
path is the output directory for the library, relative to the currently executing script file.
kind "consoleapp" set the project to generate a shared library (dll).
imagine yourself the owner of an open source software project.
normally you would include the native platform, and list it first to make it the default.
"force the use of opengl for rendering, regardless of platform" } note the commas after each key-value pair; this is required lua syntax for a table.
user guide the official premake documentation.
the actual code to be executed when the action if fired should be placed in theexecute() function.
as you can see, theflags function provides most of the features, and is a good place to start if you aren't sure how to make something go.
premake also provides conventions for defining and handling command line options and actions, allowing you to build sophisticated configuration scripts.
so, by default, it will configure your windows applications to call the standardmain() entry point instead of the windows-specificwinmain().
if the makefile is executed without any arguments, the first build configuration (in the example above,debug) will be used.
i'll see your comment and fix it up, and the in meantime others can benefit from your input.
setting the location for a project works the same way.
if you are having trouble building your project, start by contacting the project manager.
for example, you can define a symbol across all configurations of all projects by setting it at the solution level, before any filters are enabled.
the wildcard* will match files in one directory; the wildcard ** will match files in one directory and also recurse down into any subdirectories.
the solution name, provided as a parameter to the function, is used as the file name of the generated solution file.
premake can be built in either "release" (the default) or "debug" modes.
if you haven't already, read the documentation.
to build a different configuration supply theconfig argument: make config=release most projects provide debug and release configurations; to see the available targets and configurations, type: make help remove all generated binaries and intermediate files with: make clean premake generated makefiles do not support a make install step.
because of the descriptive nature of the lua language, your build scripts will often look more like static configuration files than mini-programs.
in this case, the help text will appear like this: --gfxapi=api choose a particular 3d api for rendering; one of: opengl opengl direct3d direct3d (windows only) software software renderer
you can change the output location using the location function.
unlike the example above, you now use the value as a keyword in your configuration blocks.
as an example, if this command line was used to launch premake... $ premake4 vs2005 ...then _action will be set to "vs2005".
targetdir targetextension targetprefix targetsuffix targetname "mytarget" the targetprefix function specifies the file name prefix for the compiled binary target.
project "myproject" kind "consoleapp" language "c++" locations by default, premake will place generated solution and project files in the same directory as the script which defined them.
this is only used by visual studio.
premake tries hard to make all build tools on all platforms perform as similarly as possible.
name is the new base file name.
the source code is hosted on bitbucket; file downloads are hosted onsourceforge.
configuration "debug" defines { "_debug" } define a symbol only when targeting visual studio 2005.
the string.findlast function finds the last instance of a pattern within a string.
ides like visual studio provide their own mechanism for switching build configurations.
from within your script, you can identify the current action with the _action global variable, a string value.
in addition to configurations, you can also target multiple hardware platforms, such as a 32-bit build and a 64-bit build.
the tutorial below will show you how to use these example files to get started on your own actions.
local sln = solution() you can the global variable _solutions to list out all of the currently defined solutions.
describe your c, c++, or c# software project usinga simple, easy to read syntax and let premake generate the project files for: version 4.1 of premake added experimental support for cross-compiling, targeting: premake allows you to manage your project configuration in one place and still support those pesky ide-addicted windows coders and/or cranky linux command-line junkies.
when linking against system libraries, do not include any prefix or file extension.
the * will match against a single directory,** will recurse into subdirectories as well.
if you are having trouble using premake to generate build files for a particular project, your best bet is to contact the manager of the project first.
in general, it is better to include the full (relative) path to the assembly inlinks instead.
the platform is just another configuration axis, which you can mix and match with any other selectors.
the pchheader function sets the main header file for precompiled header support.
for instance, the dotnet option is used to change which .net compiler set is used in the generated files.
so, by default, it will configure your windows applications to call the standardmain() entry point instead of the windows-specificwinmain().
the project function creates a new project and makes it active.
this is a common mistake; i still make it myself every once in a while.
the path.iscppfile function returns true if the specified path represents a c++ source code file, based on its file extension.
targetname targetdir targetprefix targetextension -- add "-d" to debug versions of files configuration "debug" targetsuffix "-d" the uuid function sets the universally unique identifier (uuid) for a project.
it isn't rocket science, and you probably already have the gist of it from the example above, so feel free to skip around.
if no build action is specified for a file a default action will be used, based on the file's extension.
instead, usean existing copy of premake to generate the files for your particular toolset and environment.
target platforms are part of the solution, just like configurations: solution "mysolution" configurations { "debug", "release" } platforms { "native", "universal" } not all tools will support all of the possible targets (currently only visual studio supports the xbox 360 platform).
the actual code to be executed when the action if fired should be placed in theexecute() function.
if you get stuck, if something isn't clear, or you want to see a demonstration of something that isn't covered by the exampledrop a note in the forums and i'll try to help you out.
use theinclude() function or lua's dofile() to link all the files together.
or maybe you just want an easy way to reconfigure your project for different situations or environments, pulling in different source code or libraries, switches and options.
premake tries hard to make all build tools on all platforms perform as similarly as possible.
solution "mysolution" configurations { "debug", "release" } language "c++" project "myproject" kind "consoleapp" files "**.cpp" links { "mytool" } prebuildcommands { "mytool --dosomething" } project"mytool" kind "consoleapp" files "**.cpp" the location function sets the destination directory for a generated solution or project file.
the key is the option identifier ("dotnet"), which references the command line value ("mono") or an empty string for valueless options.
a windows executable project named "myproject" will produce a binary namedmyproject.exe.
so you could, for instance, put all header files in a group called "headers", no matter where they appeared in the source tree.
i try to check them daily and respond personally to most posts.
targetprefix ("prefix") by default, the system naming convention will be used: a "lib" prefix for posix libraries (as inlibmyproject.so), and no prefix elsewhere.
files { "hello.h", -- you can specify exact names "*.c", -- or use a wildcard... "**.cpp" -- ...and recurse into subdirectories } you can use wildcards in the file patterns to match a set of files.
in this case you want to put the libraryproject name, not the library file name, in the list of links for the dependent project.
you could place a bit of code like this anywhere in your script.
if you are storing the generated visual studio project files in a version control system, this will create a lot of unnecessary deltas.
the os.outputof function runs a shell command and returns the output.
options can accept a value, such as--dotnet=mono or act as a flag, like--with-opengl.
if you think something should be possible and you can't figure out how to do it, feel free topost a question in the forums and someone will help you out.
name is a unique name for the project.
the os.mkdir function creates a new directory.
pchsource pchheader "afxwin.h" pchsource "afxwin.cpp" the pchsource function sets the main source file for precompiled header support.
pattern is the separator pattern at which to split; it may use lua's pattern matching syntax.
using the example and script above, the generated files will be placed inc:\code\myproject\build.
thelocation function allows you to change this location.
it saves the time that would otherwise be spent manually keeping several different toolsets in sync.
you now have a solution/makefile/workspace that you can load and build.
the targetname function specifies the base file name for the compiled binary target.
this example will apply the symbol only for debug builds on mac os x. configuration { "debug", "macosx" } defines { "debug_macosx" } multiple terms must use lua's curly bracket list syntax.
skip ahead to the next section to learn about the important differences between the build configurations.
the project name will be used as the file name of the generated solution file.
at the top level of every build is a solution, acting as a container and meta-project (other tools use the termworkspace).
configuration "debug" debugdir "bin/debug" the defines function adds preprocessor or compiler symbols to a project.
by using premake, software developers can save time and support more tools and users.
project "myproject" objdir "objects" set object directories per configuration.
most builds will need only a single solution, but you are free to create more if needed.
a sample script premake is built on lua, a powerful, fast, light-weight scripting language.
so avoid special characters; spaces are okay.
platforms { "x32", "x64" } platform settings like any other configuration-specific value, platform-specific settings are set withconfiguration filters.
premake will use the appropriate naming conventions for the current platform.
the path.getextension function returns the file extension portion of a path.
as before, this new option will be integrated into the help text, along with a description of each of the allowed values.
targetname ("name") by default, the project name will be used as the file name of the compiled binary target.
files may be set on the solution, project, and configuration level.
once added to your script, the option will appear in the help text, and you may use the trigger as a keyword in your configuration blocks.
these platforms can be quickly switched between from within your ide, or with a command-line parameter on the generated makefile.
if you downloaded a prebuilt binary package you can skip this page, which discusses how to build the premake source code.
files { "hello.h", -- you can specify exact names "*.c", -- or use a wildcard... "**.cpp" -- ...and recurse into subdirectories } you can use wildcards in the file patterns to match a set of files.
you now have a solution/makefile/workspace that you can load and build.
in this example, myproject uses a build dependency to ensure that mytool gets built first.
at the top level of every build is a solution, acting as a container and meta-project (other tools use the termworkspace).
values at the same level are evaluated in the order in which they are encountered in the script.
retrieve version information for the host operating system.
configuration "debug" objdir "../obj_debug" configuration"release" objdir "../obj_release" the os.chdir function changes the current working directory.
removing this file (which is done by premake's clean action) will restore the default settings.
unsupported platforms are silently ignored; they simply will not appear in the generated build scripts.
the _premake_command global variable stores the full path to the premake executable.
this is how i can ship a single binary, rather than the whole source tree.
when calling a function with a single string constant for an argument, lua allows you to drop the parenthesis that would normally appear around the argument list.
image options are currently only supported for xbox 360 targets.
the prelinkcommands function specifies shell commands to run after the source files have been compiled, but before the link step.
if a project with the given name already exists, it is made active and returned.
if you have any questions, ask them over in the forums and i'll try to help you out.
from within your script, you can identify the current action with the _action global variable, a string value.
there are also functions that only accept a single value, such as solution and project names, the project kind and language, and so on.
source is the file system path to the file to be copied.
these scripts will run on any platform, ending batch/shell script duplication.
it is a good idea to run a quick search first to make sure your issue hasn't already been reported.
if you modify any of the core lua scripts (anything ending in.lua), you must also update these embedded strings before your changes will appear in the release mode build.
so if i have a library project called "mylibrary"... project "mylibrary" kind "sharedlib" ...i can link against it like this.
if you can't figure out how to make a patch, get it to me however you can.
implibextension ("ext") by default, the toolset static library file extension will be used (.lib with windows tools, .a
flags { "flag_list" } if a project includes multiple calls to flags the lists are concatenated, in the order in which they appear in the script.
the native platform, in contrast, does not addany flags to the command line and lets gcc use its default behavior to target the current platform.
the path.getdrive function returns the drive letter portion of a path, if present.
an action is what gets triggered when you run premake; the command premake4 vs2008 triggers the visual studio 2008 action, while premake4 clean triggers the clean action.
configuration { "debug" } defines "_debug" -- this symbol will appear in settings for all platforms if a specific platform identifier is listed, the settings will be applied only when that platform is specifically selected by the user.
solution "mysolution" configurations { "debug", "release" }   project "myproject" the project name, like the solution name, is used as the file name for the generated project file so avoid special characters.
note that when working against the mercurial sources it is a good idea to refresh the embedded scripts after each update.
the following sections of this guide will walk you through all of the features of premake in a somewhat logical fashion.
premake will generate a build script with the right instructions for a 64-bit or an xbox build, but that build will only succeed if the corresponding tools and libraries have been installed on the developer machine.
import libraries are generated for windows dll projects.
this will save you the trouble of embedding the scripts and recompiling with each change, and will greatly speed up development.
implibname implibdir implibextension implibsuffix implibprefix "plugin" the prefix may also be set to an empty string for no prefix.
libdirs { "paths" } library search directories are not well supported by the .net tools.
getting premake if you don't have premake already, you can download it now.
you can check for an option using the _options table, which contains a list of key-value pairs.
debug builds load the scripts dynamically at startup and so can skip this step.
i personally like to use just one file for simple projects, and one-file-per-project for more complex builds.
it allows you to generate project files for tools that you do not own.
this example writes out simple "solution" and "project" files, showing how to get out the project information using the premake apis.
the _working_dir global variable stores the current working directory at the time premake was launched.
these scripts will run on any platform, ending batch/shell script duplication.
this example sets the build action for all png image files.
enter premake premake is a build configuration tool.
unlike the example above, you now use the value as a keyword in your configuration blocks.
you can use the or modifier to match against multiple, specific terms.
when built in debug mode, premake will read its lua scripts from the disk at startup, enabling compile-less code/test iterations, and therefore faster development.
you can specify a different file name using the file argument, like so: premake4 --file=myfilename.lua you can define your entire project in one script file if you want, or you can split up the projects into their own files, or any other organization you can dream up.
configuration "not windows" defines { "not_windows" } finally, you can reset the configuration filter and remove all active keywords by passing the function an empty table.
the _script global variable stores the full path of the currently executing script.
however, spaces are allowed in configuration names.
premake will deduce the correct library path and name based on the current platform and configuration.
in this case you want to put the libraryproject name, not the library file name, in the list of links for the dependent project.
in addition to the terms listed above, you may use the * and ** wildcards to match more than one term or file.
in this case, the help text will appear like this: --gfxapi=api choose a particular 3d api for rendering; one of: opengl opengl direct3d direct3d (windows only) software software renderer
links { "references" } if a project includes multiple calls to links the lists are concatenated, in the order in which they appear in the script.
solution "mysolution" configurations { "debug", "release" } language "c++" project "myexecutable" kind "consoleapp" files "**.cpp" links{ "mylibrary" } project "mylibrary" kind "sharedlib" files "**.cpp" you may also create links between non-library projects.
configuration "**.png" buildaction "embed" if multiple keywords are specified, they will be treated as a logical and.
the path.rebase function takes a relative path and makes it relative to a different location.
if you don't need them, just don't call theplatforms function at all, in which case the toolset's default behavior will be used.
for release builds (the default) this has no impact, just build as normal and go.
the path.translate function converts the file separators in a path.
project "myproject" defines { "trace" } -- this will be applied to every configuration configuration "debug" defines { "debug" } -- this will only be applied to debug builds when values are supplied at multiple levels, list fields (like defines above) areconcatenated while single-value fields (like language) are overridden.
premake adds the ability to define solutions, projects, and configurations, as well as functions useful for build configuration tasks.
it is small, weighing in at around 200k. it does not require any additional libraries or runtimes to be installed, and should build and run pretty much anywhere.
gcc users may need to install thegcc multilib packages.
if you frequently target several different platforms, and want to switch between them without regenerating your project files, you can add them directly to your script.
so you can change the build order by rearranging the order of the projects in your script.
if you have a solution that builds on windows, and you want to a binary for the xbox 360, you would call: premake4 --platform=xbox360 vs2005 the files generated by this call will include the default win32 build normally present in visual studio solutions, plus a new set of configurations which target the xbox 360.
premake's mercurial repository does not contain any project files.
the path.getname function returns the file name and extension, with any directory information removed.
you can update these strings by using the embed action, which is part of premake's own build script.
if you downloaded a prebuilt binary package you can skip this page, which discusses how to build the premake source code.
the tracker makes sure your request gets the visibility and attention it deserves, with no chance of it slipping through the cracks.
if you find a problem in the documentation, leave a comment describing the problem on that page.
instead, usean existing copy of premake to generate the files for your particular toolset and environment.
libdirs { os.findlib("x11") } configurations a configuration is a collection of flags and options to apply to a build, including build flags, header file and library search directories, and more.
once you have a working premake installed, embed the scripts by opening a console or terminal to the source code directory and running the command premake4 embed now generate the project files with a command like: premake4 gmake # for gnu makefiles using gcc premake4 vs2008 # for a visual studio 2008 solution use the --help option to see all of the available targets.
the project files generated by premake will maintain the order of the projects as they appear in your script.
libdirs { "../lua/libs", "../zlib" } you can also use wildcards to match multiple directories.
path is the full path for the image file, relative to the currently executing script file.
any values returned by the included script are passed through to the caller.
your questions will help me improve this documentation and premake itself and are very much appreciated.
files { "*.c" } excludes { "a_file.c", "another_file.c" } excludes may also use wildcards.
sometimes you may want to exclude all the files in a particular directory, but aren't sure where that directory will fall in the source tree.
if a project includes multiple calls to includedirs the lists are concatenated, in the order in which they appear in the script.
i'll continue to use the original file names (like _example.lua) through this explanation.
project values take precedence over solution values, and will appear after the solution values in lists.
the directory portion of the path, with any file name removed.
by default, solution and project files are generated into the same directory as the script that defines them.
an important caveat: i don't target multiple platforms in my own day to day work.
premake is built on lua, so everything in the lua reference manual applies to a premake script.
you can add new test files in tests/premake4.lua.
premake will check the option value at startup, and raise an error on invalid values.
if any of the identifiers is not the current environment the settings will be ignored.
the path.getbasename function returns the base file portion of a path, with the directory and file extension removed.
prebuildcommands prelinkcommands configuration "windows" postbuildcommands { "copy default.config bin\\project.config" } configuration "not windows" postbuildcommands { "cp default.config bin/project.config" } the prebuildcommands function specifies shell commands to run before each build.
virtual paths, like files, may be set on the solution, project, and configuration level.
you can specify a different file name using the file argument, like so: premake4 --file=myfilename.lua you can define your entire project in one script file if you want, or you can split up the projects into their own files, or any other organization you can dream up.
solution "mysolution" configurations { "debug", "release" } platforms { "native", "universal" } provide 32- and 64-bit specific build targets.
flags that are not supported by a particular platform or toolset are ignored.
if a project includes multiple calls to libdirs the lists are concatenated, in the order in which they appear in the script.
use an option value in a configuration targetdir ( _options["outdir"] ) new command-line options are created using the newoption function, passing a table which fully describes the option.
or maybe you just want an easy way to reconfigure your project for different situations or environments, pulling in different source code or libraries, switches and options.
files { "file_list" } if a project includes multiple calls to files the lists are concatenated, in the order in which they appear in the script.
i'll be glad to help you out.
if you get stuck, post a question over in the forums and i will do my best to help you out.
for instance, a list of source code files, or defined symbols, or build flags.
the os.findlib function scans the well-known system locations looking for a library file.
premake knows which scripts to load and run by reading the file src/_manifest.lua.
configurations { "names" } a configuration encapsulates a collection of build settings, allowing the developer to easily switch between them.
configuration { "debug", "sharedlib or staticlib" } targetsuffix"_d" -- ...or... configuration { "debug", "*lib" } targetsuffix "_d" although support is currently quite limited (only buildaction works so far), you may also apply settings to a particular file or set of files.
to this, premake adds functions for defining solutions, projects, and configurations as well as support for common build configuration tasks.
visual studio and other ides provide facilities to quickly switch between configurations; premake-generated makefiles allow the configuration to be specified with a command-line parameter.
kind "sharedlib" you can also set different kinds for each configuration.
the excludes function removes files, added with the files function, from a project.
once you have defined a list of platforms, you may use those identifiers to set upconfiguration filters and apply platform-specific settings.
**" } the resoptions function passes arguments directly to the resource compiler command line without translation.
the imageoptions function passes arguments directly to the image tool command line without translation.
uuid ("project_uuid") uuids are synonymous (for premake's purposes) with globally unique identifiers (guid).
you can also mix platforms with other configuration selectors configuration { "debug", "x64" } defines "is_64bit_debug" the postbuildcommands function specifies shell commands to run after build is finished.
the table.implode function merges an array of items into a single, formatted string.
running make with no options will build all targets using the default configuration.
it isn't rocket science, and you probably already have the gist of it from the example above, so feel free to skip around.
configuration "vs2005" defines { "visual_studio_2005" } wildcards can be used to match multiple terms.
target platforms are part of the solution, just like configurations: solution "mysolution" configurations { "debug", "release" } platforms { "native", "universal" } not all tools will support all of the possible targets (currently only visual studio supports the xbox 360 platform).
the file name and extension, with no directory information.
let me start with a bit of general information that you will need to know to begin scripting.
the path.iscfile function returns true if the specified path represents a c source code file, based on its file extension.
each solution contains one or more projects, which it turn contain the settings to generate a single binary target.
normally you would include the native platform, and list it first to make it the default.
assuming that you have the proper development tools installed and your software is portable enough, you can now build an xbox 360 binary.
path sets match the format of the path environment variable: a colon-delimited list of paths.
in the case of files you may also use the ** wildcard, which will recurse into subdirectories.
these functions set up the project state and take care of error checking and the like.
your questions will help me improve these instructions.
you may also want to check out luaforge for a wide assortment of lua add-on modules.
if the existing flags are not sufficient, you can also pass tool-specific arguments directly to the compiler or linker usingbuildoptions and linkoptions.
pattern is the pattern to search for; it may use lua's pattern matching syntax.
these are intended for folks who want to add new actions or api functions to premake.
vpaths { ["group"] = "pattern(s)" } note that lua tables do not maintain any ordering between key-value pairs, so there is no precedence between the supplied rules.
the solution name, provided as a parameter to the function, is used as the file name of the generated solution file.
if you do not supply a config argument, release mode will be used.
premake provides a great deal of flexibility when it comes to configuring your build: you can apply settings across an entire solution, a project, or to a targeted combination of configuration and toolset.
you can also refer to thereference section or the lua reference manual for information on a particular function or variable.
i'll see your comment and fix it up, and the in meantime others can benefit from your input.
visual studio and other ides provide facilities to quickly switch between configurations; premake-generated makefiles allow the configuration to be specified with a command-line parameter.
the inclusion of the lua scripts throws a wrench in things, and i certainly understand if you have questions.
if you spot any problems, or think something is unclear, feel free to leave a comment.
it reads a description of a software project and generates the files for one of several different toolsets.
pchsource "file" if no source file is set, the toolset default settings will be used.
the next release build will include the updated scripts.
for instance, if your project can be built as both as both static or shared libraries, you might use this instead: configurations { "debuglib", "debugdll", "releaselib", "releasedll" } some features of premake, such as selecting a configuration from the command line, are easier if you avoid spaces.
the source code is hosted on bitbucket; file downloads are hosted onsourceforge.
note that the project name is used to specify the link; premake will automatically figure out the correct library file name and directory and create a project dependency.
for example, if the script is located atmyproject/build and the source files are atmyproject/src, the files should be specified as files { "../src/*.cpp" } paths should always use the forward slash / as a separator; premake will translate to the appropriate platform-specific separator as needed.
if you get stuck, post a question over in the forums and i will do my best to help you out.
local prj = project() you can retrieve the list of projects associated with a solution using the projects field on the solution object, which may then be iterated over.
i try to check them daily and respond personally to most posts.
supply the --platform option to premake, and then build using the corresponding configuration.
true if haystack starts with needle.
_premake_command the _premake_command global variable stores the full path to the premake executable.
theconfiguration function is used to apply settings to a particular build environment.
the platform is just another configuration axis, which you can mix and match with any other selectors.
configuration "**.png" buildaction "embed" the buildoptions function passes arguments directly to the compiler command line without translation.
when linking against another project in the same solution, specify the project name here, rather than the library name.
premake is built on lua, so everything in the lua reference manual applies to a premake script.
you can also use wildcards to match multiple directories.
files { "src/**.cpp" } the flags function specifies build flags to modify the compiling or linking process.
the objdir function sets object and intermediate file directory for a project.
gcc users may need to install thegcc multilib packages.
if os.is64bit() then print("this is a 64-bit system") else print ("this is not a 64-bit system") end the os.isdir function checks for the existence of directory.
please see the platforms section of the user guide for a lot more information on platforms and how they are used by premake.
files { "**.c" } excludes { "tests/*.c" } the files function adds files to a project.
instead, project owners are encouraged toadd an install action to their premake scripts, which has the advantage of working with any toolset on any platform.
any settings that appear after this function in the script will be applied only in those environments that match all of the listed keywords.
"**.h" } any directory information explicitly provided in the pattern will be removed from the replacement.
if you find a problem in the documentation, leave a comment describing the problem on that page.
and it provides an easy upgrade path as new versions of your favorite tools are released.
as an example, if this command line was used to launch premake... $ premake4 vs2005 ...then _action will be set to "vs2005".
jump ahead to quick start to begin learning how to use and develop with premake.
leave a notein the forums (the preferred approach), join the mailing list, or contact me directly.
in visual studio, this file can be overridden by a per-user configuration file (such asprojectname.vcproj.mydomain-myusername.user).
the os.copyfile function copies a file from one location to another.
files { "hello.cpp", "goodbye.cpp" } add all c++ files from the src/ directory to the project.
libname is name of the library to locate.
premake will recognize it as an executable and create the build dependency, but skip the link dependency.
you add files—source code, resources, and so on—to your project using thefiles function.
so that's the name you want to give your project script files, generally.
premake will check the option value at startup, and raise an error on invalid values.
so that's the name you want to give your project script files, generally.
to this, premake adds functions for defining solutions, projects, and configurations as well as support for common build configuration tasks.
the base name portion of the supplied path, with any directory and file extension removed.
once the files have been generated you can load the solution or workspace into your ide and build as you normally would.
once added to your script, the option will appear in the help text, and you may use the trigger as a keyword in your configuration blocks.
you can define build-wide settings at the solution level; these will apply to all of the projects contained by that solution.
if a solution with the given name already exists, it is made active and returned.
when built in debug mode, premake will read its lua scripts from the disk at startup, enabling compile-less code/test iterations, and therefore faster development.
you can use the /scripts command line argument, like so: premake4 /scripts=~/code/premake4/src gmake or set a premake_path environment variable: premake_path=~/code/premake4/src you need to specify the location of the premake src/ directory, the one containing_premake_main.lua.
you can use the visual studioguidgen tool to create new uuids, orthis website, or run premake once to generate visual studio files and copy the assigned uuids.
project "myexecutableproject" -- ...project settings here... links { "mylibraryproject" } finding libraries you can tell premake where to search for libraries with the libdirs function.
a significant portion of premake is written in lua.
ext is the new file extension, including the leading dot.
finally, post any questions you might have over in the forums and i will be delighted (yes, delighted) to help you out.
most builds will need only a single solution, but you are free to create more if needed.
solution "mysolution" configurations { "debug", "release" } project "myproject" the project name, like the solution name, is used as the file name for the generated project file so avoid special characters.
path is the filesystem path to file for which to retrieve information.
pchheader "file" if no header file is set, the toolset default settings will be used.
i created an example action, available in the source code packages at src/actions/example, to help you get started.
jump ahead to quick start to begin learning how to use and develop with premake.
the indentation is for readability and is optional.
a list of key/value pairs, specified with lua's standard syntax, which map file patterns to the group in which they should appear.
for instance, you may want to build an executable to use in the prebuild step for another project.
an important caveat: i don't target multiple platforms in my own day to day work.
project "myexecutable" kind "consoleapp" links { "mylibrary" } premake will automatically figure out the library file name and directory and create a dependency between the two projects to ensure a proper build order.
using configurations premake provides a great deal of flexibility when it comes to configuring your build: you can apply settings across an entire solution, a project, or to a targeted combination of configuration and toolset.
the value is not case sensitive.
premake will generate a build script with the right instructions for a 64-bit or an xbox build, but that build will only succeed if the corresponding tools and libraries have been installed on the developer machine.
the os.is64bit function determines if the host is using a 64-bit processor.
the os.matchdirs function performs a wildcard match to locate one or more directories.
you could place a bit of code like this anywhere in your script.
skip ahead to the next section to learn about the important differences between the build configurations.
an action indicates what premake should do on any given run.
string.startswith("haystack", "needle") haystack is the string to check.
the newaction function registers a new command-line action argument.
configuration "windows" links { "user32", "gdi32" } configuration "linux" links { "m" ,"png" } configuration "macosx" -- os x frameworks need the extension to be handled properly links { "cocoa.framework", "png" }
if your premake script is in c:\code\myproject then the generated files will also be in c:\code\myproject.
by default, the project will use the system's normal naming conventions: .exe
spaces are allowed, but may make using certain premake features, such as a command-line configuration selection, more difficult.
the os.getcwd function gets the current working directory.
project values take precedence over solution values, and will appear after the solution values in lists.
configuration { "xbox360" } defines "is_xbox360_build" -- this will only get applied when user chooses the xbox 360 build
they know their project better than i will, and may have seen the same problem before.
you can change this behavior by adding the winmain build flag to your package, like so: flags { "winmain" } q.
command line arguments premake provides the ability to define and handle new command-line arguments from within your project script using thenewaction and newoption functions.
and it provides an easy upgrade path as new versions of your favorite tools are released.
include "directory" this is equivalent to: dofile "directory/premake4.lua" this allows you to specify each project in its own premake4.lua file, and then easily include them into a solution, or multiple solutions.
local prjs = solution().projects for i, prj in ipairs(prjs) do print( prj.name) end each project is represented in lua as a table of key-value pairs.
starting with premake 4.0 i am following the visual studio naming conventions for build components.
links { _options["gfxapi"] .. "drv" } in this example, you would also want to provide a default behavior for the case where no option is specified.
imageoptions { "options" } if a project includes multiple calls to imageoptions the lists are concatenated, in the order in which they appear in the script.
(single dot) current directory is returned.
theconfiguration function is used to apply settings to a particular build environment.
configuration { "xbox360" } defines "is_xbox360_build" -- this will only get applied when user chooses the xbox 360
it then uses mytool as part of its build process.
the function returns the active project object; see the project object below for more information on the structure of this object.
theclean action causes all generated files to be deleted.
links { "cocoa.framework" } to link to a sibling project (a project in the same solution) use the project name.
for instance, the dotnet option is used to change which .net compiler set is used in the generated files.
the path.getdirectory function returns the directory portion of a path, with any file name removed.
it may contain the following fields: command line arguments register a new option to select a rendering api for a 3d application.
if no platform is specified to the filter, the subsequent settings will apply to all platforms.
links { _options["gfxapi"] .. "drv" } in this example, you would also want to provide a default behavior for the case where no option is specified.
targetname targetdir targetextension targetsuffix targetprefix "plugin" the prefix may also be set to an empty string for no prefix.
these functions set up the project state and take care of error checking and the like.
the function returns the current list of target platforms for the active solution.
it serves as a simple flag, and does not take any value.
note that when working against the mercurial sources it is a good idea to refresh the embedded scripts after each update.
the easiest way to target a particular platform is to supply the --platform argument to premake.
place all header files into a virtual path called "headers".
or you could be more clever.
these platforms can be quickly switched between from within your ide, or with a command-line parameter on the generated makefile.
files and file names premake will look for a file named premake4.lua by default, much like make looks for a file named makefile.
instead, project owners are encouraged toadd an install action to their premake scripts, which has the advantage of working with any toolset on any platform.
the following sections of this guide will walk you through all of the features of premake in a somewhat logical fashion.
not all languages are supported by all of the generators; for instance, sharpdevelop does not (currently) support c or c++ development, and code::blocks does not support the .net languages (c#, managed c++).
in the generated makefiles, platforms and build configurations are paired up.
the official premake documentation.
configuration "debug" debugargs { "--append", "somefile.txt" } the debugdir function sets the working directory for the integrated debugger.
you may also want to check out luaforge for a wide assortment of lua add-on modules.
premake provides the ability to define and handle new command-line arguments from within your project script using thenewaction and newoption functions.
os.matchdirs("pattern") patterm is the file system path to search.
provide a generic build that will work anywhere, as well as a mac os x universal build.
"force the use of opengl for rendering, regardless of platform" } note the commas after each key-value pair; this is required lua syntax for a table.
thetargetdir function allows you to change this location.
in addition to 32- and 64-bit builds, premake also supports mac os x universal binaries, the playstation 3, and the xbox 360.
keywords are not case-sensitive.
files { "src/*.cpp" } add all c++ files from the src/ directory, and any subdirectories.
ides like visual studio provide their own mechanism for switching build configurations.
not all platforms are supported on all systems, unsupported platforms will be silently ignored.
if you just want to script your projects, have a look atscripting with premake instead.
platforms { "x32", "x64" } like any other configuration-specific value, platform-specific settings are set withconfiguration filters.
the best way is to create a patch (see subversion'sdiff command) against the subversion repository, or if that's not possible, the most recent source code release.
configuration { "debug" } defines "_debug" -- this symbol will appear in settings for all platforms if a specific platform identifier is listed, the settings will be applied only when that platform is specifically selected by the user.
resincludedirs { "paths" } if a project includes multiple calls to resincludedirs the lists are concatenated, in the order in which they appear in the script.
the key is the option identifier ("dotnet"), which references the command line value ("mono") or an empty string for valueless options.
once you have a working premake installed, embed the scripts by opening a console or terminal to the source code directory and running the command premake4 embed now generate the project files with a command like: premake4 gmake # for gnu makefiles using gcc premake4 vs2008 # for a visual studio 2008 solution use the --help option to see all of the available targets.
the os.get function identifies the currently targeted operating system.
vpaths { ["headers/*"] = "src/**.h" } you can also use virtual paths to remove extra directories from the ide.
it does need to actually exist on the file system.
in addition to these project generation capabilities, premake also provides a completelua scripting environment, enabling the automation of complex configuration tasks, such as setting up new source tree checkouts or creating deployment packages.
these settings include the list of source code files, the programming language used by those files, compiler flags, include directories, and which libraries to link against.
you can also refer to thereference section or the lua reference manual for information on a particular function or variable.
faqs here are answers to some of the most frequently asked questions about premake, taken fromthe forums and the mailing list.
solutions and projects starting with premake 4.0 i am following the visual studio naming conventions for build components.
a quick introduction for people who arrived here directly: premake is a build configuration tool.
solution "mysolution" you can retrieve the currently active solution object by calling solution with no parameters.
linking to external libraries is done with the links function.
i tried to truncate the platforms to something easy to type.
implibname implibdir implibprefix implibextension -- add "-d" to debug versions of files configuration "debug" implibsuffix "-d" the include function looks for a file named premake4.lua in a specified directory, and includes it in the current script.
project "myexecutable" kind "consoleapp" links { "mylibrary" } premake will automatically figure out the library file name and directory and create a dependency between the two projects to ensure a proper build order.
if the makefile is executed without any arguments, the first build configuration (in the example above,debug) will be used.
buildoptions { "options" } if a project includes multiple calls to buildoptions the lists are concatenated, in the order in which they appear in the script.
supply the --platform option to premake, and then build using the corresponding configuration.
if a wildcard matches more files than you would like, you may filter the list using theexcludes function.
solution "mysolution" configurations { "debug", "release" } platforms { "x32", "x64" } you can retrieve the current list of platforms by calling the function with no parameters.
any directory information is removed, so a path such assrc/lua/lua.h will appear in the ide asheaders/lua.h.
it reads a description of a software project and generates the files for one of several different toolsets.
in addition to the cross-compiling platform targets listed above, there is a special target callednative which preserves the default compiler behavior.
in this case, premake will generate a build dependency (the linked project will build first), but not an actual link.
you can update these strings by using the embed action, which is part of premake's own build script.
this user guide reflects the current state of the software fairly closely, but may lag in places, or get a little ahead of the official releases in others.
the inclusion of the lua scripts throws a wrench in things, and i certainly understand if you have questions.
this user guide reflects the current state of the software fairly closely, but may lag in places, or get a little ahead of the official releases in others.
defines { "callspec=__dllexport" } the deploymentoptions function passes arguments directly to the deployment tool command line without translation.
values at the same level are evaluated in the order in which they are encountered in the script.
imageoptions the implibdir function specifies the import library output directory.
oldbase is the original base directory, from withpath is relative.
you can check for the existence of an install action by viewing the help (runpremake4 --help in the project directory).
" if you plan to build with multiple tools from the same source tree you might want to split up the project files by toolset.
it is a good idea to run a quick search first to make sure your issue hasn't already been reported.
"**.h", "**.hxx", "**.hpp" } } it is also possible to include the file's path in the virtual group.
premake will synthesize the correct format based on the target platform automatically.
for instance, if your project can be built as both as both static or shared libraries, you might use this instead: configurations { "debuglib", "debugdll", "releaselib", "releasedll" } some features of premake, such as selecting a configuration from the command line, are easier if you avoid spaces.
by default, the generated project files will place their compiled output in the same directory as the script.
if you don't have premake already, you can download it now.
uuid "be2461b7-236f-4278-81d3-f0d476f9a4c0" the vpaths function places files into groups or "virtual paths", rather than the default behavior of mirroring the filesystem in ide-based projects.
the tracker makes sure your request gets the visibility and attention it deserves, with no chance of it slipping through the cracks.
the path.isresourcefile function returns true if the specified path represents a windows resource file, based on its file extension.
building the source code premake can be built in either "release" (the default) or "debug" modes.
you can define build-wide settings at the solution level; these will apply to all of the projects contained by that solution.
if you think something should be possible and you can't figure out how to do it, feel free topost a question in the forums and someone will help you out.
leave a notein the forums (the preferred approach), join the mailing list, or contact me directly.
the primary purpose of a solution is to act as a container for projects.
in a solution with two projects, link the library into the executable.
debugdir "path" note that this settings is not implemented for xcode 3, which requires a per-user configuration file in order to make it work.
thevalue field appears in the help text, and is intended to give the user a clue about the type of value that is expected.
in the generated makefiles, platforms and build configurations are paired up.
the best way is to create a patch (see subversion'sdiff command) against the subversion repository, or if that's not possible, the most recent source code release.
premake is built on lua, a powerful, fast, light-weight scripting language.
creating new options new command-line options are created using the newoption function, passing a table which fully describes the option.
language "c++" set the project language to c# language "c#" the libdirs function specifies the library search paths.
the solution name will be used as the file name of the generated solution file.
theimplibdir function allows you to change this location.
deploymentoptions { "options" } if a project includes multiple calls to deploymentoptions the lists are concatenated, in the order in which they appear in the script.
by default, the system naming convention will be used: no prefix on windows, a prefix of "lib" (as inlibmyproject.a) on other systems.
the os.pathsearch function searches a collection of paths for a particular file.
as before, this new option will be integrated into the help text, along with a description of each of the allowed values.
if you only want to set a single value, you can leave off the brackets if you like.
solution "mysolution" configuration { "debug", "release" } project "myproject" you can retrieve the currently active project object by calling project with no parameters.
they know their project better than i will, and may have seen the same problem before.
a quick introduction for people who arrived here directly: premake is a build configuration tool.
using theuuid function, you can assign a fixed uuid to each project which never changes, removing the randomness from the generated projects.
for example, if the script is located atmyproject/build and the source files are atmyproject/src, the files should be specified as files { "../src/*.cpp" } paths should always use the forward slash / as a separator; premake will translate to the appropriate platform-specific separator as needed.
lua allows the creation of namespaces (of a sort) by putting your functions into a table.
if you downloaded one of the official source code release packages, the project files have already been generated for you, and may be found in the build/ directory.
the wildcard* will match files in one directory; the wildcard ** will match files in one directory and also recurse down into any subdirectories.
once the files have been generated you can load the solution or workspace into your ide and build as you normally would.
for instance, thevs2005 action indicates that visual studio 2005 project files should be generated.
solution "mysolution" project "mylibraryproject" -- ...project settings here... project "myexecutableproject" -- ...project settings here... links { "mylibraryproject" } you can tell premake where to search for libraries with the libdirs function.
when calling a function with a single string constant for an argument, lua allows you to drop the parenthesis that would normally appear around the argument list.
if no build action is specified for a file a default action will be used, based on the file's extension.
this is an optional setting; if it is not provided the toolset's default behavior will be used.
premake adds the ability to define solutions, projects, and configurations, as well as functions useful for build configuration tasks.
premake scripts are really lua programs, so anything you can do in lua can also be done in a premake script.
configuration { "linux", "gmake" } resoptions { "`wx-config --cxxflags`", "-ansi", "-pedantic" } the solution function creates a new solution and makes it active.
do this only if your software requires knowledge of the underlying architecture at build time, otherwise include "native" to provide a generic build.
it saves the time that would otherwise be spent manually keeping several different toolsets in sync.
so avoid special characters; spaces are okay.
if you are having trouble building or using premake,visit our support page and i'll try to help you out.
the directory must contain apremake4.lua file, or an error will occur.
project "myproject" kind "consoleapp" language "c++" by default, premake will place generated solution and project files in the same directory as the script which defined them.
resdefines { "debug", "trace" } symbols may also assign values.
if you downloaded one of the official source code release packages, the project files have already been generated for you, and may be found in the build/ directory.
resdefines { "callspec=__dllexport" } the resincludedirs function specifies the include file search paths for the resource compiler.
for instance, this rule will cause the previous example to appear aslua/lua.h , removing the src part of the path from all files.
if newsep is nil, the native path separator for the current environment will be used.
post it to thepatch tracker on sourceforge—i get notified via email, and it provides a good place to discuss and track it.
for example, you can define a symbol across all configurations of all projects by setting it at the solution level, before any filters are enabled.
there are also functions that only accept a single value, such as solution and project names, the project kind and language, and so on.
resdefines { "symbols" } if a project includes multiple calls to resdefines the lists are concatenated, in the order in which they appear in the script.
specifying platforms the easiest way to target a particular platform is to supply the --platform argument to premake.
if you modify any of the core lua scripts (anything ending in.lua), you must also update these embedded strings before your changes will appear in the release mode build.
monodevelop and sharpdevelop do not support search directories at all, using only the gac.
as you can see, theflags function provides most of the features, and is a good place to start if you aren't sure how to make something go.
premake will deduce the correct library path and name based on the current platform and configuration.
these commands will be passed to the shell exactly as entered, including path separators and the like.
file patterns may contain the* wildcard to match against files in the current directory, or the** wildcard to perform a recursive match.
rather than repeating all of that here, i'll just let you go browse through the files and start plugging in the code for your own actions.
true if haystack ends with needle.
you can also use this method to create a build dependency between non-libraries.
premake will figure out the correct library to link against for the current configuration, and will also create a dependency between the projects to ensure a proper build order.
use theinclude() function or lua's dofile() to link all the files together.
using the example and script above, the generated files will be placed inc:\code\myproject\build.
you can check for the existence of an install action by viewing the help (runpremake4 --help in the project directory).
files { "*.c" } excludes { "a_file.c", "another_file.c" } excludes may also use wildcards.
in addition to the cross-compiling platform targets listed above, there is a special target callednative which preserves the default compiler behavior.
resoptions { "options" } if a project includes multiple calls to resoptions the lists are concatenated, in the order in which they appear in the script.
for release builds (the default) this has no impact, just build as normal and go.
in release builds, premake uses a copy of the scripts embedded into static strings: seesrc/host/scripts.c.
using the generated makefiles running make with no options will build all targets using the default configuration.
if you are having trouble using premake to generate build files for a particular project, your best bet is to contact the manager of the project first.
let me start with a bit of general information that you will need to know to begin scripting.
the project files generated by premake will maintain the order of the projects as they appear in your script.
use pkg-config style configuration when building on linux with gcc.
i personally like to use just one file for simple projects, and one-file-per-project for more complex builds.
this uuid is essentially random and will change each time the project file is generated.
so you can change the build order by rearranging the order of the projects in your script.
it allows you to generate project files for tools that you do not own.
premake scripts are really lua programs, so anything you can do in lua can also be done in a premake script.
describe your c, c++, or c# software project usinga simple, easy to read syntax and let premake generate the project files for: microsoft visual studio 2002-2010, including the express editions gnu make, including cygwin and mingw apple xcode version 4.1 of premake added experimental support for cross-compiling, targeting: 32- and 64-bit builds mac os x 32- and 64-bit universal binaries playstation 3 (visual studio and gnu make) xbox 360 (visual studio only) premake allows you to manage your project configuration in one place and still support those pesky ide-addicted windows coders and/or cranky linux command-line junkies.
on platforms where this has not been implemented, it will return zero for all version numbers, and the platform name as the description.
objdir ("path") by default, object and intermediate files are stored in a directory named "obj" in the same directory as the project.
solution ("name") solutions are the top-level objects in a premake build script, and are synonymous with a visual studio solution.
the native platform, in contrast, does not addany flags to the command line and lets gcc use its default behavior to target the current platform.
you can also use not to apply the settings to all environments where the identifier is not set.
linkoptions { "options" } if a project includes multiple calls to linkoptions the lists are concatenated, in the order in which they appear in the script.
destination is the path to the copy location.
thevalue field appears in the help text, and is intended to give the user a clue about the type of value that is expected.
however, spaces are allowed in configuration names.
defines { "debug", "trace" } symbols may also assign values.
the command premake4 embed copies all of the scripts listed in the manifest into static c buffers in the filesrc/host/scripts.c, which then gets compiled into the final executable.
the printf performs like its c counterpart, printing a formatted string.
the configuration function limits the subsequent build settings to a particular environment.
premake will recognize it as an executable and create the build dependency, but skip the link dependency.
on os x,: "10.6.6 (mac os x snow leopard)" the os.is function checks the current operating system identifier against a particular value.
next steps if you are having trouble building your project, start by contacting the project manager.
if you frequently target several different platforms, and want to switch between them without regenerating your project files, you can add them directly to your script.
if all of these identifiers are present in the current runtime environment, then the settings following theconfiguration call will be applied.
newsep is the new path separator.
if you are having trouble building or using premake,visit our support page and i'll try to help you out.
by default, the generated project files will place the import library in the same directory as the compiled binary.
premake automatically assigns a uuid to each project, which is used by the visual studio generators to identify the project within a solution.
"**.h" } you may also specify multiple file patterns using the table syntax.
i tried to truncate the platforms to something easy to type.
implibname ("name") by default, the target name will be used as the import library file name.
for instance, thevs2005 action indicates that visual studio 2005 project files should be generated.
the targetdir function sets the destination directory for the compiled binary target.
the underscore sorts this file to the top of the list making it easy to locate.
if you spot any problems, or think something is unclear, feel free to leave a comment.
the imagepath function sets the file name of the deployment image produced by the build.
for instance, you may want to build an executable to use in the prebuild step for another project.
as an example, if this command line was used to launch premake... $ premake4 vs2005 alpha beta ...then _args[1] will be set to "alpha" and _args[2] to "beta".
just unpack the download and place the executable on your system search path or anywhere else convenient.
when you have completed your changes and are ready to roll them out, note that you must runpremake4 embed and recompile in order to see your changes in the release build of premake.
project "myproject"   defines { "trace" } -- this will be applied to every configuration   configuration "debug" defines { "debug" } -- this will only be applied to debug builds when values are supplied at multiple levels, list fields (like defines above) areconcatenated while single-value fields (like language) are overridden.
if no platform is specified to the filter, the subsequent settings will apply to all platforms.
building premake learn how to compile premake from the source code.
i've loaded up the example files, particularly the action description, to help you make sense of them.
the next release build will include the updated scripts.
debug vs. release modes a significant portion of premake is written in lua.
_script the _script global variable stores the full path of the currently executing script.
projects the primary purpose of a solution is to act as a container for projects.
assuming that you have the proper development tools installed and your software is portable enough, you can now build an xbox 360 binary.
unsupported platforms are silently ignored; they simply will not appear in the generated build scripts.
you can also use this method to create a build dependency between non-libraries.
the resdefines function specifies preprocessor symbols for the resource compiler.
to build a different configuration supply theconfig argument: make config=release most projects provide debug and release configurations; to see the available targets and configurations, type: make help remove all generated binaries and intermediate files with: make clean premake generated makefiles do not support a make install step.
learn how to compile premake from the source code.
implibname implibextension implibprefix implibsuffix implibdir "../libraries" the implibextension function specifies the import library file extension.
if you only want to set a single value, you can leave off the brackets if you like.
i keep all of the actions in src/actions, so create a new folder there with an appropriate name.
post it to thepatch tracker on sourceforge—i get notified via email, and it provides a good place to discuss and track it.
copy the files from src/actions/example to your new folder and rename them appropriately.
you can check for an option using the _options table, which contains a list of key-value pairs.
in this section, i'll show you how to create project scripts for premake.
the function returns the current list of configuration names for the active solution.
in this case, the native platform would not be included in the list.
configurations { "debug", "release", "debugdll", "releasedll" } you can retrieve the current list of configurations by calling the function with no parameters.
by using premake, software developers can save time and support more tools and users.
implibdir implibextension implibprefix implibsuffix implibname "mytarget" the implibprefix function specifies the import library file name prefix.
just unpack the download and place the executable on your system search path or anywhere else convenient.
the os.rmdir function removes an existing directory as well as any files or subdirectories it contains.
in addition to 32- and 64-bit builds, premake also supports mac os x universal binaries, the playstation 3, and the xbox 360.
sometimes you may want to exclude all the files in a particular directory, but aren't sure where that directory will fall in the source tree.
because of the descriptive nature of the lua language, your build scripts will often look more like static configuration files than mini-programs.
the os.stat function retrieves information about a file.
in this case, the native platform would not be included in the list.
"install the software", execute = function () os.copyfile( "bin/debug/myprogram", "/usr/local/bin/myprogram") end } the newoption function registers a new command-line option argument.
**" } the linkoptions function passes arguments directly to the linker command line without translation.
premake will synthesize the correct format based on the target platform automatically.
visual studio will change relative paths to absolute, making it difficult to share the generated project.
note that all expressions are evaluated before the condition is checked; the following expression can not be implemented with an immediate if because it may try to concatenate a string value.
it is small, weighing in at around 200k. it does not require any additional libraries or runtimes to be installed, and should build and run pretty much anywhere.
for instance, a list of source code files, or defined symbols, or build flags.