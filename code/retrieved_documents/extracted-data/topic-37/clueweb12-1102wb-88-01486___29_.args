also, if you are able to use the code under test with a minimal amount of other code or libraries, it means you are creating very modular, self-contained code, which will help with the overall design.it is common sense and a good software engineering practice to keep all the graphics-related code in one library or module, and make the rest of the game independent of the platform graphics api and hardware.the resulting code is much easier to work with as a result, and it directly solves the problems it was intended to fix.the extra code does not take significantly longer to write initially, and it allows us to move a lot faster once we have accumulated more code and we need to refactor or optimize the code in any way.when doing this, it can be extremely useful to have somebody on board with previous tdd experience who can help guide the process, set up the environment, and avoid common early mistakes.one of the drawbacks of this approach is that we’re working directly with the hardware, so tests actually do initialize and shutdown the graphics system every time (except for those platforms out there that can only initialize the graphics system once), so they can be more time consuming.this makes it so everybody is running unit tests for all code all the time, which greatly improves the build stability.test-driven development can be a very effective development technique.it is possible to simply write code faster than it is to write the tests first, but as soon as that code needs to be refactored, debugged, used by somebody else, or simply gets more complex, any time savings quickly disappear.few media of creation are so flexible, so easy to polish and rework, so readily capable of realizing grand conceptual structures.that way we could make any graphics api calls that we needed without having to worry about the underlying hardware.broken builds happen much less frequently, and they’re usually caused by a missing file or a different platform not compiling correctly.pair programing also has the added advantage of making programmers less likely to skip writing tests, which can be a common reaction early on.not only does this allow us to unit-test our code in isolation, but we also keep future merges with epic’s codebase as simple as possible.the key to working with tdd is to realize that refactoring is an integral part of the development process and should happen regularly every few tests.