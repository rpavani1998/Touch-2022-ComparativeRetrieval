while this sounds complicated, it's actually quite simple.
what it wants to see is: messagebox (hwnd, text("this is my first ce app"), text("hello world"), mb_ok); the text-macro simply converts a string at compile-time to unicode format.
if a particular device has some picadillos germaine to its processor, you won't see them when it runs on the emulator.
game technologies while directx isn't there, you're not completely out of luck.
numbers, though, can only give you part of the story.
the doom and quake engines direct3d and opengl don't exist for pocketpc, but you're not out of luck if you're looking for 3d that fits in your pocket.
best of all, though, is that it addresses a problem caused by the loss of directsound -- wave mixing.
in addition to framebuffer access, gapi gives you a relatively platform-neutral way of accessing the pocketpc's controls.
while compiling the file and sending it over to the device happens at a reasonable speed, debugging is downright glacial.
this goes for every hard-coded string in your application, from window-class-names to filenames you pass to the file-handling commands.
gxgetdisplayproperties() returns a structure containing the properties of the display, including bits per pixel, width, height, x pitch, and y pitch.
pressing the "run" button will then run your app in the on-screen windows ce emulator.
set a breakpoint in your code, and the code will stop when it gets to that point.
developing an app for the on-screen emulator will make you feel right at home if you're used to developing standard windows apps under visual c++ 6.0.
conclusion pocketpc's are cool.
drawtext() was better than textout(), so drawtext() got to stay.
here's a comparison of some of the best of the pocketpc offerings compared with the best color palm titles.
in fact, they're almost identical to their windows-only brethren, visual c++ 6.0 and visual basic 6.0.
if you want to change the bits, you need to create a new bitmap, which make it far less than optimal for displaying frames of animation.
as you can see, the pocketpc machines are all more expensive than the palms, but the capabilities of the pocketpc's are disproportionately greater.
using createdibsection(), you can create a buffer of memory that's shared between the application and video driver.
embedded visual c++ works through ms's activesync software, which is the software used to connect your pocketpc to your computer to exchange data with your address book and calendar.
this is important because while some handhelds like the casio and the ipaq have nice little direction-pads, some like the new hp pocketpc decided to clone
in addition to graphics, ceanim includes a library of common data structures and memory management functions.
another problem with gapi is that direct framebuffer access precludes all of the nice window commands.
from time to time, though, you'll need to compile on the device so you can ensure that the graphics look right, the game is playing at a reasonable speed, and no bugs are creeping in that aren't showing up on the emulator.
furthermore, your emulated app will likely be running much faster emulated than on the device, so you won't get a good feel for how your game plays if you develop solely for the emulator.
examine a variable in memory, and visual c++ will get the value and show it to you on your main screen.
the start menu was moved to a little icon in the corner.
since there weren't going to be any old ce apps, the designers went through the win32 api with a fine-toothed comb to prune it down to its bare essentials -- a library that would still allow you to create powerful apps, but without supporting a lot of antiquated function calls.
you can change the bits as necessary and blit the buffer to the screen very quickly using the standard old bitblt() command.
if you want to change the bits, you need to create a new bitmap, which make it far less than optimal for displaying frames of animation.
it leverages the dibsection api to the hilt to provide all kinds of animation effects, including sprite animation, alpha blending, dirty rectangle management, and palette management.
you'll probably want to save debugging on the device as a last resort to fix bugs that don't show up under the next method -- compiling for the pocketpc emulator.
since embedded visual basic produces programs that are interpreted by the pocketpc's rather rudimentary vbscript interpreter, embedded visual basic isn't really suitable for games.
examine a variable in memory, and visual c++ will get the value and show it to you on your main screen.
gxgetdefaultkeys() returns a struct containing the standard key-values that pocketpc supports, so you can easily check to see if a key is down.
in fact, the api functions that aren't part of the kernel, window, and gdi modules of windows probably aren't there.
pressing the "run" button will then run your app in the on-screen windows ce emulator.
not only are there some very capable developer tools for pocketpc, they're available for a song.
also, the emulator takes on the capabilities of the compiling machine, so you'll likely be developing your app on a 24-bit screen even though there are no pocketpc's with 24-bit screens.
much like microsoft's unsuccessful plans for windows nt running on every desktop platform, you can write to a standard windows api and get your application to work on all ce processors with a simple recompile.
despite the technical superiority of hardware like the casio e-100 series, the palm-size pc platform was savaged by critics for being overcomplicated and clumsy to use.
a significant chunk of the win32 api functions (around 90% of 'em, actually) aren't there.
drawtext() was better than textout(), so drawtext() got to stay.
finally, the emulator only runs on windows nt or windows 2000 for reasons that will be clear later.
since there weren't going to be any old ce apps, the designers went through the win32 api with a fine-toothed comb to prune it down to its bare essentials -- a library that would still allow you to create powerful apps, but without supporting a lot of antiquated function calls.
how the compiler works there are two ways to develop an app for pocketpc, and you will very likely be using both methods interchangeably.
thankfully, switching between one approach and another is as simple as choosing the target processor on the toolbar and recompiling.
developing an app for the on-screen emulator will make you feel right at home if you're used to developing standard windows apps under visual c++ 6.0.
thankfully, though, you don't have to worry about what processor for which you're writing.
since unicode is the way of the world, and supporting both ansi and unicode would take up more space than necessary, ansi strings got the boot.
using createdibsection(), you can create a buffer of memory that's shared between the application and video driver.
the pocketpc api is different from the win32 api sorry to throw a bucket of cold water on your plans, but if you have grand designs on simply recompiling your code and having it work, it's not going to happen that easily.
the first is by compiling your game for a connected device, then uploading, running, and debugging the game over the connection (usually serial).
for the bulk of development, the on-screen emulator is the way to go.
in addition to framebuffer access, gapi gives you a relatively platform-neutral way of accessing the pocketpc's controls.
ddb's (device dependent bitmaps) are owned by the video driver and are in whatever format
after dumping the dead wood, the designers went through the list of similar, yet redundant functions.
if you don't need to throw pixels at the screen at the highest speed possible, and you want very good speed without worrying about what new platforms are coming out and whether or not gapi will support them, you should look at the win32 dibsection api.
there's a sound class that can play multiple sounds at once so you don't have to cripple the sounds in your game.
all of the pocketpc functions that take strings are expecting unicode strings.
to compile for the emulator, you set the target processor as the x86 ce emulator, press the "make" button, and embedded visual c++ will generate a windows ce app that runs on the x86 processor.
thankfully, switching between one approach and another is as simple as choosing the target processor on the toolbar and recompiling.
like the handheld pc, it started out with several vendors, many of which bailed after low sales, like uniden and philips.
if anything, check out the author's ce offerings at the web address above to see the kind of things you can do.
thankfully, though, an intrepid hacker wrote a gapi dll that indeed works on the emulator.
best of all, though, is that it addresses a problem caused by the loss of directsound -- wave mixing.
it took very good advantage of color.
since the screen is so small, apps automatically grow to the size of the screen, and the title and menubars are combined.
the os makers, though, often must leave antiquated function calls in place to keep from breaking old apps.
what it wants to see is: messagebox (hwnd, text("this is my first ce app"), text("hello world"), mb_ok); the text-macro simply converts a string at compile-time to unicode format.
windows ce programming windows ce essential windows ce application programming windows ce 3.0 application programming discussion groups an active mailing list on yahoogroups is windowsce-dev hpc.net has a windows ce developer's mailing-list with over 1500 members!
first off, it's propriatary.
so don't type: messagebox (hwnd, "this is my first ce app", "hello world", mb_ok); you'll just upset your compiler.
after dumping the dead wood, the designers went through the list of similar, yet redundant functions.
this version should look instantly familiar.
on the whole, it's much more more extensive and high-level than gapi.
using the on-screen emulator, you can run an application under the debugger and it will run just as quickly as if you were debugging a native windows application.
after initializing gapi with gxopendisplay(), you can call gxbegindraw() to get a pointer to the framebuffer.
if you've been reading the trade articles of the past few years, this is probably the impression you got from microsoft's handheld entries.
it leverages the dibsection api to the hilt to provide all kinds of animation effects, including sprite animation, alpha blending, dirty rectangle management, and palette management.
it's up to the hardware maker how the video memory is organized.
you could modify the bits directly, and you could display them to the screen quickly.
the development tools are robust and very inexpensive.
since embedded visual basic produces programs that are interpreted by the pocketpc's rather rudimentary vbscript interpreter, embedded visual basic isn't really suitable for games.
while compiling the file and sending it over to the device happens at a reasonable speed, debugging is downright glacial.
there are unicode equivalents for all of your favorite string-handling functions, so don't get too upset.
this time, it actually works.
the new pocketpc interface capabilities the best way to show the capabilities of the respective devices is to show them side-by-side.
the c++ compiler cross-compiles to the aforementioned processors, while embedded visual basic produces files that are interpreted by a vbscript-style interpreter on the target device.
this is important because while some handhelds like the casio and the ipaq have nice little direction-pads, some like the new hp pocketpc decided to clone
press the "run" button, and your app will pop up on the device's screen.
press the "run" button, and your app will pop up on the device's screen.
if you have windows 95/98/me, you're stuck with developing on the connected device.
from time to time, though, you'll need to compile on the device so you can ensure that the graphics look right, the game is playing at a reasonable speed, and no bugs are creeping in that aren't showing up on the emulator.
in fact, the api functions that aren't part of the kernel, window, and gdi modules of windows probably aren't there.
since unicode is the way of the world, and supporting both ansi and unicode would take up more space than necessary, ansi strings got the boot.
furthermore, your emulated app will likely be running much faster emulated than on the device, so you won't get a good feel for how your game plays if you develop solely for the emulator.
they are very fast to display but have one gigantic drawback -- you can't change the bits once you've created the bitmap.
thankfully, though, an intrepid hacker wrote a gapi dll that indeed works on the emulator.
they are very fast to display but have one gigantic drawback -- you can't change the bits once you've created the bitmap.
the first is by compiling your game for a connected device, then uploading, running, and debugging the game over the connection (usually serial).
while the whole of the win32 api isn't there, there's enough to get around.
embedded visual c++ works through ms's activesync software, which is the software used to connect your pocketpc to your computer to exchange data with your address book and calendar.
the tools are very mature and robust.
so don't type: messagebox (hwnd, "this is my first ce app", "hello world", mb_ok); you'll just upset your compiler.
hence, if you're looking foraddatom() or getwindowword(), you won't find them.
you may lose some formatting when you deselect html mode and switch back to the rich text editor.
in addition to graphics, ceanim includes a library of common data structures and memory management functions.
copying the app to the on-screen emulator and running is almost instantaneous.
while this sounds complicated, it's actually quite simple.
if your pocketpc is connected via activesync, you've done all that's necessary to develop for your device.
the h/pc 2000 desktop the only major difference is that the applications don't live in nice little overlapping panes.
copying the app to the on-screen emulator and running is almost instantaneous.
the package includes embedded visual c++, embedded visual basic, and emulators for the platforms mentioned above.
the c++ compiler cross-compiles to the aforementioned processors, while embedded visual basic produces files that are interpreted by a vbscript-style interpreter on the target device.
finally, the emulator only runs on windows nt or windows 2000 for reasons that will be clear later.
the rich text editor is not available while html is enabled.
the file will be compiled, linked, and sent over to the device.
there are unicode equivalents for all of your favorite string-handling functions, so don't get too upset.
in fact, they're almost identical to their windows-only brethren, visual c++ 6.0 and visual basic 6.0.
hence, windows ce was written to work with for alternative processors with very low power consumption, like the strongarm, sh3/sh4, and mips.
a significant chunk of the win32 api functions (around 90% of 'em, actually) aren't there.
if you need a form-based data-collector or something to perform field calculations for you, it's ideal.
the os makers, though, often must leave antiquated function calls in place to keep from breaking old apps.
gxgetdisplayproperties() returns a structure containing the properties of the display, including bits per pixel, width, height, x pitch, and y pitch.
making a truly tiny machine based on a pentium-class processor just wouldn't be practical, because even though there are low-power pentium-class processors for laptops, shrinking a pentium machine to the size of a deck of cards and still getting reasonable battery life just wasn't going to happen.
it looks and acts very similarly to the windows you've come to know and tolerate.
best of all, microsoft finally made available the baby-office apps that had previously only been available on the handheld pc's.
rather than make processor-emulators for the various processors out there, ms simply built a version of windows ce that runs on an x86 processor.
the package includes embedded visual c++, embedded visual basic, and emulators for the platforms mentioned above.
you'll probably want to save debugging on the device as a last resort to fix bugs that don't show up under the next method -- compiling for the pocketpc emulator.
on the whole, it's much more more extensive and high-level than gapi.
if a particular device has some picadillos germaine to its processor, you won't see them when it runs on the emulator.
the device and embedded visual c++ are constantly having to update each other as to the status of your running program.
after initializing gapi with gxopendisplay(), you can call gxbegindraw() to get a pointer to the framebuffer.
jimmy's windows ce software www.pocketgamer.org ziosoft your name: or sign in html mode is enabled.
you can change the bits as necessary and blit the buffer to the screen very quickly using the standard old bitblt() command.
how the compiler works there are two ways to develop an app for pocketpc, and you will very likely be using both methods interchangeably.
the development tools are robust and very inexpensive.
there's a sound class that can play multiple sounds at once so you don't have to cripple the sounds in your game.
finally, gapi doesn't run on the emulator, which gets rid of some of the advantages of developing on-screen as mentioned in the previous article.
gxgetdefaultkeys() returns a struct containing the standard key-values that pocketpc supports, so you can easily check to see if a key is down.
the pitch values specify the distance between pixel values in the buffer, because a framebuffer is not necessarily a 240x320 array of 16-bit values.
to compile for the emulator, you set the target processor as the x86 ce emulator, press the "make" button, and embedded visual c++ will generate a windows ce app that runs on the x86 processor.
not only are there some very capable developer tools for pocketpc, they're available for a song.
if your pocketpc is connected via activesync, you've done all that's necessary to develop for your device.
while internally it was basically the same windows ce as the earlier versions, the user-interface was retooled to work better on a tiny screen.
hence, if you're looking foraddatom() or getwindowword(), you won't find them.
also, the emulator takes on the capabilities of the compiling machine, so you'll likely be developing your app on a 24-bit screen even though there are no pocketpc's with 24-bit screens.
all of the pocketpc functions that take strings are expecting unicode strings.
for the most part, if there existed several functions that did a similar job, they just kept the one or two that could best cover the capabilities of the rest.
finally, gapi doesn't run on the emulator, which gets rid of some of the advantages of developing on-screen as mentioned in the previous article.
the pocketpc api is different from the win32 api sorry to throw a bucket of cold water on your plans, but if you have grand designs on simply recompiling your code and having it work, it's not going to happen that easily.
for the bulk of development, the on-screen emulator is the way to go.
for the most part, if there existed several functions that did a similar job, they just kept the one or two that could best cover the capabilities of the rest.
a dib's memory is owned by your application, but drawing the bitmap to the screen requires the video driver to convert the bitmap to screen format, which makes displaying them much slower than ddb's.
while the whole of the win32 api isn't there, there's enough to get around.
game technologies while directx isn't there, you're not completely out of luck.
a dib's memory is owned by your application, but drawing the bitmap to the screen requires the video driver to convert the bitmap to screen format, which makes displaying them much slower than ddb's.
the menubar shrank and moved to the bottom.
the biggest difference is that they do not generate native x86 windows applications.
rather than make processor-emulators for the various processors out there, ms simply built a version of windows ce that runs on an x86 processor.
the doom and quake engines direct3d and opengl don't exist for pocketpc, but you're not out of luck if you're looking for 3d that fits in your pocket.
the device and embedded visual c++ are constantly having to update each other as to the status of your running program.
this goes for every hard-coded string in your application, from window-class-names to filenames you pass to the file-handling commands.
it's a great way to get your app up and running quickly, and debugging is a breeze.
using the on-screen emulator, you can run an application under the debugger and it will run just as quickly as if you were debugging a native windows application.
the designers of ce decided early on to focus on portability and small size in the design of ce, and it shows.
if you need a form-based data-collector or something to perform field calculations for you, it's ideal.
ddb's (device dependent bitmaps) are owned by the video driver and are in whatever format the driver prefers.
the principal advantage to this approach is speed.
if you don't need to throw pixels at the screen at the highest speed possible, and you want very good speed without worrying about what new platforms are coming out and whether or not gapi will support them, you should look at the win32 dibsection api.
if anything, check out the author's ce offerings at the web address above to see the kind of things you can do.
the biggest difference is that they do not generate native x86 windows applications.
set a breakpoint in your code, and the code will stop when it gets to that point.
if you have windows 95/98/me, you're stuck with developing on the connected device.
it's a great way to get your app up and running quickly, and debugging is a breeze.
another problem with gapi is that direct framebuffer access precludes all of the nice window commands.
the standard windows interface, while it worked well on larger screens, was tight on handhelds and was downright difficult on a small 240x320 screen.
you can purchase microsoft's embedded visual tools 3.0 cd from microsoft for only the cost of shipping and handling.
dibsections are weird birds.
you could modify the bits directly, and you could display them to the screen quickly.
you can purchase microsoft's embedded visual tools 3.0 cd from microsoft for only the cost of shipping and handling.
the pitch values specify the distance between pixel values in the buffer, because a framebuffer is not necessarily a 240x320 array of 16-bit values.
direct3d, directdraw, directinput, directplay, and opengl pocketpc doesn't support them.