gxgetdisplayproperties() returns a structure containing the properties of the display, including bits per pixel, width, height, x pitch, and y pitch.
in fact, they're almost identical to their windows-only brethren, visual c++ 6.0 and visual basic 6.0.
if you don't need to throw pixels at the screen at the highest speed possible, and you want very good speed without worrying about what new platforms are coming out and whether or not gapi will support them, you should look at the win32 dibsection api.
if you need a form-based data-collector or something to perform field calculations for you, it's ideal.
using createdibsection(), you can create a buffer of memory that's shared between the application and video driver.
a significant chunk of the win32 api functions (around 90% of 'em, actually) aren't there.
as you can see, the pocketpc machines are all more expensive than the palms, but the capabilities of the pocketpc's are disproportionately greater.
so don't type: messagebox (hwnd, "this is my first ce app", "hello world", mb_ok); you'll just upset your compiler.
the rich text editor is not available while html is enabled.
a dib's memory is owned by your application, but drawing the bitmap to the screen requires the video driver to convert the bitmap to screen format, which makes displaying them much slower than ddb's.
since embedded visual basic produces programs that are interpreted by the pocketpc's rather rudimentary vbscript interpreter, embedded visual basic isn't really suitable for games.
they are very fast to display but have one gigantic drawback -- you can't change the bits once you've created the bitmap.
after initializing gapi with gxopendisplay(), you can call gxbegindraw() to get a pointer to the framebuffer.
the file will be compiled, linked, and sent over to the device.
dibsections are weird birds.
all of the pocketpc functions that take strings are expecting unicode strings.
finally, the emulator only runs on windows nt or windows 2000 for reasons that will be clear later.
gxgetdefaultkeys() returns a struct containing the standard key-values that pocketpc supports, so you can easily check to see if a key is down.
copying the app to the on-screen emulator and running is almost instantaneous.
jimmy's windows ce software www.pocketgamer.org ziosoft your name: or sign in html mode is enabled.
the menubar shrank and moved to the bottom.
also, the emulator takes on the capabilities of the compiling machine, so you'll likely be developing your app on a 24-bit screen even though there are no pocketpc's with 24-bit screens.
the first is by compiling your game for a connected device, then uploading, running, and debugging the game over the connection (usually serial).
the biggest difference is that they do not generate native x86 windows applications.
another problem with gapi is that direct framebuffer access precludes all of the nice window commands.
what it wants to see is: messagebox (hwnd, text("this is my first ce app"), text("hello world"), mb_ok); the text-macro simply converts a string at compile-time to unicode format.
on the whole, it's much more more extensive and high-level than gapi.
since embedded visual basic produces programs that are interpreted by the pocketpc's rather rudimentary vbscript interpreter, embedded visual basic isn't really suitable for games.
in fact, the api functions that aren't part of the kernel, window, and gdi modules of windows probably aren't there.
thankfully, though, you don't have to worry about what processor for which you're writing.
examine a variable in memory, and visual c++ will get the value and show it to you on your main screen.
press the "run" button, and your app will pop up on the device's screen.
the principal advantage to this approach is speed.
it's up to the hardware maker how the video memory is organized.
pressing the "run" button will then run your app in the on-screen windows ce emulator.
drawtext() was better than textout(), so drawtext() got to stay.
here's a comparison of some of the best of the pocketpc offerings compared with the best color palm titles.
despite the technical superiority of hardware like the casio e-100 series, the palm-size pc platform was savaged by critics for being overcomplicated and clumsy to use.
thankfully, though, an intrepid hacker wrote a gapi dll that indeed works on the emulator.
the h/pc 2000 desktop the only major difference is that the applications don't live in nice little overlapping panes.
the doom and quake engines direct3d and opengl don't exist for pocketpc, but you're not out of luck if you're looking for 3d that fits in your pocket.
hence, windows ce was written to work with for alternative processors with very low power consumption, like the strongarm, sh3/sh4, and mips.
while compiling the file and sending it over to the device happens at a reasonable speed, debugging is downright glacial.
after dumping the dead wood, the designers went through the list of similar, yet redundant functions.
the os makers, though, often must leave antiquated function calls in place to keep from breaking old apps.
developing an app for the on-screen emulator will make you feel right at home if you're used to developing standard windows apps under visual c++ 6.0.
first off, it's propriatary.
a dib's memory is owned by your application, but drawing the bitmap to the screen requires the video driver to convert the bitmap to screen format, which makes displaying them much slower than ddb's.
since the screen is so small, apps automatically grow to the size of the screen, and the title and menubars are combined.
since there weren't going to be any old ce apps, the designers went through the win32 api with a fine-toothed comb to prune it down to its bare essentials -- a library that would still allow you to create powerful apps, but without supporting a lot of antiquated function calls.
if a particular device has some picadillos germaine to its processor, you won't see them when it runs on the emulator.
if you want to change the bits, you need to create a new bitmap, which make it far less than optimal for displaying frames of animation.
not only are there some very capable developer tools for pocketpc, they're available for a song.
rather than make processor-emulators for the various processors out there, ms simply built a version of windows ce that runs on an x86 processor.
hence, if you're looking foraddatom() or getwindowword(), you won't find them.
finally, gapi doesn't run on the emulator, which gets rid of some of the advantages of developing on-screen as mentioned in the previous article.
game technologies while directx isn't there, you're not completely out of luck.
the package includes embedded visual c++, embedded visual basic, and emulators for the platforms mentioned above.
for the bulk of development, the on-screen emulator is the way to go.
it took very good advantage of color.
there's a sound class that can play multiple sounds at once so you don't have to cripple the sounds in your game.
the c++ compiler cross-compiles to the aforementioned processors, while embedded visual basic produces files that are interpreted by a vbscript-style interpreter on the target device.
on the whole, it's much more more extensive and high-level than gapi.
the pocketpc api is different from the win32 api sorry to throw a bucket of cold water on your plans, but if you have grand designs on simply recompiling your code and having it work, it's not going to happen that easily.
using the on-screen emulator, you can run an application under the debugger and it will run just as quickly as if you were debugging a native windows application.
from time to time, though, you'll need to compile on the device so you can ensure that the graphics look right, the game is playing at a reasonable speed, and no bugs are creeping in that aren't showing up on the emulator.
while the whole of the win32 api isn't there, there's enough to get around.
this goes for every hard-coded string in your application, from window-class-names to filenames you pass to the file-handling commands.
ddb's (device dependent bitmaps) are owned by the video driver and are in whatever format
you'll probably want to save debugging on the device as a last resort to fix bugs that don't show up under the next method -- compiling for the pocketpc emulator.
set a breakpoint in your code, and the code will stop when it gets to that point.
copying the app to the on-screen emulator and running is almost instantaneous.
embedded visual c++ works through ms's activesync software, which is the software used to connect your pocketpc to your computer to exchange data with your address book and calendar.
the pocketpc api is different from the win32 api sorry to throw a bucket of cold water on your plans, but if you have grand designs on simply recompiling your code and having it work, it's not going to happen that easily.
while this sounds complicated, it's actually quite simple.
a significant chunk of the win32 api functions (around 90% of 'em, actually) aren't there.
this time, it actually works.
making a truly tiny machine based on a pentium-class processor just wouldn't be practical, because even though there are low-power pentium-class processors for laptops, shrinking a pentium machine to the size of a deck of cards and still getting reasonable battery life just wasn't going to happen.
best of all, though, is that it addresses a problem caused by the loss of directsound -- wave mixing.
ddb's (device dependent bitmaps) are owned by the video driver and are in whatever format the driver prefers.
examine a variable in memory, and visual c++ will get the value and show it to you on your main screen.
you can change the bits as necessary and blit the buffer to the screen very quickly using the standard old bitblt() command.
gxgetdisplayproperties() returns a structure containing the properties of the display, including bits per pixel, width, height, x pitch, and y pitch.
while this sounds complicated, it's actually quite simple.
windows ce programming windows ce essential windows ce application programming windows ce 3.0 application programming discussion groups an active mailing list on yahoogroups is windowsce-dev hpc.net has a windows ce developer's mailing-list with over 1500 members!
there are unicode equivalents for all of your favorite string-handling functions, so don't get too upset.
rather than make processor-emulators for the various processors out there, ms simply built a version of windows ce that runs on an x86 processor.
in addition to framebuffer access, gapi gives you a relatively platform-neutral way of accessing the pocketpc's controls.
they are very fast to display but have one gigantic drawback -- you can't change the bits once you've created the bitmap.
gxgetdefaultkeys() returns a struct containing the standard key-values that pocketpc supports, so you can easily check to see if a key is down.
conclusion pocketpc's are cool.
furthermore, your emulated app will likely be running much faster emulated than on the device, so you won't get a good feel for how your game plays if you develop solely for the emulator.
after dumping the dead wood, the designers went through the list of similar, yet redundant functions.
also, the emulator takes on the capabilities of the compiling machine, so you'll likely be developing your app on a 24-bit screen even though there are no pocketpc's with 24-bit screens.
it leverages the dibsection api to the hilt to provide all kinds of animation effects, including sprite animation, alpha blending, dirty rectangle management, and palette management.
if you have windows 95/98/me, you're stuck with developing on the connected device.
the biggest difference is that they do not generate native x86 windows applications.
while the whole of the win32 api isn't there, there's enough to get around.
drawtext() was better than textout(), so drawtext() got to stay.
numbers, though, can only give you part of the story.
it's a great way to get your app up and running quickly, and debugging is a breeze.
if you don't need to throw pixels at the screen at the highest speed possible, and you want very good speed without worrying about what new platforms are coming out and whether or not gapi will support them, you should look at the win32 dibsection api.
in addition to graphics, ceanim includes a library of common data structures and memory management functions.
the start menu was moved to a little icon in the corner.
direct3d, directdraw, directinput, directplay, and opengl pocketpc doesn't support them.
you could modify the bits directly, and you could display them to the screen quickly.
the os makers, though, often must leave antiquated function calls in place to keep from breaking old apps.
finally, gapi doesn't run on the emulator, which gets rid of some of the advantages of developing on-screen as mentioned in the previous article.
since there weren't going to be any old ce apps, the designers went through the win32 api with a fine-toothed comb to prune it down to its bare essentials -- a library that would still allow you to create powerful apps, but without supporting a lot of antiquated function calls.
all of the pocketpc functions that take strings are expecting unicode strings.
this goes for every hard-coded string in your application, from window-class-names to filenames you pass to the file-handling commands.
this is important because while some handhelds like the casio and the ipaq have nice little direction-pads, some like the new hp pocketpc decided to clone
furthermore, your emulated app will likely be running much faster emulated than on the device, so you won't get a good feel for how your game plays if you develop solely for the emulator.
thankfully, switching between one approach and another is as simple as choosing the target processor on the toolbar and recompiling.
thankfully, though, an intrepid hacker wrote a gapi dll that indeed works on the emulator.
developing an app for the on-screen emulator will make you feel right at home if you're used to developing standard windows apps under visual c++ 6.0.
you'll probably want to save debugging on the device as a last resort to fix bugs that don't show up under the next method -- compiling for the pocketpc emulator.
using createdibsection(), you can create a buffer of memory that's shared between the application and video driver.
if you need a form-based data-collector or something to perform field calculations for you, it's ideal.
best of all, though, is that it addresses a problem caused by the loss of directsound -- wave mixing.
another problem with gapi is that direct framebuffer access precludes all of the nice window commands.
if your pocketpc is connected via activesync, you've done all that's necessary to develop for your device.
the standard windows interface, while it worked well on larger screens, was tight on handhelds and was downright difficult on a small 240x320 screen.
you could modify the bits directly, and you could display them to the screen quickly.
for the most part, if there existed several functions that did a similar job, they just kept the one or two that could best cover the capabilities of the rest.
while compiling the file and sending it over to the device happens at a reasonable speed, debugging is downright glacial.
you may lose some formatting when you deselect html mode and switch back to the rich text editor.
like the handheld pc, it started out with several vendors, many of which bailed after low sales, like uniden and philips.
after initializing gapi with gxopendisplay(), you can call gxbegindraw() to get a pointer to the framebuffer.
in addition to framebuffer access, gapi gives you a relatively platform-neutral way of accessing the pocketpc's controls.
you can purchase microsoft's embedded visual tools 3.0 cd from microsoft for only the cost of shipping and handling.
to compile for the emulator, you set the target processor as the x86 ce emulator, press the "make" button, and embedded visual c++ will generate a windows ce app that runs on the x86 processor.
so don't type: messagebox (hwnd, "this is my first ce app", "hello world", mb_ok); you'll just upset your compiler.
the designers of ce decided early on to focus on portability and small size in the design of ce, and it shows.
what it wants to see is: messagebox (hwnd, text("this is my first ce app"), text("hello world"), mb_ok); the text-macro simply converts a string at compile-time to unicode format.
set a breakpoint in your code, and the code will stop when it gets to that point.
there are unicode equivalents for all of your favorite string-handling functions, so don't get too upset.
the pitch values specify the distance between pixel values in the buffer, because a framebuffer is not necessarily a 240x320 array of 16-bit values.
the development tools are robust and very inexpensive.
not only are there some very capable developer tools for pocketpc, they're available for a song.
the c++ compiler cross-compiles to the aforementioned processors, while embedded visual basic produces files that are interpreted by a vbscript-style interpreter on the target device.
much like microsoft's unsuccessful plans for windows nt running on every desktop platform, you can write to a standard windows api and get your application to work on all ce processors with a simple recompile.
if you want to change the bits, you need to create a new bitmap, which make it far less than optimal for displaying frames of animation.
using the on-screen emulator, you can run an application under the debugger and it will run just as quickly as if you were debugging a native windows application.
embedded visual c++ works through ms's activesync software, which is the software used to connect your pocketpc to your computer to exchange data with your address book and calendar.
for the most part, if there existed several functions that did a similar job, they just kept the one or two that could best cover the capabilities of the rest.
best of all, microsoft finally made available the baby-office apps that had previously only been available on the handheld pc's.
you can purchase microsoft's embedded visual tools 3.0 cd from microsoft for only the cost of shipping and handling.
the development tools are robust and very inexpensive.
since unicode is the way of the world, and supporting both ansi and unicode would take up more space than necessary, ansi strings got the boot.
for the bulk of development, the on-screen emulator is the way to go.
it looks and acts very similarly to the windows you've come to know and tolerate.
how the compiler works there are two ways to develop an app for pocketpc, and you will very likely be using both methods interchangeably.
if you have windows 95/98/me, you're stuck with developing on the connected device.
if you've been reading the trade articles of the past few years, this is probably the impression you got from microsoft's handheld entries.
since unicode is the way of the world, and supporting both ansi and unicode would take up more space than necessary, ansi strings got the boot.
game technologies while directx isn't there, you're not completely out of luck.
if a particular device has some picadillos germaine to its processor, you won't see them when it runs on the emulator.
finally, the emulator only runs on windows nt or windows 2000 for reasons that will be clear later.
there's a sound class that can play multiple sounds at once so you don't have to cripple the sounds in your game.
pressing the "run" button will then run your app in the on-screen windows ce emulator.
the pitch values specify the distance between pixel values in the buffer, because a framebuffer is not necessarily a 240x320 array of 16-bit values.
if anything, check out the author's ce offerings at the web address above to see the kind of things you can do.
the new pocketpc interface capabilities the best way to show the capabilities of the respective devices is to show them side-by-side.
it leverages the dibsection api to the hilt to provide all kinds of animation effects, including sprite animation, alpha blending, dirty rectangle management, and palette management.
press the "run" button, and your app will pop up on the device's screen.
how the compiler works there are two ways to develop an app for pocketpc, and you will very likely be using both methods interchangeably.
in fact, the api functions that aren't part of the kernel, window, and gdi modules of windows probably aren't there.
the first is by compiling your game for a connected device, then uploading, running, and debugging the game over the connection (usually serial).
while internally it was basically the same windows ce as the earlier versions, the user-interface was retooled to work better on a tiny screen.
the tools are very mature and robust.
in addition to graphics, ceanim includes a library of common data structures and memory management functions.
if anything, check out the author's ce offerings at the web address above to see the kind of things you can do.
the doom and quake engines direct3d and opengl don't exist for pocketpc, but you're not out of luck if you're looking for 3d that fits in your pocket.
from time to time, though, you'll need to compile on the device so you can ensure that the graphics look right, the game is playing at a reasonable speed, and no bugs are creeping in that aren't showing up on the emulator.
if your pocketpc is connected via activesync, you've done all that's necessary to develop for your device.
this is important because while some handhelds like the casio and the ipaq have nice little direction-pads, some like the new hp pocketpc decided to clone
this version should look instantly familiar.
the device and embedded visual c++ are constantly having to update each other as to the status of your running program.
in fact, they're almost identical to their windows-only brethren, visual c++ 6.0 and visual basic 6.0.
thankfully, switching between one approach and another is as simple as choosing the target processor on the toolbar and recompiling.
it's a great way to get your app up and running quickly, and debugging is a breeze.
to compile for the emulator, you set the target processor as the x86 ce emulator, press the "make" button, and embedded visual c++ will generate a windows ce app that runs on the x86 processor.
the device and embedded visual c++ are constantly having to update each other as to the status of your running program.
the package includes embedded visual c++, embedded visual basic, and emulators for the platforms mentioned above.
hence, if you're looking foraddatom() or getwindowword(), you won't find them.
you can change the bits as necessary and blit the buffer to the screen very quickly using the standard old bitblt() command.
