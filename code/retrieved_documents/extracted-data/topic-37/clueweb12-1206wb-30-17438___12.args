it would be far better if they incorporated less stuff in less timeframes so new standards can be released more often.
this is a discussion on c++0x concepts fall within the general discussions forums, part of the community boards category; in general, direct3d is designed to be a 3d hardware interface.
opengl, on the other hand, is designed to be a 3d rendering system that may be hardware accelerated.
no different from so many other professional areas, from accounting to scientific fields.
everything else is just unnecessary fluff share 6,998 originally posted by brafil seems like they have understood that they were making the language too complex.
so you want to do oop programming.
i may be looking at concepts as easier simply because i understand better now what generic programming is under c++.
expert programmers should not have to suffer because newbies might have a difficult time grasping all concepts.
like always using the new function definitions - looks more like pascal.
i was hoping the new standard would be finalized soon because the longer it takes the longer we have to wait for it to appear in compilers.
initializer lists can be heterogenous, and the compiler will interpret the elements as constructor arguments and do overload resolution.
i personally don't like the new function definition types nor the new typedef possibilities.
opengl, on the other hand, is designed to be a 3d rendering system that may be hardware accelerated.
in my view, this alone makes concepts a feature that reduces programming complexity already.
the feature set of direct3d is derived from the ... linkback posts 1,036 in general, direct3d is designed to be a 3d hardware interface.
one day, whe, he feels more comfortable with the language and decides to step into more complex areas of software development.
seems like they have understood that they were making the language too complex.
this is a discussion on c++0x concepts fall within the general discussions forums, part of the community boards category; in general, direct3d is designed to be a 3d hardware interface.
but hard to track bugs or hard to understand compiler reports is going to strain the coder a lot more.
the feature set of direct3d is derived from the feature set of what hardware provides.
i understand that they dropped them.
it is in my view acceptable that generic programming is accepted as being even harder.
originally posted by phantomotap "integration, especially with the library, was a very complex task, and uncovered many weaknesses, both of concepts themselves and of other language features, such as rvalue references.
it just seems, with concepts, c++ generic programming would be made easier to teach and learn.
it should also be the understanding that some jobs simply aren't as easy as others.
but hard to track bugs or hard to understand compiler reports is going to strain the coder a lot more.
it just seems, with concepts, c++ generic programming would be made easier to teach and learn.
i know the internals of only one compiler, but i can tell that while it would be possible to modify it to parse this, it would lead to some very ugly code in the parser.
i forgot how easy it was to derail threads simply by mentioning those two words.
i think that would be nice.
finally, there's the admission that conceptually c++ templates are irreprehensible, but the theoretic basis on which they were implemented in c++ is weak.
this has also a lot to do with the natural characteristic of c++ of being a modular programming language, which makes it easy to teach and learn.
the language is made harder for them and it will take a long while until all the new concepts, semantics and syntax get buried in their brain.
the way typedef works, i think it would be very hard to make template typedefs that don't look absolutely atrocious.
quiet technologies... that make some noise.
the language is made harder for them and it will take a long while until all the new concepts, semantics and syntax get buried in their brain.
it would be cheaper to just get a computer which is 25% faster.
but inm my defense i'll say that i'm in fact a newcmmer to generic programming with no more than 1 year on my back and very little to show in terms of actual work.
this has far more repercussions than just the admission we can use different tools for different jobs.
what we have now is a syntax that is somewhat easy to teach, semantics somewhat easy to learn, but the coder is left alone trying to understand template related errors messages.
it should also be the understanding that some jobs simply aren't as easy as others.
i understand that they dropped them.
the feature set of direct3d is derived from the feature set of what hardware provides.
making it easier and more powerful, even.
for a newcommer going from procedural programming to oop is a big step.
the using keyword doesn't have as much grammatical cruft attached.
c++ is already a complex language to learn and use .
many concepts are great: constexpr, rvalue references, extern templates, initializer lists, auto variable, decltype, the new for-loops, thread_local, regexes, suffixes - a nice "toy" that can be both very fun and useful the things i would reconsider: nullptr - it's not very elegant imo.
i personally don't like the new function definition types nor the new typedef possibilities.
certainly adding new features to the language while keeping a close eye on complexity is a good goal.
seems like they have understood that they were making the language too complex.
everything else is just unnecessary fluff originally posted by brafil seems like they have understood that they were making the language too complex.
this has far more repercussions than just the admission we can use different tools for different jobs.
the fact that the two apis have become so similar in functionality shows how well hardware is converging into user functionality[citation needed].
the current ones for "normal" c++ are thick enough.
the current ones for "normal" c++ are thick enough.
you can actually have a lot of fun with them.
"the internet treats censorship as damage and routes around it."
finally, there's the admission that conceptually c++ templates are irreprehensible, but the theoretic basis on which they were implemented in c++ is weak.
it is in my view acceptable that generic programming is accepted as being even harder.
so i think it's a real shame they dropped concepts, but i am very positive about every other added feature.
this is particularly damaging to library developers who suffer the most.
this has also a lot to do with the natural characteristic of c++ of being a modular programming language, which makes it easy to teach and learn.
but inm my defense i'll say that i'm in fact a newcmmer to generic programming with no more than 1 year on my back and very little to show in terms of actual work.
it was in the course of concept integration that they discovered that throwing move constructors (and moving is closely tied with rvalue refs) are completely unsafe - as with throwing destructors, if you have one, you simply cannot write exception-safe code.
what we have now is a syntax that is somewhat easy to teach, semantics somewhat easy to learn, but the coder is left alone trying to understand template related errors messages.
but then again, switching between languages often isn't good either.
i may be looking at concepts as easier simply because i understand better now what generic programming is under c++.
in my view, this alone makes concepts a feature that reduces programming complexity already.
you mean it's included as a crutch to help ancient programmers limp along without them having to relearn too much.
no different from so many other professional areas, from accounting to scientific fields.
the new typedefs and the new function definition types enhances the parts that c++ specializes in.
certainly adding new features to the language while keeping a close eye on complexity is a good goal.
in general, direct3d is designed to be a 3d hardware interface.
but it was the interaction with concepts that pointed out that it's not safe, in general, to let rvalue references bind to lvalues.
however, std::initializer_list can only represent homogenous initializer lists.
this is particularly damaging to library developers who suffer the most.
in general, the new syntax is much nicer than the arcane c syntax.
what i mean is that usually we strive to learn what it is we want to do and a language provides the facilities to do so.
a feeling that herb sutter'srecent blog post makes even stronger.
i forgot how easy it was to derail threads simply by mentioning those two words.
for a newcommer going from procedural programming to oop is a big step.
one day, whe, he feels more comfortable with the language and decides to step into more complex areas of software development.
the fact that the two apis have become so similar in functionality shows how well hardware is converging into user functionality[citation needed].
as far as i know, using is only used for copying data into namespaces.