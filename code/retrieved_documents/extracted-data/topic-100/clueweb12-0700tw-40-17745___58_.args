most importantly, use cases can be an effective tool when they are developed in a disciplined manner, as part of a methodology that first creates a well-defined domain model.the domain model provides an infrastructure for the requirements-gathering process, so that the development of use cases can proceedsystematically, in a way that could never happen without the domain model.that’s part of the reason why we — as a profession and as an industry — continue to do such a poor job of requirements gathering, and continue to have so many system failures.an important feature of any useful requirements-gathering methodology is that it provides asystematic approach to identifying all of the system requirements.the whole purpose of systems analysis methodologies, in fact, is to provide guidance for situations in which the process is not so simple and mechanical.in embedded systems, the system’s reliance on properties of the surrounding real world are very real, and can often be safety-critical.it exposes the students to the issue of ambiguity in domain descriptions, and helps me make the point that one of the requirements analyst’s most important tasks is the detection and removal of such ambiguities.as jackson points out in a recent paper, it is almost impossible for software developers to build correct software if they don’t understand the problem domain, and how what they are doing relates to what happens there.practising programmers who try to adhere to this doctrine will find themselves devoting their skills to tasks that seem at best arbitrary and at worst senseless.another reason that we start development with capturing information about the real world is there are properties of the real world that constrain the system, or that the system must know about, or that the system relies on, in order to satisfy the customer’s requirements.this is a useful technique, and one worth pointing out for the benefit of those who have not yet discovered it.we start by modeling the real world (rather than describing the functionality that we wish the system-to-be to provide) because the model supplies essential components that we need in order to create our descriptions of the system functionality.it discourages the requirements analyst from examining the problem domain, by focusing attention only on what happens at the system boundary.one of the joys of python is that python makes it so easy to do “standard loop” processing on a sequence such as a list or a string.the upside of doing step 2 is that it enables a smart cl parsing module automatically to generate user documentation for the cl language, and to dump that documentation to the screen when it finds a syntactic or semantic error in the command line, or when the command line is a request (