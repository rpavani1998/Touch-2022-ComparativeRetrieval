reply as a python user that has enjoyed doing some ruby in the past, i’m glad to see that ruby performance is improving.
reply python 2.6.2 is faster and really faster with psyco: on a intel core i7 940 (2.9 ghz) : 16s for python 2.6.2 without psyco 0.9s with psyco !!!!!
[i386-mswin32]: 120.469s ruby 1.9.1p0 (2009-01-30 revision 21907)
you can read my follow up here.
in this task boo+mono is faster than dump c app : int fib(int n) { if (n == 0
a language is fast, if the development progress is fast.
fun as that certainly was, let’s try to summarize and clarify a few points.
most ruby people i talk to think the same way.
in fact, the leading python framework (django) says in their documentation that it’s memory and not processing power that makes the difference.
and you can parallelise it for free november 29, 2007 antonio cangiano writes about how ruby 1.9 has improved in various ways, so that the naive fibonacci algorithm is [...]
click here to cancel reply.
the speedup is much more modest for more realistic tasks, and a few things are slower in 1.9.
it was one of those  tests that you do at 3 am in an irb session when you feel you’ve made  your daily peace with your actual workload for the night.
but what can be roughly said is that it seems ruby-1.9 will be faster than 1.8, and this alone is the most important difference
i think we can close the gap.
ruby è infatti notevolmente più veloce rispetto alla precedente come dimostrò uno tra
but for now, i’ll say just… wow!
reply switchbl8, my python results were confirmed by people with similar hardware to mine.
we’d see ruby 1.9.0 doing 1.7x better than python.
anyway!reply i wholeheartedly agree with you andrew.
but what can be roughly said is that it seems ruby-1.9 will be faster than  1.8, and this alone is the most important difference anyway!
but it doesnt mean,  ruby is more powerful than python.
note that jruby trunk now actually performs even better on recursive fib than ruby 1.9.reply antonio, python can calculate first 35 fibo numbers in hundreds of times faster than ruby.
lol ruby 1.9 kicks python ass.
on my workstation it takes less than 0.1 second: $ time python2.5 fibo.py real 0m0.075s user 0m0.020s sys 0m0.028s
fib :: int -> int fib i | (i == 0)
reply november 28, 2007 at 11:13 am heh, day by day, python vs. ruby is becoming more like vi/emacs wars!
but i was blown away when i timed the latest version from trunk (even if it’s a really silly example that’s being tested).
reply psyco is an impressive piece of software, but it isn’t that useful for web applications.
the test was run on mac os x 10.5 with my macbook pro (core 2  duo 2.2 ghz and 2 gb of memory).
(i don’t  get into the language wars.
i <- [0..36]] slim:desktop jorrit$ ./fib [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34),(10,55),(11,89),(12,144),(13,233),(14,377),(15,610),(16,987),(17,1597),(18,2584),(19,4181),(20,6765),(21,10946),(22,17711),(23,28657),(24,46368),(25,75025),(26,121393),(27,196418),(28,317811),(29,514229),(30,832040),(31,1346269),(32,2178309),(33,3524578),(34,5702887),(35,9227465),(36,14930352)] 0.586306 btw, that means 0.586306 seconds, what is more than 20 times faster than ruby 1.9!reply for me (windows) ruby 1.9.1 16.2s python 2.6 25s ruby crystalized [1] 4.8s enjoy.
reply [...] têm acontecido na minha universidade (mais uma vez), achei relevante o post que ele fez sobre a performance do ruby 1.9.
reply ruby 1.9 doesn’t smoke python away!
reply andrew ingram says: november 28, 2007 at 7:46 am i imagine that like many i’m skeptical about the true level of  improvement, i’m eager to see some more thorough benchmarks but still, assuming it’s not a one off thing, that’s a pretty  impressive speedup and could end up making ruby much more competitive as an  enterprise-level language.
./fibs 0.00s user 0.00s system 84% cpu 0.004 total faster, simpler, shorter.
november 28, 2007 at 8:46 am
pentium(r) iii mobile cpu 1133mhz cl-user> (defun fibo (n) (if ( (defun test () (dotimes (i 36) (format t "n=~a => ~a~%" i (fibo i))))
yet, no body even mentioned why it’s normal to have memory leak in our rails-based service so we have to restart the process every hour !!!
did ruby just go from 159 seconds down to 12?
reply i’ve also done some comparison with similar results: http://railstooge.blogspot.com/2009/01/ruby-vs-python-lame-benchmark.html dataangel: it’s not tail recursive, the last operation is the addition of the two calls to fib.
just to make sure i wasn’t crazy
see coderspiel my results (core2duo @ 2.4 ghz) antonio’s fibonacci test ruby 1.8.6 => 82.8s
for example  try to execute on your workstation: def fib(): a, b = b, a  + b f = fib() print “n=%d =>
posted on nov 28th, 2007  indjango, python, ruby, ruby on rails | 102 comments alright the title of this post is a tad sensational sounding, i know, and  it’s in part aimed at messing with my many pythonista friends.
if the ruby interpreter can execute faster than python, the python folks  will try to improve python.
reply i ran the fib test program.
follow @acangianofollow @acangiano now shipping some of the links contained within this site have my referral id (e.g., amazon), which provides me with a small commission for each sale.
reply in my computer: jdk1.6 52594/100= 0.52594s delphi7 1m05s/100= 0.65s vc6 1m11s/100= 0.71s c#(.net2.0)
this file and tests are at http://www.bitmover.com/lm/langbench.shar reply global nerdy » blog archive
“\n”; } sub fib { my $n = shift || 0; return $n if ( $n  a = fib(n – 1); b = fib(n – 2); a + breply dataangel: it’s not tail-recursive, there’s an addition after the fib(n-1) and fib(n-2) calls.
at least for now, there is no reasonable evidence to  conclude that ruby 1.9 – which will be released for this coming christmas  – will actually be faster than python 2.5.1 in the majority of  situations, but hear me out and check out these very surprising results.
reply arman says: november 28, 2007 at 9:19 am wow…ruby is getting faster compared to python.
i’m impressed by how much ruby manages to uglify simple code  snippets.
compiled strong typed languages are much better in that case, coz no runtime-detection of types needed.
it was one of those tests that you do at 3 am in an irb session when you feel you’ve made your daily peace with your actual workload for the night.
it’s probably worth pointing out that this is the test that yarv (1.9) is really optimised for, and is not a fair representation of yarvs speed at processing general ruby apps.
print “n=%d => %d” % (i, f.next())
$ cat /proc/cpuinfo | grep name model name : intel(r)
stuzzicato da un microbenchmark pubblicato da antonio cangiano sul suo blog in cui ha messo a confronto l…reply @antonio:
for example try to execute on your workstation: def fib(): a, b = 0, 1 while true: yield a a, b = b, a + b f = fib() for i in range(36):
i develop for my clients, not for sick greed.
sure, the headline was an attention grabber, just like this one is , but in a matter of a few hours, there were all sorts of blog entries with variants in many languages, more than 200 comments on reddit, and fifty comments on my own blog.
reply sapphirecat says: november 28, 2007 at 12:30 pm instead of doing all that benchmarking yourself, you should borrow someone  else’s.
-r [1] http://github.com/rdp/crystalizer with jruby experiencing a speed up of about 200% thanks to invokedynamic in java 7.02 is time to rewrite the comparison.
it’s time to show secret python weapon  – calculation of same fibonacci numbers but in 1000 times faster than  antonio’s ruby implementation.
reply she says: november 28, 2007 at 7:56 am
reply [...] holy shmoly, ruby 1.9 smokes python away!
if( $n == 0 || $n == 1 ) return $n; for( $i=0; $i #’.fib($i).”\n”; took about 74 seconds on my box using: php 5.2.3-1ubuntu6 (cli)  (built: oct 4 2007 23:35:54) irrelevant to compare to his numbers but looks like it’s slow  compared to the new ruby or python.
i primi test pubblicati da antonio
fica, como resumo, os resultados obtido comparando a função de fibbonacci [...]
here’s an erlang version: fib(n) -> fib(n, 1, 0).
cl-user> (defun fibo (n) (declare  (optimize speed (safety 0)
building websites unfortunately include other processing operations and even more complicated not to mention file access, networking and string manipulations … i would love to see more about such benchmarks tests performed for realistic operations ..
n == 1) { return n; } else { return fib(n-1) + fib(n-2); } } int main(char* argv, int argc) {
looks like ruby’s function call overhead might be less than  python’s?
currently i’m working with rails and found its serious memory leak problem, but django a kind of python’s framework doesn’t have such problem.
[root@diego ~]# i develop to get paid.
i don’t think there’s that much conflict between the ruby and python communities.
–j. november 28, 2007 at 12:04 pm and how about php 5 for good measure?
they might include optimization later, but that’s not there yet.
it’s time to show secret python weapon – calculation of same fibonacci numbers but in 1000 times faster than antonio’s ruby implementation.
not bad considering jruby doesn’t have any integer math optimizations like ruby 1.9 does.
reply november 28, 2007 at 1:47 pm wowowow !!!
november 28, 2007 at 11:21 am ech, python 2.4.4 + psyco gives: 2.5 sek reply november 28, 2007 at 11:23 am on my pc, python takes 20 secs without psyco.
can you  post a link where this is documented? reply xtian says: november 28, 2007 at 7:03 am bruno, i thought it might have been that at first, but the recursive calls  aren’t tail calls.
in example above i took “boo” – compileable (you can use booi – iterpreter-like version as well) strong-typed (but you can use non-strong-typed constructs – slower) language with python-like syntax.
style-warning: redefining test in defun cl-user> (time (test))
as soon as you start swapping, you’re toast.
i ruby 1.9, rulând o func?ie care calculeaz?
http://blog.jruby.org/2011/12getting_started_with_jruby_and_java_7/ also in hacker news: http://news.ycombinator.com/item?id=3372816 python on pypy did this in 4.074s and in 17 secs on the same machine.
also, ruby never had any tail recursion.
does ruby1.9 give you built in unicode support?
but indeed, the speed-up between ruby 1.8 and 1.9 is, well… wow !-) reply november 28, 2007 at 6:37 am what about psyco?
here are my results for another pair of languages: python 2.5 0m15.657s gnu smalltalk 2.95f 0m4.594s [...] following a series of posts that started with this one, moved to this one and, so far, has reached this one.
i wasn’t planning to make a post about it.
fib(0, _, result) -> result; fib(n, next, result) -> fib(n – 1, next + result, next).
realistic comparisons are very hard to do, and that’s why you’ll see very few of them floating around.
reply toreau says: november 28, 2007 at 2:05 pm bad choice of a benchmark, as the fibonacci function can be cached.
(if (or (eql n 0) (eql n 1)) n (+ (fib (- n 1)) (fib  (- n 2)))))
it is extremely fast, is unlikely to have bugs, and did not take long to code: # glen’s benchmark algorithm: ans =
i’m impressed by how much ruby manages to uglify simple code snippets.
andrew: yes, the above code *is* run through the vm (ruby 1.9 doesn’t have an ast walker anymore).
so python (in this case) on my system is about 120 times faster than ruby, how can yours only be 6 times faster?
notify me of new posts by email.
by the way, i don’t really understand how you can improve a language to make it 15 times speeder on so simple script… 8| let’s take good news without too many questionsreply nevermind that 1.9 comes with a vm… isn’t it possible the code is compiled to bytecode and then run through the vm?reply bad choice of a benchmark, as the fibonacci function can be cached.
it’s a single test (which is obviously not a real world example, as you would use an iterative version of the function if it were), and unlike with real programs, it doesn’t stress many features of the language.
i’m happy to see ruby getting some much needed optimization.
reply dima dogadaylo says: november 28, 2007 at 10:26 am antonio, python can calculate first 35 fibo numbers in hundreds of times  faster than ruby.
[...] evaluation took: 2.129 seconds of real time 1.948121 seconds of user run time 0.0 seconds of system run time 0 calls to %eval 0 page faults and 179,528 bytes consed.
>>> d={} >>> def fib(n): … if n==0 or n==1: … return n … if d.has_key(n): … return d[n] … else: … temp = fib(n-1)
wars!reply this just goes to prove how crap python is.
reply [...] 6.8 smokes python and ruby away!
reply oliver says: november 28, 2007 at 7:10 am
http://psyco.sourceforge.net/ there are lies, damn lies and benchmarks…reply does ruby 1.9 optimize tail recursive calls?
» take the new ruby for a spin  says: november 28, 2007 at 1:28 pm [...] real point to take from antonio cangiano’s article, holy  shmoly, ruby 1.9 smokes python away!, is not that ruby 1.9 runs circles around  python, but that ruby 1.9’s performance appears to [...] reply november 28, 2007 at 1:29 pm ruby 1.9 doesn’t smoke python away!
inspire the wrong kind of reactions.
n == 1 n else fib(n-1) + fib(n-2)
done with python 2.5.1 on 64bits ubuntu.
haskell, ruby smackdown november 30, 2007 antonio cangiano writes about how the new and improved ruby 1.9 is actually faster than python for a fibonacci [...]
i was expecting a decent improvement,  as i’ve been playing with 1.9 every now and then for a long time –
test descriptions: cat copy stdin to stdout grep match a regular  expression against stdin, print each match hash use each line of stdin as  a hash key, value is 1.
we (bitmover) are using it to benchmark our scripting language, you can use it for whatever you like.
(i don’t get into the language wars.
it’s going to be fun.
i’ve found on the page http://antoniocangiano.com/2007/11/2…s-python-away/ a discussion about the performance differences between several languages (ruby, perl, python…) to [...]
does ruby1.9 give you built in unicode support?reply heh, day by day, python vs. ruby is becoming more like vi/emacs
this post mostly pokes fun at python programmers regarding the ruby 1.9 improvements.
do |i| puts "n=#{i} => #{fib(i)}" end and the python equivalent: def fib(n): if n == 0 or n == 1: return n else: return fib(n-1) +  fib(n-2) for i in range(36): print "n=%d =>
*of course* iterative or memoized algorithms are way faster.
fib(n-2) end end 36.times do |i| puts "n=#{i} => #{fib(i)}" end and the python equivalent: def fib(n): if n == 0 or n ==
reply that function can most certainly be made tail recursive.
the result shows ruby 1.9.1 on windows took 50s instead of 12s: ruby 1.8.6 (2007-03-13 patchlevel 0)
reply i sincerely welcome and appreciate your comments, whether in agreement or dissenting with my article.
1: return n else: return fib(n-1) + fib(n-2) for i in range(36): print "n=%d =>
right language for right job.
reply a faster algorithm,using python,0.6 sec.
koichi sasada, do you have an amazon wishlist?
there were however, also a few misconceptions.
there is a semantic difference between discussing a language itself, it’s syntax, it’s standard [...]
during this year’s rubyconf keynote, matz unbuttoned his shirt to show he was wearing a python shirt underneath so there can’t be that much conflict: http://www.flickr.com/photos/john_lam/1910968816/ maybe there’s some friendly rivalry, but that only helps everyone improve.
and difference will be much more in big apps.
if you want to make python look really bad, you can do as peter norvig and use python lists for matrix multiplication (http://norvig.com/python-lisp.html ).
python is the best solution for my current  situation, but i admire ruby.)
i guess having a compiler (which can compile things entered interactively!)
for i in range(1,n): c = a + b b = a a = c if a  “) .
show a ++ c ++ show b; fibs = 0 : 1 : zipwith (+) fibs (tail fibs)
so i’m curious as to why people would still prefer languages without one.
int i; for (i = 0; i %d\n", i, fib(i)); } } ./test_fib
i guess having a compiler (which can compile things entered interactively!) is a bit of an advantage.
http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=all&lang=yarv&lang2=python does anyone know how to increase the stack size in ruby 1.9.0 – there’s an unhappy program - http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=recursive&lang=yarv&id=2#logreply and for cold reality itself: #include unsigned long fib(int i) { if (i == 0
išskir?iau greitaveik?, bei [...]
is a bit of an advantage.
jruby 1.1b1 => 13.9s ruby 1.9 =>
it allowed him to write blog entry titled “holy shmoly, ruby 1.9  smokes python away!”.
reply python has very slow recursion performance just today i read a post from antonio showing how big of an improvement ruby …reply reality check: c# 1.4 secs.
antonio cangiano compared execution time of recursive fibonacci function  written in python and ruby 1.9 and found that ruby variant was almost 3 times  as fast.
holy shmoly, ruby 1.9 smokes python away!
thank you for your support.
my post about ruby 1.9’s impressive improvement over ruby 1.8.6 created quite an echo within the developer community.
reply wow…ruby is getting faster compared to python.
as you can see in this traditional fibonacci task boo is 40 times faster than python.
reply i’m wondering about the memory usage.
we rubyists have been teased for a long time, due to the slowness of the main ruby interpreter.
http://psyco.sourceforge.net/ november 28, 2007 at 6:39 am there are lies, damn lies and benchmarks… reply christian says: november 28, 2007 at 7:03 am does ruby 1.9 optimize tail recursive calls?
i | otherwise = fib (i-1) + fib (i-2)
if i manage to find some time, i will report the results in this blog.
and that depends mostly on the programmer.
imo titles like “ruby 1.9 smokes python away!”
python is the best solution for my current situation, but i admire ruby.)reply i imagine that like many i’m skeptical about the true level of improvement, i’m eager to see some more thorough benchmarks but still, assuming it’s not a one off thing, that’s a pretty impressive speedup and could end up making ruby much more competitive as an enterprise-level language.
n == 1 n else fib(n-1) +
using  the memoize module in perl, i can perform the same calculation in 0.024 seconds  on my athlon64 3700+; #!/usr/bin/perl
manages to knock python out of the water – and where python has still the  edge.
it’s a single test (which is obviously  not a real world example, as you would use an iterative version of the function  if it were), and unlike with real programs, it doesn’t stress many  features of the language.
comments are automatically closed 15 days after the publication of each article.
the point i am trying to make, is that real-world performance has very little to do with the speed of the python or ruby interpreter measured in micro-benchmarks.
so i knew it was faster – but i was blown away when i timed the latest  version from trunk (even if it’s a really silly example that’s  being tested).
alright the title of this post is a tad sensational sounding, i know, and it’s in part aimed at messing with my many pythonista friends.
well of course i am biased since i use ruby and not python (but i never can  understand a conflict between ruby and python, i am always saying to join up to  beat on common enemies… perl and php and of course legacy shell scripts  or solutions especially if they use perl )
[i386-mswin32]: 49.218s how to explain this?
thanks for sharing, i hope to do some benchamarks between  1.8 and 1.9 reply ola bini says: november 28, 2007 at 10:24 am first, ruby 1.9 has tail call analysis, but doesn’t use it for  anything right now.
a honest haskel comparison (same algoritm), but it can be a lot faster (as shown by twey).
it’s funny that this post was written a year ago but there still isn’t any stable version of ruby 1.9.reply http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ruby&lang2=pythonreply psyco vs yarv http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=psyco&lang2=yarv memory usage psyco =
it allowed him to write blog entry titled “holy shmoly, ruby 1.9 smokes python away!”.
just out of curiosity i decided to run a single benchmark (you can hardly call it that) to see how ruby 1.9 had improved over the current stable version (1.8.6).
real 0m0.271s why all performance tests are all about recursive fibonacci ..
reply it is really goo to hear that as one of my main concerns today is ruby’s speed!
here the benchmark is on *function calls*, not on generating fibonacci numbers.
general performance improvement for 1.9 is looking to be about 150% to 200% for most applications, based on more real world test cases.
this file and tests are at http://www.bitmover.com/lm/langbench.sharreply [...] real point to take from antonio cangiano’s article, holy shmoly, ruby 1.9 smokes python away!, is not that ruby 1.9 runs circles around python, but that ruby 1.9’s performance appears to [...]
it would still be anecdotal evidence, but at least it would be  more than just one microbenchmark.
but it doesnt mean, ruby is more powerful than python.
so how can yours run for 31 seconds?
it is really goo to hear that as one of my main concerns today is  ruby’s speed!
ruby 1.9 doesn’t smoke python away!
really a beautiful christmas present it seems !
i’m a ruby guy, but i think python is a beautiful language..
(btw, what is python?)reply ech, python 2.4.4 + psyco gives: 2.5 sekreply on my pc, python takes 20 secs without psyco.
[...]reply a very fast fib snippet in ruby: fibonacci numbers in ruby http://snippets.dzone.com/posts/show/3562reply [...] reading this article comparing the new ruby 1.9 to it’s older version and python, i though it would be interesting [...]
[...] reply greg graham says: november 28, 2007 at 7:26 am as a python user that has enjoyed doing some ruby in the past, i’m  glad to see that ruby performance is improving.
the performance is mainly because of special handling of fixed point maths  by new vm that ruby 1.9 provides….
are you sure you have just cut and pasted my snippet without altering anything?
iterative versions of the same script run in well under a second, this is true for both ruby and python, but the recursive one (without psyco or memoization) shouldn’t.
reply for the record, java 1.6 u10 does it in….
reply ruby1.9 vs python 2.5.1 « andrei maxim says: november 28,  2007 at 7:12 am [...] 28, 2007 in nout??itags: python, ruby19 antonio cangiano a f?cut un  mic test cu python 2.5.1 ?
reply martin vilcans says: november 28, 2007 at 12:16 pm that’s an impressive speedup, but of course it just tests one little  special case (a.k.a.
i don’t have ruby 1.9, but 1.8.6 runs about two minutes, that’s approx.
if the ruby interpreter can execute faster than python, the python folks will try to improve python.
reply del ben oscar says: november 28, 2007 at 10:12 am that’s cool
lang cat grep hash loop proc sort wc pl 0.35 0.36 0.63 0.11 0.30 2.03  1.03 py 0.37 1.08 0.46 0.18 0.17 1.83 0.48 rb 0.83 0.86 1.98 0.31  0.52 3.32 2.29 rb-snap 0.74 0.79 1.39 0.04 0.06 3.04 1.44 tcl 0.97  0.78 1.24 0.07 0.24 3.76 0.97 l 1.01 0.78 1.32 0.07 0.24 4.15 1.60 here’s the langbench readme:
in java it took around 0.4 sec while in groovy it took 22 seconds ..
so, you might be cutting down some milliseconds off each request once that request gets heard, but you might also be dramatically increasing the time before an apache process actually deals with a specific request.
benchmarks just tend to tell lies.
reply sturla, no one is disputing that.
why don’t you go to the computer  language shootout (http://shootout.alioth.debian.org/) and test all of their  microbenchmarks.
[1..] fibs where join c (a, b) =
bruno says: november 28, 2007 at 6:13 am i guess the difference between ruby 1.9 and python 2.5 mostly may comes  from python not optimizing tail-recursive calls (which btw is a design choice  wrt/ ease of debugging, not a technical flaw).
it only goes up to f(35).
reply leonardo says: november 28, 2007 at 8:39 am
reply not so sure whether your point of view is specific for recursive function or not?
python 2.5.1: 54s i like toreau pointing out that algorithmic consideration can have a huge effect, especially when folks are in the ‘yeah, well my obscure language of choice does it in n secs’ mode.
well of course i am biased since i use ruby and not python (but i never can understand a conflict between ruby and python, i am always saying to join up to beat on common enemies… perl and php and of course legacy shell scripts or solutions especially if they use perl )
in the company i’m working with now, we invested more than 2 years developing a social network service using rubyonrails, and the overall performance is killing us …
general performance improvement for 1.9 is looking to be about  150% to 200% for most applications, based on more real world test cases.
a f?cut un mic test cu python 2.5.1 ?
can you post a link where this is documented?reply bruno, i thought it might have been that at first, but the recursive calls aren’t tail calls.
quick numerical benchmark of ruby 1.9
tail-recursion kicks in, only when your procedure is recursive, but process is  iterative.
at least in this one instance, jruby was faster than python [not psyco, mind you, which no one has yet written an equivalent for ruby ] http://shootout.alioth.debian.org/u32q/benchmark.php?test=fannkuch&lang=all so that’s good.
the test was run on mac os x 10.5 with my macbook pro (core 2 duo 2.2 ghz and 2 gb of memory).
[0, 1, 1] except indexerror: fibo.seq.append( fibo.seq[-2] + fibo.seq[-1] )
http://www.mysoftparade.com/blog/ruby-19-doesnt-smoke-python-away/ dataangel says: november 28, 2007 at 1:45 pm @gnufied: why isn’t it tail recursive?
14s121/10= 1.4121s python2.5 52s ruby1.86 2m24s [...] announcing publicity – a brand new language designed to smoke any other language out there.
=> 1 n=2 => 1 … n=34 => 5702887
reply [...] nauja, stabili ruby versija.
i suppose -?- that the interpreters i talk about below are coded in c)…
when i saw the  results though, my jaw dropped.
date; public class test3 { public static void main(string[] args) { system.out.println ("hello"); long s = new date().gettime(); for(int i=1; i println "n=${i} => ${fib(i)}" } e =
reply november 28, 2007 at 9:46 am python has very slow recursion performance just today i read a post from antonio showing how big of an improvement  ruby … reply november 28, 2007 at 10:04 am reality check: c# 1.4 secs.
i am not impressed by the results of this micro-benchmark (probably because i’m well-informed regarding ruby 1.9); it’s always been well-known that 1.9 can be over 5 times faster than ruby 1.8 in such simplistic tests (in this case, the gains come mainly from the integer op optimizations introduced in yarv).
the ruby code: def fib(n) if n == 0
well, it looks like with ruby 1.9, it’ll be payback time.
if you enjoyed this post, then make sure you subscribe to my newsletter  and/orfeed.
fibseq :: [(int, int)] fibseq =
for comparisons amongst ruby implementations, i’ve started a ruby benchmark suite that’s aimed at being somewhat realistic.
just out of curiosity i decided to run a single benchmark (you can hardly call  it that) to see how ruby 1.9 had improved over the current stable version  (1.8.6).
so i guess you can create slow programs with python too, didn’t know that..
7.734 seconds of real time 7.176449 seconds of  user run time 0.004 seconds of system run time 0 calls to %eval
(in-package #:cl-user) (defun fib (n) (declare (optimize (speed 3) (space 0) (safety 0) (debug 0)))
by the way, i don’t really understand how you can improve a language  to make it 15 times speeder on so simple script… 8| let’s take good news without too many questions reply november 28, 2007 at 1:57 pm nevermind that 1.9 comes with a vm… isn’t it possible the code is compiled to bytecode and then run  through the vm?
the next sensational headline supported by an artificial benchmark.
reply “mmmm.. yes fascinating,” he mumbles as he switches back to his vim window editing c source.
(btw, what is python?)
temp … return temp … >>> for i in range(36): … print “n=%d => %d” % (i, fib(i))
never try to compare interpreting languages in many-function-call-tasks.
reply november 28, 2007 at 11:20 am this just goes to prove how crap python is.
reply jan rychter says: november 28, 2007 at 11:57 am well, since you’re comparing high-level languages… i quickly  coded a silly implementation in common lisp.
reply for macbook pro, 2.2ghz, leopard 10.5.1: ruby 1.8.6: 50s ruby1.9 edge: 12s jruby edge: 45s jruby edge -j-server: 20s jruby edge -j-server -j-djruby.compile.frameless=true: 18s python 2.4.4: 30s python 2.4.4 + psyco: 1.8s (sic!)
reply ruby test_fib.rb 62.25s user 8.15s system 99% cpu 1:10.85 total python test_fib.py 23.90s user 0.00s system 99% cpu 23.912 total booi test_fib.boo 1.12s user 0.02s system 99% cpu 1.141 total (now prepare to be shocked)
looks like ruby’s function call overhead might be less than python’s?reply bruno: that function can’t be optimized by tail-recursive calls.
=> 0 n=1 => 1 n=2 => 1 … n=34 => 5702887 n=35 => 9227465 real 0m15.056s user 0m14.868s sys 0m0.086s [root@diego ~]# time python test.py n=0
nasa uses python to process image data from hubble.
however, trolling will not be tolerated.
reply chris khoo says: november 28, 2007 at 8:26 am “mmmm.. yes fascinating,” he mumbles as he switches back to his  vim window editing c source.
loop measure the cost of a loop proc measure  procedure call cost sort sorts stdin to stdout wc implements wc in a  hand coded way input data is a million lines of code generated like this: for i in 1 2 3 4 5 6 7 8 9 0
you just need to use right tools for right tasks.
on my workstation it takes less than 0.1 second: $ time python2.5  fibo.py november 28, 2007 at 11:00 am yay, now you just need to take it to the next level.
with psyco, only 1.5 secs!reply well, since you’re comparing high-level languages… i quickly coded a silly implementation in common lisp.
(time (loop for i from 0 to 35 do (format t “~a => ~a~&” i (fib i)))) ; cpu time (total) 920 msec user, 10 msec system ; real time 924 msec this is on the same type macbook pro that you’ve used, where the python version takes 31s.
new date() println e.gettime() - s.gettime() took: 22 secreply
[...] evaluation took: 7.734 seconds of real time 7.176449 seconds of user run time 0.004 seconds of system run time 0 calls to %eval 0 page faults and 212,424 bytes consed.
[root@diego ~]# time
doing the same thing when it comes to comparing two different languages however, leaves much more room for error.
n=35 => 9227465 real 0m42.697s user 0m42.107s sys 0m0.165s
at least for now, there is no reasonable evidence to conclude that ruby 1.9 – which will be released for this coming christmas – will actually be faster than python 2.5.1 in the majority of situations, but hear me out and check out these very surprising results.
but in this version, to call fib() on every number from 0 to 35 means that we are measuring 78,176,300 function calls.
using the memoize module in perl, i can perform the same calculation in 0.024 seconds on my athlon64 3700+; #!/usr/bin/perl # use strict; use warnings; use memoize; memoize( ‘fib’ ); for ( 0..36 ) { print $_ .
do cat tcl/generic/*.[ch]
name (required) mail (will not be published) (required)
i guess the difference between ruby 1.9 and python 2.5 mostly may comes from python not optimizing tail-recursive calls (which btw is a design choice wrt/ ease of debugging, not a technical flaw).
you have an excellent cpu there, but running the python script in under a second seems like an unrealistic result.
i used: #!/usr/bin/env python def fib(n): return fib_r(0, 1, n) def fib_r(cur, next, rem): if rem == 0: return cur else: return fib_r(next, cur + next, rem - 1) for i in range(36): print "n=%d =>
a common enough mistake.
one of the technologies i’ve been examining lately which groovy /
copyright (c) 2007 by bitmover, inc. you may use for any purpose  provided that if you use the “langbench” name you report all  results for all languages like so: langbench version 0.5 results: lang cat grep hash loop proc sort split pl 0.85 0.85 1.38 0.24 0.68 4.72 5.13 py 0.81 2.97 1.03 0.34 0.40  4.37 1.56 rb 1.81 1.68 4.18 0.53 1.04 8.00 3.66 tcl 2.02 1.45 2.44  0.13 0.72 7.48 3.93 l 2.02 1.48 2.43 0.12 0.73 8.11 3.94 with the exception that you may leave off the l language until it is widely distributed (defined as apt-get install l).
no one reported a significantly lower number than what i got.
granted python is not the fastest language out there, but ruby  1.9 was still able to execute the script almost 3 times as fast.
%d" % (i, fib(i)) instead of yours.
as the psyco webiste says, it uses a lot of memory.
this means c is slow, python and ruby are fast.
i just simply code it as below: def fn(n): a
update holy shmoly, ruby 1.9 smokes python away!
on the other hand, i could make python with numpy do wavelet transforms a lot faster than matlab.
yarv faster psyco > yarvreply interesting.
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465] for x in ans: print x hoppinjohns: computers have different processor speeds and capabilitiesreply [...] reading this article comparing the new ruby 1.9 to it’s older version and python, i thought it would be [...]
è previsto intorno a natale e con il passare dei giorni la curiosità dei rubyisti si fa sempre più intensa.
for calculating the first 36 fibonacci numbers, i found this to be 6 orders of magnitude faster, i.e. giving a speedup by a factor of a million: def fibo(n): while 1: try: return fibo.seq[n] except attributeerror: fibo.seq =
reply november 28, 2007 at 7:57 am i wholeheartedly agree with you andrew.
paolo, both programs compute up to f(35).reply i’m not sure how much slower a core2duo 2.2ghz is than a amd x2 6000+, but on my system the python version finishes in well under a second.
reply that’s cool thanks for sharing, i hope to do some benchamarks between 1.8 and 1.9reply first, ruby 1.9 has tail call analysis, but doesn’t use it for anything right now.
koichi  sasada, do you have an amazon wishlist?
salem, this is not a realistic benchmark; i program in, and love, both ruby and python.
i checked wikipedia and it says a tail recursive is when the last instruction is a recursive call, which those defs of fib fit.
(as tempting as they are, catchy headlines are best avoided if you care about the quality of the discussion more than about the number of visits.)reply hey friends.
reply nice that a couple of people mentioned the benchmarks game, looking at the recursive benchmark
on my system, jruby finishes in about 23 seconds to ruby 1.9′s 13 seconds.
ruby 1.8.6: 158.869s python 2.5.1: 31.507s ruby 1.9.0: 11.934s
reply a trivial translation to ocaml let rec fib n =
this means c is  slow, python and ruby are fast.
running the snippets above, i got the following results: ruby 1.8.6: 158.869s
granted python is not the fastest language out there, but ruby 1.9 was still able to execute the script almost 3 times as fast.
it was great though because such a simple post generated a lot of discussion amongst developers, with some insightful arguments taking place – and besides it almost created a new meme with the whole “holy shomly” thing.
but i’m more then happy, that ruby is getting faster, even though i  turned away from it and back to my beloved python.
so i’m curious as to why people would still  prefer languages without one.
i like python because the standard library is great and it has built in unicode support.
a good choice of algorithm is far more important than language implementation.
google uses python to run youtube.
i ran a recursive fibonacci function, just to stress test a bit of recursion and method calling, and while i was at it, i decided to compare it with python too.
antonio cangiano compared execution time of recursive fibonacci function written in python and ruby 1.9 and found that ruby variant was almost 3 times as fast.
[...]reply ahem, your ruby program does *not* compute f(36)
(in-package #:cl-user) (declare (optimize (speed 3) (space 0) (safety 0)  (debug 0)))
yay, now you just need to take it to the next level.
in java: import java.util.
note that jruby trunk now actually performs even better on recursive fib  than ruby 1.9.
claims that “python or ruby is so slow”, and that “c++ or java is so much faster”, have in 99% of the cases more to do with bad programming than the platform.
if not that so, but just only fibonacci calculation, i’ll wonder why you have to make things complicated?
now it’ll be very interesting to run a series of algorithmically  equivalent tests for ruby and python, and to see just when exactly ruby 1.9
reply november 28, 2007 at 7:03 am bruno: that function can’t be optimized by tail-recursive calls.
so you have proven it takes 31.5 seconds to calculate 36 fibonacci numbers in python 2.5.1 if you use the dumbest possible algorithm (exponential complexity).
for those who misunderstood the purpose of the benchmark and suggested iterative, tail-recursive, or memoizing algorithms, i respectfully suggest that this is a better algorithm.
booc test_fib.boo; time mono test_fib.exe 0.76s user 0.00s system 99% cpu 0.768 total test_fib.boo: def fib(n as int) as int: if n == 0 or n == 1: return n else: return fib(n-1) + fib(n-2) for i in range(36): res = fib(i) print "n=${i} => ${res}" what i want to say?
(time (loop for i from 0 to 35 do (format t “~a =>  ~a~&” i (fib i)))) ; cpu time (total) 920 msec user, 10 msec system ; real time 924 msec this is on the same type macbook pro that you’ve used, where the  python version takes 31s.
that means fewer server processes listening to requests.
-o6 -o fib fib.c 0.339 seconds.
that’s almost 1 second for every fib-number.
in fact i think jruby is “almost as fast” as 1.9 @peke a “stable” 1.9 version is slated for february, i believe.
reply [...] 28, 2007 in nout??itags: python, ruby19 antonio cangiano
so i’m not sure ruby 1.9 is much faster than python; however it is impressive compared to ruby 1.8.
groovy as a scripting language is slower than ruby, however, taking in the whole stack (grails) it’s considered more scalable than rails by all means, and this is what i really care about ..
0.95s user 0.00s system 99% cpu 0.957 totalreply @vadim, multi-processor is the key, but there are many many implementations of stuff that will just lead you down an ultimately blind alley.
anyway, i still love php.
the thing that really matter is how python or ruby performs in the real world.
but indeed, the speed-up between ruby 1.8 and 1.9 is, well… wow !-)reply
python 2.5.1 : 31.507sruby 1.9.0: 11.934s ehm, hold on a second!
but i’m more then happy, that ruby is getting faster, even though i turned away from it and back to my beloved python.
receive my posts by email close 102 responses to “holy shmoly, ruby 1.9 smokes python away!”
http://www.mysoftparade.com/blog/ruby-19-doesnt-smoke-python-away/reply @gnufied: why isn’t it tail recursive?
8.7s numerical test from http://numericalruby.com/2007/11/28/quick-numerical-benchmark-of-ruby-19/ ruby 1.8.6 => 111.8s jruby 1.1b1 => 48.8s ruby 1.9 => 44.5s so ruby1.9 is about 2 – 10 times faster than ruby1.8reply @luke: later today i’ll publish “the great ruby shootout”.
we  rubyists have been teased for a long time, due to the slowness of the main ruby  interpreter.
the performance is mainly because of special handling of fixed point maths by new vm that ruby 1.9 provides….reply
also, if you haven’t seen it already, check charles’ post about jruby and this particular benchmark: http://headius.blogspot.com/2007/11/java-6-port-for-os-x-tiger-and-leopard.html $0.02, enjoy.
in a world where memory is more the constraint than cpu, psyco does more harm than good.
with psyco, only 1.5 secs!
yra labai daug, iš j?
just to  make sure i wasn’t crazy i checked wikipedia and it says a tail recursive  is when the last instruction is a recursive call, which those defs of fib fit.
they might include optimization later, but that’s not  there yet.
i was expecting a decent improvement, as i’ve been playing with 1.9 every now and then for a long time – so i knew it was faster –
reply in java: 0=>0 1=>1 2=>1 3=>2 4=>3 5=>5 6=>8 7=>13 8=>21 9=>34 10=>55 11=>89 12=>144 13=>233 14=>377 15=>610 16=>987 17=>1597 18=>2584 19=>4181 20=>6765 21=>10946 22=>17711 23=>28657 24=>46368 25=>75025 26=>121393 27=>196418 28=>317811 29=>514229 30=>832040 31=>1346269 32=>2178309 33=>3524578 34=>5702887 35=>9227465 time=484ms [...] are being generated to make “your religion language” look good against others (usually by misusing the language you want to bash).
for one, i wouldn’t touch anything that furthers microsoft’s interests.
because you don’t care so much about speed increases as you do memory usage when it comes to web applications.
tail-recursion kicks in, only when your procedure is recursive, but process is iterative.
to save you the bother of reading these the [...]
results: real 0m0.048s user 0m0.012s sys 0m0.016s using your script the results are about as slow as everybody elses: real 0m24.502s user 0m23.837s sys 0m0.496s
thomas güttler says: november 28, 2007 at 11:12 am a language is fast, if the development progress is fast.
now it’ll be very interesting to run a series of algorithmically equivalent tests for ruby and python, and to see just when exactly ruby 1.9 manages to knock python out of the water – and where python has still the edge.
cl-user> (defun fibo (n) (declare (optimize speed (safety 0) (debug 0))
(if (or (eql n 0) (eql n 1)) n (+ (fib (- n 1)) (fib (- n 2)))))
style-warning: redefining test  in defun cl-user> (time (test))
langbench is a simplistic set of microbenchmarks designed to see how well a scripting language performs at basic operations.
where you could make your program run tree times faster by changing the vm from python to ruby, you could have made it a million times faster by changing the algorithm.
(if  ( (time (test)) 2.129 seconds of real time 1.948121 seconds of  user run time 0.0 seconds of system run time 0 calls to %eval
and compiled languages does not need to be complex and heavy to learn.
yes i can create a blog in 20 minutes, but i spend more than 20 days just tweaking and struggling for little performance gain ..
pentium(r) iii  mobile cpu 1133mhz cl-user> (defun fibo (n) (if ( (defun test () (format  t "n=~a => ~a~%" i (fibo i))))
i had to blog about this one.
–j.reply and how about php 5 for good measure?
reply microbenchmark: ruby 1.9.0 contro tutti (… non proprio…) il rilascio di ruby 1.9
i like python because the standard library is great and it has built in  unicode support.
website notify me of follow-up comments by email.
ruby memoize version looks like the perl version, minus some line noise and shifting and such cool things (although both have been my obscure language of choice at various times): require “memoize” def fib(n) return n if(n  ahem, your ruby program does *not* compute f(36) it only goes up to f(35).
there’s something wrong with your system or your python for sure.
if n=0 || n=1 then n else fib (n-1) + fib (n-2);; for n = 0 to 35 do printf.printf “n=%d => %d\n” n (fib n); done;; runs 100 times faster than python python 0m41.993s ocaml 0m0.455s
return 1; return fib(i – 1) + fib(i – 2); } int main() { int i = 0; for (i = 0; i %ld\n”, i, fib(i)); return 0; } gcc
i ran a recursive fibonacci function, just to stress test a bit of  recursion and method calling, and while i was at it, i decided to compare it  with python too.
when i saw the results though, my jaw dropped.
have a look on the pentium-4 sandbox of the famous computer  language shootout:http://shootout.alioth.debian.org/ reply larry mcvoy says: november 28, 2007 at 12:36 pm we’ve got a little set of test cases for various languages (including  a new one we’ve built for internal use but are releasing as open source  in case anyone else wants to play with it) and the results are improved but  nowhere near as impressive as this thread implies.
if you enjoyed this post, then make sure you subscribe to my newsletter and/orfeed.