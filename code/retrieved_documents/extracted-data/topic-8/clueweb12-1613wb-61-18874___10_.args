indeed, php is flexible enough to build-up arrays in the memory without knowing their size in advance.such an algorithm that is capable of sorting data in linear o(n) time is radix sort and the domain of the input is restricted – it must consist only of integers.on the other hand, quicksort is considered one of the best general purpose sorting algorithms, but while it’s a great algorithm when the data is randomized, it’s practically as slow as bubble sort when the input is almost or fully sorted.indeed,insertion and bubble sort are considered slow, with a best-case complexity of o(n2), but they are quite effective when the input is fairly sorted.it’s easy to understand and implement even a beginner can understand and implement radix sort, which is great.we saw that general purpose sorting algorithms like insertion sort, bubble sort andquicksort can be very efficient in some cases and inefficient in others.even a beginner can understand and implement radix sort, which is great.so, when you have a sorted array and you add some “new” values to the array you can sort it quite effectively with insertion sort.for input that is almost sorted, insertion sort may be preferred instead of quicksort, which is generally a faster algorithm.new relic provides the resources and best practices to help you monitor these applications.so practically there are lots of cases of sorting integers, so radix sort may be one very, very useful algorithm and it is so cool that it is also easy to implement.fortunately, modern programming languages and libraries are more flexible so we can initialize our temporary array even if we don’t know the interval of input values, as in the example bellow.this algorithm is very useful in practice because in practice we often sort sets of integers.because the input is so important for an algorithm's efficiency, we may ask if there are any sorting algorithms that are faster than o(n.log(n)), which is the average-case complexity for merge sort and quicksort.that is a great benefit in performance compared to o(n.log(n)) or even worse with o(n2) as we can see in the following chart.