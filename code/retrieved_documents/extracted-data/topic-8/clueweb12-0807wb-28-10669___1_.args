because of its focus on readability, it actually can be used to write functional programs are much more readable by a large mass of programmers than most of the functional programming languages themselves (readability being subjectively interpreted by me as what is most natural for english or similar language speaking people).its an extremely unpredictable environment which has resulted in a number of how-to’s for safe threaded programming using constructs such as locks, mutexes etc.python is probably the most productive language i have worked with (across a variety of different types of programming requirements).a function is said to be referentially transparent if its invocation can be substituted by the return value in a program without impacting the program in any other way.add to that the fact that python is a language thats extremely easy to learn, suffers from excellent readability, has fairly good web frameworks such asdjango, has excellent mathematical and statistical libraries such asnumpy, and cool network oriented frameworks such as twisted.some of the nice benefits (i am tempted to say side effects) of functional programming are : python is not the best functional programming language.in general because of fewer side effects, testing under functional programming is often a lot easier, and the importance of having to do “integration” testing and “module” testing is lesser since testing functions in isolation is likely to identify most issues, far more than in typical imperative programming.this is to demonstrate how python treats attributes and functions virtually identically consistent with theuniform access principle.to further make it easy i re-represent the same function below differently which is much more readable and easier to understand.because a data structure once constructed will not be modified and because the source of the modifications can be clearly located to the function which instantiated the datastructure, the unpredictability of data changing right under you is gone.similarly during debugging you need to be able to quickly locate the function likely to have the problem, after which you can easily focus on the function to be able to quickly resolve the issue.in an imperative environment, you not only have to deal with data structures being modified in place by some other parts of the program, in a threaded environment such modifications can happen using peer threads, even as your current thread whose logic you are focusing on is attempting to exercise that logic.this is a must read article which provides the reader with a good overview without getting too much into the nitty gritties of functional programming.thus the way most changes to state are implemented are not by modifying an object in place (which is how imperative programming deals with it) but by cloning the data structure with some of the values getting modified and the modified data structure being returned by the function.java programmers are aware of the immutability of the string instances wherein any modifications to the string result in a new string instance being created.