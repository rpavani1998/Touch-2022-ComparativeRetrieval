fair enough, so python 2.5 is the latest, so i installed that.
i decided that although python/django and ror (less so ror, in my opinion) certainly seem like great ways to build web apps, i don't think there's an order of magnitude increase in productivity over java, assome have claimed.
the leading candidate for the static typing party, particularly among moderate static typers, but having a hard time gaining support from conservative members of the static party who claim that he is too dynamic on some issues.
it uses mongrel to run ror. apache is the actual web server, it passes requests intended for ror to mongrel, which then serves the request.
the datamapper project is a model-centric orm for ruby apps and as that project continues to grow, their could be some ideas borrowed from django evolution, although they do already have their own thing going on with auto-migration.
my only criticism of the book so far is that they may have published it a little to early, because for example if states that grails doesn't support many-to-many relationships, when in fact it does as of version 0.3.
typo has caused my entire vps instance hosted at vpsland to become unreachable.
another strong dynamic party candidate, but having a hard time stealing the spotlight from the two dynamic party candidates, despite running on a strong platform.
when i started learning ruby, from the start, everything just worked as you expected it would.
i'm not a big fan of developing with php, and i was hoping to start doing some custom things with my site, so i switched to typo, so that my site would be running ror, and i could make my own extensions using ror.
stripes and hibernate 3.2 with annotations are much better than struts (or webwork or spring mvc for that matter) and hibernate 2.0 respectively.
the other nice thing about grails is that it leverages all the existing java frameworks, such asspring and hibernate.
the reason why it isn't like this in ror is because ruby isn't a statically typed language.
i like python and django, but i always thought to myself, wouldn't it be nice if the language was optionally typed, to that you could declare the type if you want to, so that the type could be used as metadata by a framework?
a candidate that appeals to some members of both the dynamic and static typing parties, quickly gaining notoriety on the web for his support of once unconventional ideas like functional programming.
since then, i've discovered a few major design flaws with ror, so i'm not writing any code in ror now.
since i can't create a class in ruby and declare what type each property is, there is no way to automatically generate a database based on the model.
since then, i've discovered a few major design flaws with ror, so i'm not writing any code in ror now.
anyone who has tried to maintain a web app built with struts 1.x, spring, hibernate 2.0, jsp 1.0 and an overly complex set of ant build scripts can attest to that.
first, i add c:python24in to my path, fire up a command prompt, and enter "python" in hopes of getting an interactive shell.
again, i am naive when it comes to python, this is not a fair criticism of python, i have done very little to learn the language at this point, i just trying to illustrate a point.
there are some differences between evolutions and migrations, mainly due to the fact that django is model-centric, meaning that you define the attributes of your models in the code and generate the database from that.
django is cool in a lot of ways.
first of all, and this isn't really a design flaw, but more of a bug, is that some combination of typo, mongrel and rails is causing a serious memory leak.
my only criticism of the book so far is that they may have published it a little to early, because for example if states that grails doesn't support many-to-many relationships, when in fact it does as of version 0.3.
well you will consider many of the things in java odd, so i'm just going to consider all of these things first impressions and move on to learn more about the language and give it a fair chance.
this candidate has experience that proves she can bring change.
this means that audit, hinting, and verification schemes can use the django model as a point of reference.
so the point of this long technical discussion is that from what i've read about grails so far, it looks interesting.
stripes and hibernate 3.2 with annotations are much better than struts (or webwork or spring mvc for that matter) and hibernate 2.0 respectively.
grails the leading candidate for the static typing party, particularly among moderate static typers, but having a hard time gaining support from conservative members of the static party who claim that he is too dynamic on some issues.
first, i add c:python24in to my path, fire up a command prompt, and enter "python" in hopes of getting an interactive shell.
comments december 13, 2006 this site is currently using typo, which is blog software written using ruby on rails(ror).
you get you what you get, which is a lot, but you don't have much control over it.
a candidate from the dynamic party who is quickly gaining support, running on his campaign of hope.
conceptually, i like this idea better thanruby on rails, where you define your domain model in the database, and then rails generates objects for you at runtime based on the database metadata.
my theory is that we are at a point with java where we can build applications with the same level of productivity as any other framework.
anyone who has tried to maintain a web app built with struts 1.x, spring, hibernate 2.0, jsp 1.0 and an overly complex set of ant build scripts can attest to that.
i press the up arrow, but it doesn't bring up my previous command.
i'm in no way stating that python is poor language due to these oddities, they just strike me as odd and i feel the need to express it.
i originally started this site with wordpress, which is php-based blog software.
why not, because the python executables aren't in c:python24in, they are in c:python24.
but the bottom line is that if you are a shitty guitar player, it's going to sound like shit, not matter which one you pick.
i'm in no way stating that python is poor language due to these oddities, they just strike me as odd and i feel the need to express it.
they say "the django evolution syntax is a dsl".
so the point of this long technical discussion is that from what i've read about grails so far, it looks interesting.
this means that audit, hinting, and verification schemes can use the django model as a point of reference.
it puts a nice domain specific language on top of hibernate to make using hibernate even easier.
aside form the memory leak issues, and general difficult of setting up a stable rails site, the biggest thing i don't like about ror is that your application model is inferred from the database at runtime.
my theory is that we are at a point with java where we can build applications with the same level of productivity as any other framework.
you get you what you get, which is a lot, but you don't have much control over it.
i do most of my programming in java, so i came to the realization that there are great things about python, django, ruby and rails, but java, stripes, hibernate and friends have advantages too.
but when turning back to java, one thing i realized i missed was the true object oriented-ness that dynamic langauges allow.
it's a must read for anyone looking into grails.
it uses mongrel to run ror. apache is the actual web server, it passes requests intended for ror to mongrel, which then serves the request.
the current leader in the web application framework space, has a declining approval rating from the general public, but still maintains support from members of the static typing party.
i think up until recently, you couldn't argue with a straight face that building a java application is not more complicated than building a ruby on rails app.
again, compared to rails with apache, fcgi/scgi, lighttpd, mongrel, etc..., i don't know, let's just say i have found the process of setting up a rails production web/app server challenging.
rails one of the leading candidates from the dynamic typing party.
for example, in dynamic languages, to store a user object in the database, you use user.save , whereas in java, you do something like userdao.save(user).
should be a small memory footprint too, making it easy to run multiple apps in my 192mb virtual server webhost.
maybe this is because i have done most of my programming in java, but when i started to learn ruby, everything in ruby just made sense, without java's stupidity, such as nullpointerexceptions and primatives.
and if you are a great guitar player, anything is going to sound pretty good.
should be a small memory footprint too, making it easy to run multiple apps in my 192mb virtual server webhost.
the part where this analogy falls apart is that once you learn to play guitar, you can pick up any guitar and play, but just because you are a ruby on rails expert doesn't mean you can build a web site with java, and vice versa.
i'm going to try to get a new version of this site developed with grails, and i'll try to make posts here of my progress, assuming typo doesn't bring down my site again.
in my opinion, there is too much python syntax to call that a dsl.
for example, in dynamic languages, to store a user object in the database, you useuser.save , whereas in java, you do something likeuserdao.save(user).
jsp 1.2 is better than jsp 1.0, maven is better than ant, the list goes on.
the reason why it isn't like this in ror is because ruby isn't a statically typed language.
and if you are a great guitar player, anything is going to sound pretty good.
i've found the documentation on the grails site to be ok, but the book is great.
i press the up arrow, but it doesn't bring up my previous command.
the web application framework candidates february 14, 2008 the web application framework race is heating up, so let's take a moment to meet some of the candidates.
i like python and django, but i always thought to myself, wouldn't it be nice if the language was optionally typed, to that you could declare the type if you want to, so that the type could be used as metadata by a framework?
again, i am naive when it comes to python, this is not a fair criticism of python, i have done very little to learn the language at this point, i just trying to illustrate a point.
but this blog post isn't really about python or django specifically, it's about languages and web frameworks.
one of the leading candidates from the dynamic typing party.
so as i said i would, i've taken a look at python and django.
maybe this is because i have done most of my programming in java, but when i started to learn ruby, everything in ruby just made sense, without java's stupidity, such as nullpointerexceptions and primatives.
this is nice because you can build web apps using groovy on grails (gog?), and then deploy to a regular java application server, such as my personal favorite,resin.
again, compared to rails with apache, fcgi/scgi, lighttpd, mongrel, etc..., i don't know, let's just say i have found the process of setting up a rails production web/app server challenging.
i do most of my programming in java, so i came to the realization that there are great things about python, django, ruby and rails, but java, stripes, hibernate and friends have advantages too.
the language is succinct and powerful, it almost feels like writing psuedo code, except that it actually works.
the other nice thing about grails is that it leverages all the existing java frameworks, such asspring and hibernate.
as a result, the model definition is canonical - not the database.
validation that an evolution script will leave the database in a state consistent with the current model definition.
choosing a web framework and programming language is like choosing a guitar.
i also feel the need to blog about it because it will motivate me into actually doing it.
aside form the memory leak issues, and general difficult of setting up a stable rails site, the biggest thing i don't like about ror is that your application model is inferred from the database at runtime.
i decided that although python/django and ror (less so ror, in my opinion) certainly seem like great ways to build web apps, i don't think there's an order of magnitude increase in productivity over java, assome have claimed.
i think up until recently, you couldn't argue with a straight face that building a java application is not more complicated than building a ruby on rails app.
there are some differences between evolutions and migrations, mainly due to the fact that django is model-centric, meaning that you define the attributes of your models in the code and generate the database from that.
validation that an evolution script will leave the database in a state consistent with the current model definition.
i also feel the need to blog about it because it will motivate me into actually doing it.
but this blog post isn't really about python or django specifically, it's about languages and web frameworks.
choosing a web framework and programming language is like choosing a guitar.
the part where this analogy falls apart is that once you learn to play guitar, you can pick up any guitar and play, but just because you are a ruby on rails expert doesn't mean you can build a web site with java, and vice versa.
java the current leader in the web application framework space, has a declining approval rating from the general public, but still maintains support from members of the static typing party.
but python is still weird.
the thing i was least impressed with is that the admin interface isn't very customizable.
also, the succinctness of the dynamic languages are great, whereas java verbosity can be almost ridiculous at times.
annotations and generics are making life easier.
one is that python isn't that weird, it's just different.
i originally started this site with wordpress, which is php-based blog software.
it says it works with python 2.3-2.4, doesn't say anything about 2.5.
fair enough, so python 2.5 is the latest, so i installed that.
the language is succinct and powerful, it almost feels like writing psuedo code, except that it actually works.
february 14, 2008 the web application framework race is heating up, so let's take a moment to meet some of the candidates.
in my opinion, there is too much python syntax to call that a dsl.
this candidate has experience that proves she can bring change.
the datamapper project is a model-centric orm for ruby apps and as that project continues to grow, their could be some ideas borrowed from django evolution, although they do already have their own thing going on with auto-migration.
one is that python isn't that weird, it's just different.
the thing i was least impressed with is that the admin interface isn't very customizable.
merb a candidate from the dynamic party who is quickly gaining support, running on his campaign of hope.
first of all, and this isn't really a design flaw, but more of a bug, is that some combination of typo, mongrel and rails is causing a serious memory leak.
i've found the documentation on the grails site to be ok, but the book is great.
i'm going to try to get a new version of this site developed with grails, and i'll try to make posts here of my progress, assuming typo doesn't bring down my site again.
django another strong dynamic party candidate, but having a hard time stealing the spotlight from the two dynamic party candidates, despite running on a strong platform.
the thing i was most impressed with is the admin interface.
they say "the django evolution syntax is a dsl".
but when turning back to java, one thing i realized i missed was the true object oriented-ness that dynamic langauges allow.
why not, because the python executables aren't in c:python24in, they are in c:python24.
conceptually, i like this idea better thanruby on rails, where you define your domain model in the database, and then rails generates objects for you at runtime based on the database metadata.
one thing that as me interested in django is that the way it works in general is you define your domain model in code, in python objects, and django figures out how to build a database for you.
whereas a ruby on rails model is a description of a database that has been created by hand, django uses the python model to creates the database.
but the bottom line is that if you are a shitty guitar player, it's going to sound like shit, not matter which one you pick.
so, on with the weirdness: so to get started, i started reading the django install guide.
comments typo problems, new site coming soon (hopefully) december 13, 2006 this site is currently using typo, which is blog software written using ruby on rails(ror).
this is nice because you can build web apps using groovy on grails (gog?), and then deploy to a regular java application server, such as my personal favorite,resin.
django is cool in a lot of ways.
i'm sure if you know python well you will consider many of the things in java odd, so i'm just going to consider all of these things first impressions and move on to learn more about the language and give it a fair chance.
it says it works with python 2.3-2.4, doesn't say anything about 2.5.
whereas a ruby on rails model is a description of a database that has been created by hand, django uses the python model to creates the database.
the thing i was most impressed with is the admin interface.
i'm not a big fan of developing with php, and i was hoping to start doing some custom things with my site, so i switched to typo, so that my site would be running ror, and i could make my own extensions using ror.
when i started learning ruby, from the start, everything just worked as you expected it would.
scala a candidate that appeals to some members of both the dynamic and static typing parties, quickly gaining notoriety on the web for his support of once unconventional ideas like functional programming.
also, the succinctness of the dynamic languages are great, whereas java verbosity can be almost ridiculous at times.
one thing that as me interested in django is that the way it works in general is you define your domain model in code, in python objects, and django figures out how to build a database for you.
jsp 1.2 is better than jsp 1.0, maven is better than ant, the list goes on.
since i can't create a class in ruby and declare what type each property is, there is no way to automatically generate a database based on the model.
handling blocks based on indentation is cool.
as a result, the model definition is canonical - not the database.
it puts a nice domain specific language on top of hibernate to make using hibernate even easier.
