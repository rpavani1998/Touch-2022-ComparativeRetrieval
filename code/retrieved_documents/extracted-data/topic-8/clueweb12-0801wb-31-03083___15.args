reply as a python user that has enjoyed doing some ruby in the past, i’m glad to see that ruby performance is improving.
a language is fast, if the development progress is fast.
in fact, the leading python framework (django) says in their documentation that it’s memory and not processing power that makes the difference.
the speedup is much more modest for more realistic tasks, and a few things are slower in 1.9.
it was one of those tests that you do at 3 am in an irb session when you feel you’ve made your daily peace with your actual workload for the night.
reply switchbl8, my python results were confirmed by people with similar hardware to mine.
anyway!reply i wholeheartedly agree with you andrew.
but it doesnt mean, ruby is more powerful than python.
note that jruby trunk now actually performs even better on recursive fib than ruby 1.9.reply antonio, python can calculate first 35 fibo numbers in hundreds of times faster than ruby.
reply psyco is an impressive piece of software, but it isn’t that useful for web applications.
the test was run on mac os x 10.5 with my macbook pro (core 2 duo 2.2 ghz and 2 gb of memory).
reply andrew ingram says: november 28, 2007 at 7:46 am i imagine that like many i’m skeptical about the true level of improvement, i’m eager to see some more thorough benchmarks but still, assuming it’s not a one off thing, that’s a pretty impressive speedup and could end up making ruby much more competitive as an enterprise-level language.
./fibs 0.00s user 0.00s system 84% cpu 0.004 total faster, simpler, shorter.
yet, no body even mentioned why it’s normal to have memory leak in our rails-based service so we have to restart the process every hour !!!
if the ruby interpreter can execute faster than python, the python folks will try to improve python.
follow @acangianofollow @acangiano now shipping some of the links contained within this site have my referral id (e.g., amazon), which provides me with a small commission for each sale.
at least for now, there is no reasonable evidence to conclude that ruby 1.9 – which will be released for this coming christmas – will actually be faster than python 2.5.1 in the majority of situations, but hear me out and check out these very surprising results.
reply arman says: november 28, 2007 at 9:19 am wow…ruby is getting faster compared to python.
i’m impressed by how much ruby manages to uglify simple code snippets.
compiled strong typed languages are much better in that case, coz no runtime-detection of types needed.
it was one of those tests that you do at 3 am in an irb session when you feel you’ve made your daily peace with your actual workload for the night.
it’s probably worth pointing out that this is the test that yarv (1.9) is really optimised for, and is not a fair representation of yarvs speed at processing general ruby apps.
i develop for my clients, not for sick greed.
reply sapphirecat says: november 28, 2007 at 12:30 pm instead of doing all that benchmarking yourself, you should borrow someone else’s.
-r [1] http://github.com/rdp/crystalizer with jruby experiencing a speed up of about 200% thanks to invokedynamic in java 7.02 is time to rewrite the comparison.
it’s time to show secret python weapon – calculation of same fibonacci numbers but in 1000 times faster than antonio’s ruby implementation.
if( $n == 0 || $n == 1 ) return $n; for( $i=0; $i #’.fib($i).”\n”; took about 74 seconds on my box using: php 5.2.3-1ubuntu6 (cli) (built: oct 4 2007 23:35:54) irrelevant to compare to his numbers but looks like it’s slow compared to the new ruby or python.
building websites unfortunately include other processing operations and even more complicated not to mention file access, networking and string manipulations … i would love to see more about such benchmarks tests performed for realistic operations ..
currently i’m working with rails and found its serious memory leak problem, but django a kind of python’s framework doesn’t have such problem.
[root@diego ~]# i develop to get paid.
it’s time to show secret python weapon – calculation of same fibonacci numbers but in 1000 times faster than antonio’s ruby implementation.
not bad considering jruby doesn’t have any integer math optimizations like ruby 1.9 does.
in example above i took “boo” – compileable (you can use booi – iterpreter-like version as well) strong-typed (but you can use non-strong-typed constructs – slower) language with python-like syntax.
as soon as you start swapping, you’re toast.
http://blog.jruby.org/2011/12getting_started_with_jruby_and_java_7/ also in hacker news: http://news.ycombinator.com/item?id=3372816 python on pypy did this in 4.074s and in 17 secs on the same machine.
also, ruby never had any tail recursion.
reply toreau says: november 28, 2007 at 2:05 pm bad choice of a benchmark, as the fibonacci function can be cached.
i’m impressed by how much ruby manages to uglify simple code snippets.
by the way, i don’t really understand how you can improve a language to make it 15 times speeder on so simple script… 8| let’s take good news without too many questionsreply nevermind that 1.9 comes with a vm… isn’t it possible the code is compiled to bytecode and then run through the vm?reply bad choice of a benchmark, as the fibonacci function can be cached.
it’s a single test (which is obviously not a real world example, as you would use an iterative version of the function if it were), and unlike with real programs, it doesn’t stress many features of the language.
reply dima dogadaylo says: november 28, 2007 at 10:26 am antonio, python can calculate first 35 fibo numbers in hundreds of times faster than ruby.
wars!reply this just goes to prove how crap python is.
haskell, ruby smackdown november 30, 2007 antonio cangiano writes about how the new and improved ruby 1.9 is actually faster than python for a fibonacci [...]
test descriptions: cat copy stdin to stdout grep match a regular expression against stdin, print each match hash use each line of stdin as a hash key, value is 1.
we (bitmover) are using it to benchmark our scripting language, you can use it for whatever you like.
*of course* iterative or memoized algorithms are way faster.
right language for right job.
during this year’s rubyconf keynote, matz unbuttoned his shirt to show he was wearing a python shirt underneath so there can’t be that much conflict: http://www.flickr.com/photos/john_lam/1910968816/ maybe there’s some friendly rivalry, but that only helps everyone improve.
and difference will be much more in big apps.
if you want to make python look really bad, you can do as peter norvig and use python lists for matrix multiplication (http://norvig.com/python-lisp.html ).
so i’m curious as to why people would still prefer languages without one.
i guess having a compiler (which can compile things entered interactively!) is a bit of an advantage.
it allowed him to write blog entry titled “holy shmoly, ruby 1.9 smokes python away!”.
reply python has very slow recursion performance just today i read a post from antonio showing how big of an improvement ruby …reply reality check: c# 1.4 secs.
antonio cangiano compared execution time of recursive fibonacci function written in python and ruby 1.9 and found that ruby variant was almost 3 times as fast.
reply wow…ruby is getting faster compared to python.
as you can see in this traditional fibonacci task boo is 40 times faster than python.
if i manage to find some time, i will report the results in this blog.
python is the best solution for my current situation, but i admire ruby.)reply i imagine that like many i’m skeptical about the true level of improvement, i’m eager to see some more thorough benchmarks but still, assuming it’s not a one off thing, that’s a pretty impressive speedup and could end up making ruby much more competitive as an enterprise-level language.
using the memoize module in perl, i can perform the same calculation in 0.024 seconds on my athlon64 3700+; #!/usr/bin/perl
manages to knock python out of the water – and where python has still the edge.
it’s a single test (which is obviously not a real world example, as you would use an iterative version of the function if it were), and unlike with real programs, it doesn’t stress many features of the language.
the point i am trying to make, is that real-world performance has very little to do with the speed of the python or ruby interpreter measured in micro-benchmarks.
so i knew it was faster – but i was blown away when i timed the latest version from trunk (even if it’s a really silly example that’s being tested).
well of course i am biased since i use ruby and not python (but i never can understand a conflict between ruby and python, i am always saying to join up to beat on common enemies… perl and php and of course legacy shell scripts or solutions especially if they use perl )
thanks for sharing, i hope to do some benchamarks between 1.8 and 1.9 reply ola bini says: november 28, 2007 at 10:24 am first, ruby 1.9 has tail call analysis, but doesn’t use it for anything right now.
a honest haskel comparison (same algoritm), but it can be a lot faster (as shown by twey).
it allowed him to write blog entry titled “holy shmoly, ruby 1.9 smokes python away!”.
general performance improvement for 1.9 is looking to be about 150% to 200% for most applications, based on more real world test cases.
it would still be anecdotal evidence, but at least it would be more than just one microbenchmark.
but it doesnt mean, ruby is more powerful than python.
i’m a ruby guy, but i think python is a beautiful language..
[...]reply a very fast fib snippet in ruby: fibonacci numbers in ruby http://snippets.dzone.com/posts/show/3562reply [...] reading this article comparing the new ruby 1.9 to it’s older version and python, i though it would be interesting [...]
[...] reply greg graham says: november 28, 2007 at 7:26 am as a python user that has enjoyed doing some ruby in the past, i’m glad to see that ruby performance is improving.
the performance is mainly because of special handling of fixed point maths by new vm that ruby 1.9 provides….
reply martin vilcans says: november 28, 2007 at 12:16 pm that’s an impressive speedup, but of course it just tests one little special case (a.k.a.
if the ruby interpreter can execute faster than python, the python folks will try to improve python.
so, you might be cutting down some milliseconds off each request once that request gets heard, but you might also be dramatically increasing the time before an apache process actually deals with a specific request.
benchmarks just tend to tell lies.
bruno says: november 28, 2007 at 6:13 am i guess the difference between ruby 1.9 and python 2.5 mostly may comes from python not optimizing tail-recursive calls (which btw is a design choice wrt/ ease of debugging, not a technical flaw).
python 2.5.1: 54s i like toreau pointing out that algorithmic consideration can have a huge effect, especially when folks are in the ‘yeah, well my obscure language of choice does it in n secs’ mode.
well of course i am biased since i use ruby and not python (but i never can understand a conflict between ruby and python, i am always saying to join up to beat on common enemies… perl and php and of course legacy shell scripts or solutions especially if they use perl )
general performance improvement for 1.9 is looking to be about 150% to 200% for most applications, based on more real world test cases.
can you post a link where this is documented?reply bruno, i thought it might have been that at first, but the recursive calls aren’t tail calls.
at least in this one instance, jruby was faster than python [not psyco, mind you, which no one has yet written an equivalent for ruby ] http://shootout.alioth.debian.org/u32q/benchmark.php?test=fannkuch&lang=all so that’s good.
the test was run on mac os x 10.5 with my macbook pro (core 2 duo 2.2 ghz and 2 gb of memory).
when i saw the results though, my jaw dropped.
reply november 28, 2007 at 9:46 am python has very slow recursion performance just today i read a post from antonio showing how big of an improvement ruby … reply november 28, 2007 at 10:04 am reality check: c# 1.4 secs.
i am not impressed by the results of this micro-benchmark (probably because i’m well-informed regarding ruby 1.9); it’s always been well-known that 1.9 can be over 5 times faster than ruby 1.8 in such simplistic tests (in this case, the gains come mainly from the integer op optimizations introduced in yarv).
well, it looks like with ruby 1.9, it’ll be payback time.
so i guess you can create slow programs with python too, didn’t know that..
by the way, i don’t really understand how you can improve a language to make it 15 times speeder on so simple script… 8| let’s take good news without too many questions reply november 28, 2007 at 1:57 pm nevermind that 1.9 comes with a vm… isn’t it possible the code is compiled to bytecode and then run through the vm?
reply “mmmm.. yes fascinating,” he mumbles as he switches back to his vim window editing c source.
never try to compare interpreting languages in many-function-call-tasks.
looks like ruby’s function call overhead might be less than python’s?reply bruno: that function can’t be optimized by tail-recursive calls.
nasa uses python to process image data from hubble.
however, trolling will not be tolerated.
reply chris khoo says: november 28, 2007 at 8:26 am “mmmm.. yes fascinating,” he mumbles as he switches back to his vim window editing c source.
you just need to use right tools for right tasks.
on my workstation it takes less than 0.1 second: $ time python2.5 fibo.py november 28, 2007 at 11:00 am yay, now you just need to take it to the next level.
(time (loop for i from 0 to 35 do (format t “~a => ~a~&” i (fib i)))) ; cpu time (total) 920 msec user, 10 msec system ; real time 924 msec this is on the same type macbook pro that you’ve used, where the python version takes 31s.
[...] evaluation took: 7.734 seconds of real time 7.176449 seconds of user run time 0.004 seconds of system run time 0 calls to %eval 0 page faults and 212,424 bytes consed.
doing the same thing when it comes to comparing two different languages however, leaves much more room for error.
at least for now, there is no reasonable evidence to conclude that ruby 1.9 – which will be released for this coming christmas – will actually be faster than python 2.5.1 in the majority of situations, but hear me out and check out these very surprising results.
using the memoize module in perl, i can perform the same calculation in 0.024 seconds on my athlon64 3700+; #!/usr/bin/perl # use strict; use warnings; use memoize; memoize( ‘fib’ ); for ( 0..36 ) { print $_ .
i guess the difference between ruby 1.9 and python 2.5 mostly may comes from python not optimizing tail-recursive calls (which btw is a design choice wrt/ ease of debugging, not a technical flaw).
you have an excellent cpu there, but running the python script in under a second seems like an unrealistic result.
no one reported a significantly lower number than what i got.
granted python is not the fastest language out there, but ruby 1.9 was still able to execute the script almost 3 times as fast.
as the psyco webiste says, it uses a lot of memory.
this means c is slow, python and ruby are fast.
on the other hand, i could make python with numpy do wavelet transforms a lot faster than matlab.
paolo, both programs compute up to f(35).reply i’m not sure how much slower a core2duo 2.2ghz is than a amd x2 6000+, but on my system the python version finishes in well under a second.
reply that’s cool thanks for sharing, i hope to do some benchamarks between 1.8 and 1.9reply first, ruby 1.9 has tail call analysis, but doesn’t use it for anything right now.
salem, this is not a realistic benchmark; i program in, and love, both ruby and python.
(as tempting as they are, catchy headlines are best avoided if you care about the quality of the discussion more than about the number of visits.)reply hey friends.
on my system, jruby finishes in about 23 seconds to ruby 1.9′s 13 seconds.
this means c is slow, python and ruby are fast.
granted python is not the fastest language out there, but ruby 1.9 was still able to execute the script almost 3 times as fast.
it was great though because such a simple post generated a lot of discussion amongst developers, with some insightful arguments taking place – and besides it almost created a new meme with the whole “holy shomly” thing.
but i’m more then happy, that ruby is getting faster, even though i turned away from it and back to my beloved python.
so i’m curious as to why people would still prefer languages without one.
i like python because the standard library is great and it has built in unicode support.
a good choice of algorithm is far more important than language implementation.
google uses python to run youtube.
antonio cangiano compared execution time of recursive fibonacci function written in python and ruby 1.9 and found that ruby variant was almost 3 times as fast.
note that jruby trunk now actually performs even better on recursive fib than ruby 1.9.
claims that “python or ruby is so slow”, and that “c++ or java is so much faster”, have in 99% of the cases more to do with bad programming than the platform.
reply november 28, 2007 at 7:03 am bruno: that function can’t be optimized by tail-recursive calls.
(time (loop for i from 0 to 35 do (format t “~a => ~a~&” i (fib i)))) ; cpu time (total) 920 msec user, 10 msec system ; real time 924 msec this is on the same type macbook pro that you’ve used, where the python version takes 31s.
that means fewer server processes listening to requests.
in fact i think jruby is “almost as fast” as 1.9 @peke a “stable” 1.9 version is slated for february, i believe.
so i’m not sure ruby 1.9 is much faster than python; however it is impressive compared to ruby 1.8.
groovy as a scripting language is slower than ruby, however, taking in the whole stack (grails) it’s considered more scalable than rails by all means, and this is what i really care about ..
0.95s user 0.00s system 99% cpu 0.957 totalreply @vadim, multi-processor is the key, but there are many many implementations of stuff that will just lead you down an ultimately blind alley.
anyway, i still love php.
but i’m more then happy, that ruby is getting faster, even though i turned away from it and back to my beloved python.
8.7s numerical test from http://numericalruby.com/2007/11/28/quick-numerical-benchmark-of-ruby-19/ ruby 1.8.6 => 111.8s jruby 1.1b1 => 48.8s ruby 1.9 => 44.5s so ruby1.9 is about 2 – 10 times faster than ruby1.8reply @luke: later today i’ll publish “the great ruby shootout”.
the performance is mainly because of special handling of fixed point maths by new vm that ruby 1.9 provides….reply
just to make sure i wasn’t crazy i checked wikipedia and it says a tail recursive is when the last instruction is a recursive call, which those defs of fib fit.
for one, i wouldn’t touch anything that furthers microsoft’s interests.
because you don’t care so much about speed increases as you do memory usage when it comes to web applications.
thomas güttler says: november 28, 2007 at 11:12 am a language is fast, if the development progress is fast.
now it’ll be very interesting to run a series of algorithmically equivalent tests for ruby and python, and to see just when exactly ruby 1.9 manages to knock python out of the water – and where python has still the edge.
where you could make your program run tree times faster by changing the vm from python to ruby, you could have made it a million times faster by changing the algorithm.
and compiled languages does not need to be complex and heavy to learn.
yes i can create a blog in 20 minutes, but i spend more than 20 days just tweaking and struggling for little performance gain ..
i like python because the standard library is great and it has built in unicode support.
website notify me of follow-up comments by email.
ruby memoize version looks like the perl version, minus some line noise and shifting and such cool things (although both have been my obscure language of choice at various times): require “memoize” def fib(n) return n if(n ahem, your ruby program does *not* compute f(36) it only goes up to f(35).
when i saw the results though, my jaw dropped.
have a look on the pentium-4 sandbox of the famous computer language shootout:http://shootout.alioth.debian.org/ reply larry mcvoy says: november 28, 2007 at 12:36 pm we’ve got a little set of test cases for various languages (including a new one we’ve built for internal use but are releasing as open source in case anyone else wants to play with it) and the results are improved but nowhere near as impressive as this thread implies.
