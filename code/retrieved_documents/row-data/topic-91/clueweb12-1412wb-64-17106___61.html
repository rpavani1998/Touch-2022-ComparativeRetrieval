<!doctype html>
<meta charset="utf-8">
<title>Machine Learning Reference</title>
<body>

<h1>Machine Learning Reference</h1> 
<p>&nbsp;</p> 
<p></p> 
<ul> 
<li>Introduction. Common classes and functions </li> 
<li>Normal Bayes Classifier </li> 
<li>K Nearest Neighbors </li> 
<li>SVM </li> 
<li>Decision Trees </li> 
<li>Boosting </li> 
<li>Random Trees </li> 
<li>Expectation-Maximization </li> 
<li>Neural Networks </li> </ul> 
<p></p> 
<h2>Introduction. Common classes and functions</h2> 
<p>The Machine Learning Library (MLL) is a set of classes and functions for 
statistical classification, regression and clustering of data.</p> 
<p>Most of the classification and regression algorithms are implemented as C++ 
classes. As the algorithms have different set of features (like ability to 
handle missing measurements, or categorical input variables etc.), there is a 
little common ground between the classes. This common ground is defined by the 
class<code>CvStatModel</code> that all the other ML classes are derived from. 
</p> 
<h3>CvStatModel</h3> 
<p>Base class for statistical models in ML</p> 
<pre> class CvStatModel { public: <i>/* CvStatModel(); */</i> <i>/* CvStatModel
( const CvMat* train_data ... ); */</i> virtual ~CvStatModel(); virtual void 
clear()=0; <i>/* virtual bool train( const CvMat* train_data, [int tflag,] ..., 
const CvMat* responses, ..., [const CvMat* var_idx,] ..., [const CvMat* 
sample_idx,] ... [const CvMat* var_type,] ..., [const CvMat* missing_mask,] 
&lt;misc_training_alg_params&gt; ... )=0; */</i> <i>/* virtual float predict( 
const CvMat* sample ... ) const=0; */</i> virtual void save( const char* 
filename, const char* name=0 )=0; virtual voidload( const char* filename, const 
char* name=0 )=0; virtual voidwrite( CvFileStorage* storage, const char* name 
)=0; virtual voidread( CvFileStorage* storage, CvFileNode* node )=0; }; </pre> 
<p> In this declaration some methods are commented off. Actually, these are 
methods for which there is no unified API (with the exception of the default 
constructor), however, there are many similarities in the syntax and semantics 
that are briefly described below in this section, as if they are a part of the 
base class.</p> 
<h3>CvStatModel::CvStatModel</h3> 
<p>Default constructor</p> 
<pre> CvStatModel::CvStatModel(); </pre> 
<p>Each statistical model class in ML has default constructor without 
parameters. This constructor is useful for 2-stage model construction, when the 
default constructor is followed bytrain() or load(). </p> 
<h3>CvStatModel::CvStatModel(...)</h3> 
<p>Training constructor</p> 
<pre> CvStatModel::CvStatModel( const CvMat* train_data ... ); */ </pre> 
<p>Most ML classes provide single-step construct+train constructor. This 
constructor is equivalent to the default constructor, followed by thetrain() 
method with the parameters that passed to the constructor.</p> 
<h3>CvStatModel::~CvStatModel</h3> 
<p>Virtual destructor</p> 
<pre> CvStatModel::~CvStatModel(); </pre> 
<p> The destructor of the base class is declared as virtual, so it is safe to 
write the following code:</p> 
<pre> CvStatModel* model; if( use_svm ) model = new CvSVM(... /* SVM params 
*/); else model = new CvDTree(... /* Decision tree params */); ... delete model;
</pre> Normally, the destructor of each derived class does nothing, but calls 
the overridden methodclear() that deallocates all the memory. 
<p></p> 
<h3>CvStatModel::clear</h3> 
<p>Deallocates memory and resets the model state</p> 
<pre> void CvStatModel::clear(); </pre> 
<p> The method <code>clear</code> does the same job as the destructor, i.e. it 
deallocates all the memory occupied by the class members. But the object itself 
is not destructed, and it can be reused further. This method is called from the 
destructor, from the<code>train</code> methods of the derived classes, from the 
methodsload(), read() etc., or even explicitly by user. </p> 
<h3>CvStatModel::save</h3> 
<p>Saves the model to file</p> 
<pre> void CvStatModel::save( const char* filename, const char* name=0 ); 
</pre> 
<p> The method <code>save</code> stores the complete model state to the 
specified XML or YAML file with the specified name or default name (that 
depends on the particular class).Data persistence functionality from cxcore is 
used.</p> 
<h3>CvStatModel::load</h3> 
<p>Loads the model from file</p> 
<pre> void CvStatModel::load( const char* filename, const char* name=0 ); 
</pre> 
<p> The method <code>load</code> loads the complete model state with the 
specified name (or default model-dependent name) from the specified XML or YAML 
file. The previous model state is cleared byclear().</p> 
<p> Note that the method is virtual, therefore any model can be loaded using 
this virtual method. However, unlike the C types of OpenCV that can be loaded 
using genericcvLoad(), in this case the model type must be known anyway, 
because an empty model, an instance of the appropriate class, must be 
constructed beforehand. This limitation will be removed in the later ML 
versions.</p> 
<h3>CvStatModel::write</h3> 
<p>Writes the model to file storage</p> 
<pre> void CvStatModel::write( CvFileStorage* storage, const char* name ); 
</pre> 
<p> The method <code>write</code> stores the complete model state to the file 
storage with the specified name or default name (that depends on the particular 
class). The method is called bysave(). </p> 
<h3>CvStatModel::read</h3> 
<p>Reads the model from file storage</p> 
<pre> void CvStatMode::read( CvFileStorage* storage, CvFileNode* node ); </pre>
<p> The method <code>read</code> restores the complete model state from the 
specified node of the file storage. The node must be located by user, for 
example, using the functioncvGetFileNodeByName(). The method is called by load()
.</p> 
<p>The previous model state is cleared by clear(). </p> 
<h3>CvStatModel::train</h3> 
<p>Trains the model</p> 
<pre> bool CvStatMode::train( const CvMat* train_data, [int tflag,] ..., const 
CvMat* responses, ..., [const CvMat* var_idx,] ..., [const CvMat* sample_idx,] 
... [const CvMat* var_type,] ..., [const CvMat* missing_mask,] 
&lt;misc_training_alg_params&gt; ... );</pre> 
<p> The method trains the statistical model using a set of input feature 
vectors and the corresponding output values (responses). Both input and output 
vectors/values are passed as matrices. By default the input feature vectors are 
stored as<code>train_data</code> rows, i.e. all the components (features) of a 
training vector are stored continuously. However, some algorithms can handle 
the transposed representation, when all values of each particular feature 
(component/input variable) over the whole input set are stored continuously. If 
both layouts are supported, the method includes<code>tflag</code> parameter 
that specifies the orientation:<br>
<code>tflag=CV_ROW_SAMPLE</code> means that 
the feature vectors are stored as rows,<br>
<code>tflag=CV_COL_SAMPLE</code> 
means that the feature vectors are stored as columns.<br>
 The <code>train_data
</code> must have <code>32fC1</code> (32-bit floating-point, single-channel) 
format. Responses are usually stored in the 1d vector (a row or a column) of
<code>32sC1</code> (only in the classification problem) or <code>32fC1</code> 
format, one value per an input vector (although some algorithms, like various 
flavors of neural nets, take vector responses).</p> 
<p>For classification problems the responses are discrete class labels, for 
regression problems - the responses are values of the function to be 
approximated. Some algorithms can deal only with classification problems, some 
- only with regression problems, and some can deal with both problems. In the 
latter case the type of output variable is either passed as separate parameter, 
or as a last element of<code>var_type</code> vector:<br>
<code>
CV_VAR_CATEGORICAL</code> means that the output values are discrete class 
labels,<br>
<code>CV_VAR_ORDERED(=CV_VAR_NUMERICAL)</code> means that the 
output values are ordered, i.e. 2 different values can be compared as numbers, 
and this is a regression problem<br>
 The types of input variables can be also 
specified using<code>var_type</code>. Most algorithms can handle only ordered 
input variables.</p> 
<p> Many models in the ML may be trained on a selected feature subset, and/or 
on a selected sample subset of the training set. To make it easier for user, 
the method<code>train</code> usually includes <code>var_idx</code> and <code>
sample_idx</code> parameters. The former identifies variables (features) of 
interest, and the latter identifies samples of interest. Both vectors are 
either integer (<code>32sC1</code>) vectors, i.e. lists of 0-based indices, or 
8-bit (<code>8uC1</code>) masks of active variables/samples. User may pass 
<code>NULL</code> pointers instead of either of the argument, meaning that all 
the variables/samples are used for training.</p> 
<p>Additionally some algorithms can handle missing measurements, that is when 
certain features of certain training samples have unknown values (for example, 
they forgot to measure a temperature of patient A on Monday). The parameter
<code>missing_mask</code>, 8-bit matrix of the same size as <code>train_data
</code>, is used to mark the missed values (non-zero elements of the mask).</p> 
<p>Usually, the previous model state is cleared by clear() before running the 
training procedure. However, some algorithms may optionally update the model 
state with the new training data, instead of resetting it.</p> 
<h3>CvStatModel::predict</h3> 
<p>Predicts the response for sample</p> 
<pre> float CvStatMode::predict( const CvMat* sample[, 
&lt;prediction_params&gt;] ) const;</pre> 
<p> The method is used to predict the response for a new sample. In case of 
classification the method returns the class label, in case of regression - the 
output function value. The input sample must have as many components as the
<code>train_data</code> passed to train contains. If the <code>var_idx</code> 
parameter is passed totrain, it is remembered and then is used to extract only 
the necessary components from the input sample in the method<code>predict</code>
.</p> 
<p>The suffix &quot;const&quot; means that prediction does not affect the 
internal model state, so the method can be safely called from within different 
threads.</p> 
<h2>Normal Bayes Classifier</h2> This is a simple classification model 
assuming that feature vectors from each class are normally distributed (though, 
not necessarily independently distributed), so the whole data distribution 
function is assumed to be a Gaussian mixture, one component per a class. Using 
the training data the algorithm estimates mean vectors and covariation matrices 
for every class, and then it uses them for prediction.
<p><b> [Fukunaga90] K. Fukunaga. Introduction to Statistical Pattern 
Recognition. second ed., New York: Academic Press, 1990.</b> </p> 
<h3>CvNormalBayesClassifier</h3> 
<p>Bayes classifier for normally distributed data</p> 
<pre> class CvNormalBayesClassifier : public CvStatModel { public: 
CvNormalBayesClassifier(); virtual ~CvNormalBayesClassifier(); 
CvNormalBayesClassifier( const CvMat* _train_data, const CvMat* _responses, 
const CvMat* _var_idx=0, const CvMat* _sample_idx=0 ); virtual bool train( 
const CvMat* _train_data, const CvMat* _responses, const CvMat* _var_idx = 0, 
const CvMat* _sample_idx=0, bool update=false ); virtual float predict( const 
CvMat* _samples, CvMat* results=0 ) const; virtual void clear(); virtual void 
save( const char* filename, const char* name=0 ); virtual void load( const 
char* filename, const char* name=0 ); virtual void write( CvFileStorage* 
storage, const char* name ); virtual void read( CvFileStorage* storage, 
CvFileNode* node ); protected: ... };</pre> 
<h3>CvNormalBayesClassifier::train</h3> 
<p>Trains the model</p> 
<pre> bool CvNormalBayesClassifier::train( const CvMat* _train_data, const 
CvMat* _responses, const CvMat* _var_idx = 0, const CvMat* _sample_idx=0, bool 
update=false );</pre> 
<p> The method trains the Normal Bayes classifier. It follows the conventions 
of generictrain &quot;method&quot; with the following limitations: only 
CV_ROW_SAMPLE data layout is supported; the input variables are all ordered; 
the output variable is categorical (i.e. elements of<code>_responses</code> 
must be integer numbers, though the vector may have<code>32fC1</code> type), 
missing measurements are not supported.</p> 
<p>In addition, there is <code>update</code> flag that identifies, whether the 
model should be trained from scratch (<code>update=false</code>) or should be 
updated using new training data (<code>update=true</code>). </p> 
<h3>CvNormalBayesClassifier::predict</h3> 
<p>Predicts the response for sample(s)</p> 
<pre> float CvNormalBayesClassifier::predict( const CvMat* samples, CvMat* 
results=0 ) const;</pre> 
<p> The method <code>predict</code> estimates the most probable classes for 
the input vectors. The input vectors (one or more) are stored as rows of the 
matrix<code>samples</code>. In case of multiple input vectors, there should be 
output vector<code>results</code>. The predicted class for a single input 
vector is returned by the method.</p> 
<h2>K Nearest Neighbors</h2> 
<p> The algorithm caches all the training samples, and it predicts the 
response for a new sample by analyzing a certain number (<em>K</em>) of the 
nearest neighbors of the sample (using voting, calculating weighted sum etc.) 
The method is sometimes referred to as &quot;learning by example&quot;, i.e. 
for prediction it looks for the feature vector with a known response that is 
closest to the given vector.</p> 
<h3>CvKNearest</h3> 
<p>K Nearest Neighbors model</p> 
<pre> class CvKNearest : public CvStatModel { public: CvKNearest(); virtual 
~CvKNearest(); CvKNearest( const CvMat* _train_data, const CvMat* _responses, 
const CvMat* _sample_idx=0, bool _is_regression=false, int max_k=32 ); virtual 
bool train( const CvMat* _train_data, const CvMat* _responses, const CvMat* 
_sample_idx=0, bool is_regression=false, int _max_k=32, bool _update_base=false 
); virtual float find_nearest( const CvMat* _samples, int k, CvMat* results, 
const float** neighbors=0, CvMat* neighbor_responses=0, CvMat* dist=0 ) const; 
virtual void clear(); int get_max_k() const; int get_var_count() const; int 
get_sample_count() const; bool is_regression() const; protected: ... };</pre> 
<h3>CvKNearest::train</h3> 
<p>Trains the model</p> 
<pre> bool CvKNearest::train( const CvMat* _train_data, const CvMat* 
_responses, const CvMat* _sample_idx=0, bool is_regression=false, int 
_max_k=32, bool _update_base=false );</pre> 
<p> The method trains the K-Nearest model. It follows the conventions of 
generictrain &quot;method&quot; with the following limitations: only 
CV_ROW_SAMPLE data layout is supported, the input variables are all ordered, 
the output variables can be either categorical (<code>is_regression=false</code>
) or ordered (<code>is_regression=true</code>), variable subsets (<code>var_idx
</code>) and missing measurements are not supported.</p> 
<p>The parameter <code>_max_k</code> specifies the number of maximum neighbors 
that may be passed to the methodfind_nearest.</p> 
<p>The parameter <code>_update_base</code> specifies, whether the model is 
trained from scratch (<code>_update_base=false</code>), or it is updated using 
the new training data (<code>_update_base=true</code>). In the latter case the 
parameter<code>_max_k</code> must not be larger than the original value.</p> 
<h3>CvKNearest::find_nearest</h3> 
<p>Finds the neighbors for the input vectors</p> 
<pre> float CvKNearest::find_nearest( const CvMat* _samples, int k, CvMat* 
results=0, const float** neighbors=0, CvMat* neighbor_responses=0, CvMat* 
dist=0 ) const;</pre> 
<p> For each input vector (which are rows of the matrix <code>_samples</code>) 
the method finds<code>k&le;get_max_k()</code> nearest neighbor. In case of 
regression, the predicted result will be a mean value of the particular 
vector's neighbor responses. In case of classification the class is determined 
by voting.</p> 
<p> For custom classification/regression prediction, the method can optionally 
return pointers to the neighbor vectors themselves (<code>neighbors</code>, 
array of<code>k*_samples-&gt;rows</code> pointers), their corresponding output 
values (<code>neighbor_responses</code>, a vector of <code>k*_samples-&gt;rows
</code> elements) and the distances from the input vectors to the neighbors (
<code>dist</code>, also a vector of <code>k*_samples-&gt;rows</code> elements).
</p> 
<p>For each input vector the neighbors are sorted by their distances to the 
vector.</p> 
<p>If only a single input vector is passed, all output matrices are optional 
and the predicted value is returned by the method.</p> 
<h3>Example. Classification of 2D samples from a gaussian mixture with 
k-nearest classifier</h3> 
<pre> #include &quot;ml.h&quot; #include &quot;highgui.h&quot; int main( int 
argc, char** argv ) { const int K = 10; int i, j, k, accuracy; float response; 
int train_sample_count = 100; CvRNG rng_state = cvRNG(-1); CvMat* trainData = 
cvCreateMat( train_sample_count, 2, CV_32FC1 ); CvMat* trainClasses = 
cvCreateMat( train_sample_count, 1, CV_32FC1 ); IplImage* img = cvCreateImage( 
cvSize( 500, 500 ), 8, 3 ); float _sample[2]; CvMat sample = cvMat( 1, 2, 
CV_32FC1, _sample ); cvZero( img ); CvMat trainData1, trainData2, 
trainClasses1, trainClasses2; // form the training samples cvGetRows( 
trainData, &amp;trainData1, 0, train_sample_count/2 ); cvRandArr( 
&amp;rng_state, &amp;trainData1, CV_RAND_NORMAL, cvScalar(200,200), 
cvScalar(50,50) ); cvGetRows( trainData, &amp;trainData2, train_sample_count/2, 
train_sample_count ); cvRandArr( &amp;rng_state, &amp;trainData2, 
CV_RAND_NORMAL, cvScalar(300,300), cvScalar(50,50) ); cvGetRows( trainClasses, 
&amp;trainClasses1, 0, train_sample_count/2 ); cvSet( &amp;trainClasses1, 
cvScalar(1) ); cvGetRows( trainClasses, &amp;trainClasses2, 
train_sample_count/2, train_sample_count ); cvSet( &amp;trainClasses2, 
cvScalar(2) ); // learn classifier CvKNearest knn( trainData, trainClasses, 0, 
false, K ); CvMat* nearests = cvCreateMat( 1, K, CV_32FC1); for( i = 0; i &lt; 
img-&gt;height; i++ ) { for( j = 0; j &lt; img-&gt;width; j++ ) { 
sample.data.fl[0] = (float)j; sample.data.fl[1] = (float)i; // estimates the 
response and get the neighbors' labels response = 
knn.find_nearest(&amp;sample,K,0,0,nearests,0); // compute the number of 
neighbors representing the majority for( k = 0, accuracy = 0; k &lt; K; k++ ) { 
if( nearests-&gt;data.fl[k] == response) accuracy++; } // highlight the pixel 
depending on the accuracy (or confidence) cvSet2D( img, i, j, response == 1 ? 
(accuracy &gt; 5 ? CV_RGB(180,0,0) : CV_RGB(180,120,0)) : (accuracy &gt; 5 ? 
CV_RGB(0,180,0) : CV_RGB(120,120,0)) ); } } // display the original training 
samples for( i = 0; i &lt; train_sample_count/2; i++ ) { CvPoint pt; pt.x = 
cvRound(trainData1.data.fl[i*2]); pt.y = cvRound(trainData1.data.fl[i*2+1]); 
cvCircle( img, pt, 2, CV_RGB(255,0,0), CV_FILLED ); pt.x = 
cvRound(trainData2.data.fl[i*2]); pt.y = cvRound(trainData2.data.fl[i*2+1]); 
cvCircle( img, pt, 2, CV_RGB(0,255,0), CV_FILLED ); } cvNamedWindow( 
&quot;classifier result&quot;, 1 ); cvShowImage( &quot;classifier result&quot;, 
img ); cvWaitKey(0); cvReleaseMat( &amp;trainClasses ); cvReleaseMat( 
&amp;trainData ); return 0; }</pre> 
<h2>Support Vector Machines</h2> 
<p>Originally, support vector machines (SVM) was a technique for building an 
optimal (in some sense) binary (2-class) classifier. Then the technique has 
been extended to regression and clustering problems. SVM is a partial case of 
kernel-based methods, it maps feature vectors into higher-dimensional space 
using some kernel function, and then it builds an optimal linear discriminating 
function in this space (or an optimal hyperplane that fits into the training 
data, ...). In case of SVM the kernel is not defined explicitly. Instead, a 
distance between any 2 points in the hyperspace needs to be defined.</p> 
<p>The solution is optimal in a sense that the margin between the separating 
hyperplane and the nearest feature vectors from the both classes (in case of 
2-class classifier) is maximal. The feature vectors that are the closest to the 
hyperplane are called &quot;support vectors&quot;, meaning that the position of 
other vectors does not affect the hyperplane (the decision function).</p> 
<p>There are a lot of good references on SVM. Here are only a few ones to 
start with.</p> <b>[Burges98] C. Burges. &quot;A tutorial on support vector 
machines for pattern recognition&quot;, Knowledge Discovery and Data Mining 
2(2), 1998.</b> <br>
 (available online at 
http://citeseer.ist.psu.edu/burges98tutorial.html). <br>
<b>LIBSVM - A Library 
for Support Vector Machines. By Chih-Chung Chang and Chih-Jen Lin</b> <br>
 ( 
http://www.csie.ntu.edu.tw/~cjlin/libsvm/) 
<h3>CvSVM</h3> 
<p>Support Vector Machines</p> 
<pre> class CvSVM : public CvStatModel { public: // SVM type enum { C_SVC=100, 
NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 }; // SVM kernel type enum { 
LINEAR=0, POLY=1, RBF=2, SIGMOID=3 }; CvSVM(); virtual ~CvSVM(); CvSVM( const 
CvMat* _train_data, const CvMat* _responses, const CvMat* _var_idx=0, const 
CvMat* _sample_idx=0, CvSVMParams _params=CvSVMParams() ); virtual bool train( 
const CvMat* _train_data, const CvMat* _responses, const CvMat* _var_idx=0, 
const CvMat* _sample_idx=0, CvSVMParams _params=CvSVMParams() ); virtual float 
predict( const CvMat* _sample ) const; virtual int get_support_vector_count() 
const; virtual const float* get_support_vector(int i) const; virtual void 
clear(); virtual void save( const char* filename, const char* name=0 ); virtual 
void load( const char* filename, const char* name=0 ); virtual void write( 
CvFileStorage* storage, const char* name ); virtual void read( CvFileStorage* 
storage, CvFileNode* node ); int get_var_count() const { return var_idx ? 
var_idx-&gt;cols : var_all; } protected: ... };</pre> 
<h3>CvSVMParams</h3> 
<p>SVM training parameters</p> 
<pre> struct CvSVMParams { CvSVMParams(); CvSVMParams( int _svm_type, int 
_kernel_type, double _degree, double _gamma, double _coef0, double _C, double 
_nu, double _p, CvMat* _class_weights, CvTermCriteria _term_crit ); int 
svm_type; int kernel_type; double degree; // for poly double gamma; // for 
poly/rbf/sigmoid double coef0; // for poly/sigmoid double C; // for 
CV_SVM_C_SVC, CV_SVM_EPS_SVR and CV_SVM_NU_SVR double nu; // for CV_SVM_NU_SVC, 
CV_SVM_ONE_CLASS, and CV_SVM_NU_SVR double p; // for CV_SVM_EPS_SVR CvMat* 
class_weights; // for CV_SVM_C_SVC CvTermCriteria term_crit; // termination 
criteria };</pre> 
<p></p> 
<dl> 
<dt> svm_type </dt> 
<dd> Type of SVM, one of the following types: <br>
 CvSVM::C_SVC - n-class 
classification (n&gt;=2), allows imperfect separation of classes with penalty 
multiplier<code>C</code> for outliers. <br>
 CvSVM::NU_SVC - n-class 
classification with possible imperfect separation. Parameter<code>nu</code> (in 
the range 0..1, the larger the value, the smoother the decision boundary) is 
used instead of<code>C</code>. <br>
 CvSVM::ONE_CLASS - one-class SVM. All the 
training data are from the same class, SVM builds a boundary that separates the 
class from the rest of the feature space.<br>
 CvSVM::EPS_SVR - regression. The 
distance between feature vectors from the training set and the fitting 
hyperplane must be less than<code>p</code>. For outliers the penalty multiplier 
<code>C</code> is used. <br>
 CvSVM::NU_SVR - regression; <code>nu</code> is 
used instead of<code>p</code>. </dd> 
<dt> kernel_type </dt> 
<dd> The kernel type, one of the following types: <br>
 CvSVM::LINEAR - no 
mapping is done, linear discrimination (or regression) is done in the original 
feature space. It is the fastest option.<em>d(x,y) = x&bull;y == (x,y)</em> <br>
 CvSVM::POLY - polynomial kernel:<em>d(x,y) = (gamma*(x&bull;y)+coef0)degree
</em> <br>
 CvSVM::RBF - radial-basis-function kernel; a good choice in most 
cases:<em>d(x,y) = exp(-gamma*|x-y|2)</em> <br>
 CvSVM::SIGMOID - sigmoid 
function is used as a kernel:<em>d(x,y) = tanh(gamma*(x&bull;y)+coef0)</em> <br>
</dd> 
<dt> degree, gamma, coef0 </dt> 
<dd> Parameters of the kernel, see the formulas above. </dd> 
<dt> C, nu, p </dt> 
<dd> Parameters in the generalized SVM optimization problem. </dd> 
<dt> class_weights </dt> 
<dd> Optional weights, assigned to particular classes. They are multiplied by 
<code>C</code> and thus affect the misclassification penalty for different 
classes. The larger weight, the larger penalty on misclassification of data 
from the corresponding class.</dd> 
<dt> term_crit </dt> 
<dd> Termination procedure for iterative SVM training procedure (which solves 
a partial case of constrained quadratic optimization problem)</dd> </dl> 
<p> The structure must be initialized and passed to the training method of 
CvSVM </p> 
<h3>CvSVM::train</h3> 
<p>Trains SVM</p> 
<pre> bool CvSVM::train( const CvMat* _train_data, const CvMat* _responses, 
const CvMat* _var_idx=0, const CvMat* _sample_idx=0, CvSVMParams 
_params=CvSVMParams() );</pre> The method trains the SVM model. It follows the 
conventions of generictrain &quot;method&quot; with the following limitations: 
only CV_ROW_SAMPLE data layout is supported, the input variables are all 
ordered, the output variables can be either categorical (<code>
_params.svm_type=CvSVM::C_SVC</code> or <code>_params.svm_type=CvSVM::NU_SVC
</code>), or ordered ( <code>_params.svm_type=CvSVM::EPS_SVR</code> or <code>
_params.svm_type=CvSVM::NU_SVR</code>), or not required at all ( <code>
_params.svm_type=CvSVM::ONE_CLASS</code>), missing measurements are not 
supported.
<p></p> 
<p>All the other parameters are gathered in CvSVMParams structure.</p> 
<h3>CvSVM::get_support_vector*</h3> 
<p>Retrieves the number of support vectors and the particular vector</p> 
<pre> int CvSVM::get_support_vector_count() const; const float* 
CvSVM::get_support_vector(int i) const;</pre> 
<p>The methods can be used to retrieve the set of support vectors.</p> 
<h2>Decision Trees</h2> 
<p>The ML classes discussed in this section implement Classification And 
Regression Tree algorithms, which is described in[Brieman84].</p> 
<p>The class CvDTree represents a single decision tree that may be used alone, 
or as a base class in tree ensembles (seeBoosting and Random Trees).</p> 
<p>Decision tree is a binary tree (i.e. tree where each non-leaf node has 
exactly 2 child nodes). It can be used either for classification, when each 
tree leaf is marked with some class label (multiple leafs may have the same 
label), or for regression, when each tree leaf is also assigned a constant (so 
the approximation function is piecewise constant).</p> 
<h3>Predicting with Decision Trees</h3> 
<p>To reach a leaf node, and thus to obtain a response for the input feature 
vector, the prediction procedure starts with the root node. From each non-leaf 
node the procedure goes to the left (i.e. selects the left child node as the 
next observed node), or to the right based on the value of a certain variable, 
which index is stored in the observed node. The variable can be either ordered 
or categorical. In the first case, the variable value is compared with the 
certain threshold (which is also stored in the node); if the value is less than 
the threshold, the procedure goes to the left, otherwise, to the right (for 
example, if the weight is less than 1 kilo, the procedure goes to the left, 
else to the right). And in the second case the discrete variable value is 
tested, whether it belongs to a certain subset of values (also stored in the 
node) from a limited set of values the variable could take; if yes, the 
procedure goes to the left, else - to the right (for example, if the color is 
green or red, go to the left, else to the right). That is, in each node, a pair 
of entities (&lt;variable_index&gt;, &lt;decision_rule (threshold/subset)&gt;) 
is used. This pair is called split (split on the variable 
#&lt;variable_index&gt;). Once a leaf node is reached, the value assigned to 
this node is used as the output of prediction procedure.</p> 
<p>Sometimes, certain features of the input vector are missed (for example, in 
the darkness it is difficult to determine the object color), and the prediction 
procedure may get stuck in the certain node (in the mentioned example if the 
node is split by color). To avoid such situations, decision trees use so-called 
surrogate splits. That is, in addition to the best &quot;primary&quot; split, 
every tree node may also be split on one or more other variables with nearly 
the same results.</p> 
<h3>Training Decision Trees</h3> 
<p>The tree is built recursively, starting from the root node. The whole 
training data (feature vectors and the responses) are used to split the root 
node. In each node the optimum decision rule (i.e. the best &quot;primary&quot; 
split) is found based on some criteria (in ML<em>gini</em> &quot;purity&quot; 
criteria is used for classification, and sum of squared errors is used for 
regression). Then, if necessary, the surrogate splits are found that resemble 
at the most the results of the primary split on the training data; all data are 
divided using the primary and the surrogate splits (just like it is done in the 
prediction procedure) between the left and the right child node. Then the 
procedure recursively splits both left and right nodes etc. At each node the 
recursive procedure may stop (i.e. stop splitting the node further) in one of 
the following cases:<br>
</p> 
<ul> 
<li>depth of the tree branch being constructed has reached the specified 
maximum value.</li> 
<li>number of training samples in the node is less than the specified 
threshold, i.e. it is not statistically representative set to split the node 
further.</li> 
<li>all the samples in the node belong to the same class (or, in case of 
regression, the variation is too small).</li> 
<li>the best split found does not give any noticeable improvement comparing to 
just a random choice.</li> </ul> 
<p></p> 
<p>When the tree is built, it may be pruned using cross-validation procedure, 
if need. That is, some branches of the tree that may lead to the model 
overfitting are cut off. Normally, this procedure is only applied to standalone 
decision trees, while tree ensembles usually build small enough trees and use 
their own protection schemes against overfitting.</p> 
<h3>Variable importance</h3> 
<p> Besides the obvious use of decision trees - prediction, the tree can be 
also used for various data analysis. One of the key properties of the 
constructed decision tree algorithms is that it is possible to compute 
importance (relative decisive power) of each variable. For example, in a spam 
filter that uses a set of words occurred in the message as a feature vector, 
the variable importance rating can be used to determine the most 
&quot;spam-indicating&quot; words and thus help to keep the dictionary size 
reasonable.</p> 
<p>Importance of each variable is computed over all the splits on this 
variable in the tree, primary and surrogate ones. Thus, to compute variable 
importance correctly, the surrogate splits must be enabled in the training 
parameters, even if there is no missing data.</p> 
<p><b>[Brieman84] Breiman, L., Friedman, J. Olshen, R. and Stone, C. (1984), 
&quot;Classification and Regression Trees&quot;, Wadsworth.</b></p> 
<h3>CvDTreeSplit</h3> 
<p>Decision tree node split</p> 
<pre> struct CvDTreeSplit { int var_idx; int inversed; float quality; 
CvDTreeSplit* next; union { int subset[2]; struct { float c; int split_point; } 
ord; }; };</pre> 
<p></p> 
<dl> 
<dt> var_idx </dt> 
<dd> Index of the variable used in the split </dd> 
<dt> inversed </dt> 
<dd> When it equals to 1, the inverse split rule is used (i.e. left and right 
branches are exchanged in the expressions below)</dd> 
<dt> quality </dt> 
<dd> The split quality, a positive number. It is used to choose the best 
primary split, then to choose and sort the surrogate splits. After the tree is 
constructed, it is also used to compute variable importance.</dd> 
<dt> next </dt> 
<dd> Pointer to the next split in the node split list. </dd> 
<dt> subset </dt> 
<dd> Bit array indicating the value subset in case of split on a categorical 
variable.<br>
 The rule is: <code>if var_value in subset then 
next_node&lt;-left else next_node&lt;-right</code> </dd> 
<dt> c </dt> 
<dd> The threshold value in case of split on an ordered variable. <br>
 The 
rule is:<code>if var_value &lt; c then next_node&lt;-left else 
next_node&lt;-right</code> </dd> 
<dt> split_point </dt> 
<dd> Used internally by the training algorithm. </dd> </dl> 
<h3>CvDTreeNode</h3> 
<p>Decision tree node</p> 
<pre> struct CvDTreeNode { int class_idx; int Tn; double value; CvDTreeNode* 
parent; CvDTreeNode* left; CvDTreeNode* right; CvDTreeSplit* split; int 
sample_count; int depth; ... };</pre> 
<p></p> 
<dl> 
<dt> value </dt> 
<dd> The value assigned to the tree node. It is either a class label, or the 
estimated function value.</dd> 
<dt> class_idx </dt> 
<dd> The assigned to the node normalized class index (to 0..class_count-1 
range), it is used internally in classification trees and tree ensembles.</dd> 
<dt> Tn </dt> 
<dd> The tree index in a ordered sequence of trees. The indices are used 
during and after the pruning procedure. The root node has the maximum value
<code>Tn</code> of the whole tree, child nodes have <code>Tn</code> less than 
or equal to the parent's<code>Tn</code>, and the nodes with <code>Tn&le;CvDTree
::pruned_tree_idx</code> are not taken into consideration at the prediction 
stage (the corresponding branches are considered as cut-off), even if they have 
not been physically deleted from the tree at the pruning stage.</dd> 
<dt> parent, left, right </dt> 
<dd> Pointers to the parent node, left and right child nodes. </dd> 
<dt> split </dt> 
<dd> Pointer to the first (primary) split. </dd> 
<dt> sample_count </dt> 
<dd> The number of samples that fall into the node at the training stage. It 
is used to resolve the difficult cases - when the variable for the primary 
split is missing, and all the variables for other surrogate splits are missing 
too,<br>
the sample is directed to the left if <code>
left-&gt;sample_count&gt;right-&gt;sample_count</code> and to the right 
otherwise.</dd> 
<dt> depth </dt> 
<dd> The node depth, the root node depth is 0, the child nodes depth is the 
parent's depth + 1.</dd> </dl> 
<p>Other numerous fields of <code>CvDTreeNode</code> are used internally at 
the training stage.</p> 
<h3>CvDTreeParams</h3> 
<p>Decision tree training parameters</p> 
<pre> struct CvDTreeParams { int max_categories; int max_depth; int 
min_sample_count; int cv_folds; bool use_surrogates; bool use_1se_rule; bool 
truncate_pruned_tree; float regression_accuracy; const float* priors; 
CvDTreeParams() : max_categories(10), max_depth(INT_MAX), min_sample_count(10), 
cv_folds(10), use_surrogates(true), use_1se_rule(true), 
truncate_pruned_tree(true), regression_accuracy(0.01f), priors(0) {} 
CvDTreeParams( int _max_depth, int _min_sample_count, float 
_regression_accuracy, bool _use_surrogates, int _max_categories, int _cv_folds, 
bool _use_1se_rule, bool _truncate_pruned_tree, const float* _priors ); };</pre>
<p></p> 
<dl> 
<dt> max_depth </dt> 
<dd> This parameter specifies the maximum possible depth of the tree. That is 
the training algorithms attempts to split a node while its depth is less than
<code>max_depth</code>. The actual depth may be smaller if the other 
termination criteria are met (see the outline of the training procedure in the 
beginning of the section), and/or if the tree is pruned.</dd> 
<dt> min_sample_count </dt> 
<dd> A node is not split if the number of samples directed to the node is less 
than the parameter value.</dd> 
<dt> regression_accuracy </dt> 
<dd> Another stop criteria - only for regression trees. As soon as the 
estimated node value differs from the node training samples responses by less 
than the parameter value, the node is not split further.</dd> 
<dt> use_surrogates </dt> 
<dd> If <code>true</code>, surrogate splits are built. Surrogate splits are 
needed to handle missing measurements and for variable importance estimation.
</dd> 
<dt> max_categories </dt> 
<dd> If a discrete variable, on which the training procedure tries to make a 
split, takes more than<code>max_categories</code> values, the precise best 
subset estimation may take a very long time (as the algorithm is exponential). 
Instead, many decision trees engines (including ML) try to find sub-optimal 
split in this case by clustering all the samples into<code>max_categories</code>
 clusters (i.e. some categories are merged together).<br>
 Note that this 
technique is used only in<code>N(&gt;2)</code>-class classification problems. 
In case of regression and 2-class classification the optimal split can be found 
efficiently without employing clustering, thus the parameter is not used in 
these cases.</dd> 
<dt> cv_folds </dt> 
<dd> If this parameter is &gt;1, the tree is pruned using <code>cv_folds</code>
-fold cross validation.</dd> 
<dt> use_1se_rule </dt> 
<dd> If <code>true</code>, the tree is truncated a bit more by the pruning 
procedure. That leads to compact, and more resistant to the training data 
noise, but a bit less accurate decision tree.</dd> 
<dt> truncate_pruned_tree </dt> 
<dd> If <code>true</code>, the cut off nodes (with <code>Tn</code>&le; <code>
CvDTree::pruned_tree_idx</code>) are physically removed from the tree. 
Otherwise they are kept, and by decreasing<code>CvDTree::pruned_tree_idx</code> 
(e.g. setting it to -1) it is still possible to get the results from the 
original unpruned (or pruned less aggressively) tree.</dd> 
<dt> priors </dt> 
<dd> The array of a priori class probabilities, sorted by the class label 
value. The parameter can be used to tune the decision tree preferences toward a 
certain class. For example, if users want to detect some rare anomaly 
occurrence, the training base will likely contain much more normal cases than 
anomalies, so a very good classification performance will be achieved just by 
considering every case as normal. To avoid this, the priors can be specified, 
where the anomaly probability is artificially increased (up to 0.5 or even 
greater), so the weight of the misclassified anomalies becomes much bigger, and 
the tree is adjusted properly.
<p>A note about memory management: the field <code>priors</code> is a pointer 
to the array of floats. The array should be allocated by user, and released 
just after the<code>CvDTreeParams</code> structure is passed to CvDTreeTrainData
 orCvDTree constructors/methods (as the methods make a copy of the array). </p> 
</dd> </dl> 
<p> The structure contains all the decision tree training parameters. There is 
a default constructor that initializes all the parameters with the default 
values tuned for standalone classification tree. Any of the parameters can be 
overridden then, or the structure may be fully initialized using the advanced 
variant of the constructor.</p> 
<h3>CvDTreeTrainData</h3> 
<p>Decision tree training data and shared data for tree ensembles</p> 
<pre> struct CvDTreeTrainData { CvDTreeTrainData(); CvDTreeTrainData( const 
CvMat* _train_data, int _tflag, const CvMat* _responses, const CvMat* 
_var_idx=0, const CvMat* _sample_idx=0, const CvMat* _var_type=0, const CvMat* 
_missing_mask=0, const CvDTreeParams&amp; _params=CvDTreeParams(), bool 
_shared=false, bool _add_labels=false ); virtual ~CvDTreeTrainData(); virtual 
void set_data( const CvMat* _train_data, int _tflag, const CvMat* _responses, 
const CvMat* _var_idx=0, const CvMat* _sample_idx=0, const CvMat* _var_type=0, 
const CvMat* _missing_mask=0, const CvDTreeParams&amp; _params=CvDTreeParams(), 
bool _shared=false, bool _add_labels=false, bool _update_data=false ); virtual 
void get_vectors( const CvMat* _subsample_idx, float* values, uchar* missing, 
float* responses, bool get_class_idx=false ); virtual CvDTreeNode* 
subsample_data( const CvMat* _subsample_idx ); virtual void write_params( 
CvFileStorage* fs ); virtual void read_params( CvFileStorage* fs, CvFileNode* 
node ); // release all the data virtual void clear(); int get_num_classes() 
const; int get_var_type(int vi) const; int get_work_var_count() const; virtual 
int* get_class_labels( CvDTreeNode* n ); virtual float* get_ord_responses( 
CvDTreeNode* n ); virtual int* get_labels( CvDTreeNode* n ); virtual int* 
get_cat_var_data( CvDTreeNode* n, int vi ); virtual CvPair32s32f* 
get_ord_var_data( CvDTreeNode* n, int vi ); virtual int get_child_buf_idx( 
CvDTreeNode* n ); //////////////////////////////////// virtual bool set_params( 
const CvDTreeParams&amp; params ); virtual CvDTreeNode* new_node( CvDTreeNode* 
parent, int count, int storage_idx, int offset ); virtual CvDTreeSplit* 
new_split_ord( int vi, float cmp_val, int split_point, int inversed, float 
quality ); virtual CvDTreeSplit* new_split_cat( int vi, float quality ); 
virtual void free_node_data( CvDTreeNode* node ); virtual void 
free_train_data(); virtual void free_node( CvDTreeNode* node ); int 
sample_count, var_all, var_count, max_c_count; int ord_var_count, 
cat_var_count; bool have_labels, have_priors; bool is_classifier; int 
buf_count, buf_size; bool shared; CvMat* cat_count; CvMat* cat_ofs; CvMat* 
cat_map; CvMat* counts; CvMat* buf; CvMat* direction; CvMat* split_buf; CvMat* 
var_idx; CvMat* var_type; // i-th element = // k&lt;0 - ordered // k&gt;=0 - 
categorical, see k-th element of cat_* arrays CvMat* priors; CvDTreeParams 
params; CvMemStorage* tree_storage; CvMemStorage* temp_storage; CvDTreeNode* 
data_root; CvSet* node_heap; CvSet* split_heap; CvSet* cv_heap; CvSet* nv_heap; 
CvRNG rng; };</pre> 
<p> This structure is mostly used internally for storing both standalone trees 
and tree ensembles efficiently. Basically, it contains 3 types of information:
</p> 
<ol> 
<li>The training parameters, CvDTreeParams instance. </li> 
<li>The training data, preprocessed in order to find the best splits more 
efficiently. For tree ensembles this preprocessed data is reused by all the 
trees. Additionally, the training data characteristics that are shared by all 
trees in the ensemble are stored here: variable types, the number of classes, 
class label compression map etc.</li> 
<li>Buffers, memory storages for tree nodes, splits and other elements of the 
trees constructed.</li> </ol> 
<p> There are 2 ways of using this structure. In simple cases (e.g. standalone 
tree, or ready-to-use &quot;black box&quot; tree ensemble from ML, likeRandom 
Trees or Boosting) there is no need to care or even to know about the structure 
- just construct the needed statistical model, train it and use it. The<code>
CvDTreeTrainData</code> structure will be constructed and used internally. 
However, for custom tree algorithms, or another sophisticated cases, the 
structure may be constructed and used explicitly. The scheme is the following:
</p> 
<ol> 
<li>The structure is initialized using the default constructor, followed by 
<code>set_data</code> (or it is built using the full form of constructor). The 
parameter<code>_shared</code> must be set to <code>true</code>. </li> 
<li>One or more trees are trained using this data, see the special form of the 
methodCvDTree::train. </li> 
<li>Finally, the structure can be released only after all the trees using it 
are released.</li> </ol> 
<p></p> 
<h3>CvDTree</h3> 
<p>Decision tree</p> 
<pre> class CvDTree : public CvStatModel { public: CvDTree(); virtual 
~CvDTree(); virtual bool train( const CvMat* _train_data, int _tflag, const 
CvMat* _responses, const CvMat* _var_idx=0, const CvMat* _sample_idx=0, const 
CvMat* _var_type=0, const CvMat* _missing_mask=0, CvDTreeParams 
params=CvDTreeParams() ); virtual bool train( CvDTreeTrainData* _train_data, 
const CvMat* _subsample_idx ); virtual CvDTreeNode* predict( const CvMat* 
_sample, const CvMat* _missing_data_mask=0, bool raw_mode=false ) const; 
virtual const CvMat* get_var_importance(); virtual void clear(); virtual void 
read( CvFileStorage* fs, CvFileNode* node ); virtual void write( CvFileStorage* 
fs, const char* name ); // special read &amp; write methods for trees in the 
tree ensembles virtual void read( CvFileStorage* fs, CvFileNode* node, 
CvDTreeTrainData* data ); virtual void write( CvFileStorage* fs ); const 
CvDTreeNode* get_root() const; int get_pruned_tree_idx() const; 
CvDTreeTrainData* get_data(); protected: virtual bool do_train( const CvMat* 
_subsample_idx ); virtual void try_split_node( CvDTreeNode* n ); virtual void 
split_node_data( CvDTreeNode* n ); virtual CvDTreeSplit* find_best_split( 
CvDTreeNode* n ); virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, 
int vi ); virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi ); 
virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi ); virtual 
CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi ); virtual 
CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi ); virtual 
CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi ); virtual 
double calc_node_dir( CvDTreeNode* node ); virtual void complete_node_dir( 
CvDTreeNode* node ); virtual void cluster_categories( const int* vectors, int 
vector_count, int var_count, int* sums, int k, int* cluster_labels ); virtual 
void calc_node_value( CvDTreeNode* node ); virtual void prune_cv(); virtual 
double update_tree_rnc( int T, int fold ); virtual int cut_tree( int T, int 
fold, double min_alpha ); virtual void free_prune_data(bool cut_tree); virtual 
void free_tree(); virtual void write_node( CvFileStorage* fs, CvDTreeNode* node 
); virtual void write_split( CvFileStorage* fs, CvDTreeSplit* split ); virtual 
CvDTreeNode* read_node( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* 
parent ); virtual CvDTreeSplit* read_split( CvFileStorage* fs, CvFileNode* node 
); virtual void write_tree_nodes( CvFileStorage* fs ); virtual void 
read_tree_nodes( CvFileStorage* fs, CvFileNode* node ); CvDTreeNode* root; int 
pruned_tree_idx; CvMat* var_importance; CvDTreeTrainData* data; };</pre> 
<h3>CvDTree::train</h3> 
<p>Trains decision tree</p> 
<pre> bool CvDTree::train( const CvMat* _train_data, int _tflag, const CvMat* 
_responses, const CvMat* _var_idx=0, const CvMat* _sample_idx=0, const CvMat* 
_var_type=0, const CvMat* _missing_mask=0, CvDTreeParams params=CvDTreeParams() 
); bool CvDTree::train( CvDTreeTrainData* _train_data, const CvMat* 
_subsample_idx );</pre> 
<p> There are 2 <code>train</code> methods in <code>CvDTree</code>.</p> 
<p> The first method follows the generic CvStatModel::train conventions,&nbsp; 
it is the most complete form of it. Both data layouts (<code>
_tflag=CV_ROW_SAMPLE</code> and <code>_tflag=CV_COL_SAMPLE</code>) are 
supported, as well as sample and variable subsets, missing measurements, 
arbitrary combinations of input and output variable types etc. The last 
parameter contains all the necessary training parameters, seeCvDTreeParams 
description.</p> 
<p>The second method <code>train</code> is mostly used for building tree 
ensembles. It takes the pre-constructedCvDTreeTrainData instance and the 
optional subset of training set. The indices in<code>_subsample_idx</code> are 
counted relatively to the<code>_sample_idx</code>, passed to <code>
CvDTreeTrainData</code> constructor. For example, if <code>_sample_idx=[1, 5, 
7, 100]</code>, then <code>_subsample_idx=[0,3]</code> means that the samples 
<code>[1, 100]</code> of the original training set are used. </p> 
<h3>CvDTree::predict</h3> 
<p>Returns the leaf node of decision tree corresponding to the input vector</p>
<pre> CvDTreeNode* CvDTree::predict( const CvMat* _sample, const CvMat* 
_missing_data_mask=0, bool raw_mode=false ) const;</pre> 
<p>The method takes the feature vector and the optional missing measurement 
mask on input, traverses the decision tree and returns the reached leaf node on 
output. The prediction result, either the class label or the estimated function 
value, may be retrieved as<code>value</code> field of the CvDTreeNode 
structure, for example: dtree-&gt;predict(sample,mask)-&gt;value</p> 
<p>The last parameter is normally set to <code>false</code> that implies a 
regular input. If it is<code>true</code>, the method assumes that all the 
values of the discrete input variables have been already normalized to<code>
0..&lt;num_of_categoriesi&gt;-1</code> ranges. (as the decision tree uses such 
normalized representation internally). It is useful for faster prediction with 
tree ensembles. For ordered input variables the flag is not used.</p> 
<h3>Example. Building Tree for Classifying Mushrooms</h3> 
<p>See mushroom.cpp sample that demonstrates how to build and use the decision 
tree.</p> 
<h2>Boosting</h2> 
<p> A common machine learning task is supervised learning of the following 
kind: Predict the outputy for an unseen input sample x given a training set 
consisting of input and its desired output. In other words, the goal is to 
learn the functional relationshipF: y = F(x) between input x and output y. 
Predicting qualitative output is called classification, while predicting 
quantitative output is called regression.</p> 
<p> Boosting is a powerful learning concept, which provide a solution to 
supervised classification learning task. It combines the performance of many 
&quot;weak&quot; classifiers to produce a powerful 'committee' [HTF01]. A weak 
classifier is only required to be better than chance, and thus can be very 
simple and computationally inexpensive. Many of them smartly combined, however, 
result in a strong classifier, which often outperforms most 'monolithic' strong 
classifiers such as SVMs and Neural Networks.</p> 
<p> Decision trees are the most popular weak classifiers used in boosting 
schemes. Often the simplest decision trees with only a single split node per 
tree (called stumps) are sufficient.</p> 
<p> Learning of boosted model is based on N training examples {(xi,yi)}1N with 
xi &isin; RK and yi &isin; {&minus;1, +1}. xi is a K-component vector. Each 
component encodes a feature relevant for the learning task at hand. The desired 
two-class output is encoded as &minus;1 and +1.</p> 
<p> Different variants of boosting are known such as Discrete Adaboost, Real 
AdaBoost, LogitBoost, and Gentle AdaBoost [FHT98]. All of them are very similar 
in their overall structure. Therefore, we will look only at the standard 
two-class Discrete AdaBoost algorithm as shown in the box below. Each sample is 
initially assigned the same weight (step 2). Next a weak classifierfm(x) is 
trained on the weighted training data (step 3a). Its weighted training error 
and scaling factorcm is computed (step 3b). The weights are increased for 
training samples, which have been misclassified (step 3c). All weights are then 
normalized, and the process of finding the next week classifier continues for 
anotherM-1 times. The final classifier F(x) is the sign of the weighted sum 
over the individual weak classifiers (step 4).</p> 
<ol> 
<li>Given N examples {(xi,yi)}1N with xi &isin; RK, yi &isin; {&minus;1, +1}. 
</li> 
<li>Start with weights wi = 1/N, i = 1,&hellip;,N. </li> 
<li>Repeat for m = 1,2,&hellip;,M: 
<ol> 
<li>Fit the classifier fm(x) &isin; {&minus;1,1}, using weights wi on the 
training data.</li> 
<li>Compute errm = Ew [1(y &ne; fm(x))], cm = log((1 &minus; errm)/errm). </li>
<li>Set wi &larr; wi exp[cm 1(yi &ne; fm(xi))], i = 1,2,&hellip;,N, and 
renormalize so that &sum;i wi = 1. </li> </ol> </li> 
<li>Output the classifier sign[&sum; m = 1M cm fm(x)]. </li> </ol>  Two-class 
Discrete AdaBoost Algorithm: Training (steps 1 to 3) and Evaluation (step 4) 
<p><b>NOTE. </b>As well as the classical boosting methods, the current 
implementation supports 2-class classifiers only. For M&gt;2 classes there is
<em>AdaBoost.MH</em> algorithm, described in [FHT98], that reduces the problem 
to the 2-class problem, yet with much larger training set.</p> 
<p>In order to reduce computation time for boosted models without substantial 
loosing of the accuracy, the influence trimming technique may be employed. As 
the training algorithm proceeds and the number of trees in the ensemble is 
increased, a larger number of the training samples are classified correctly and 
with increasing confidence, thereby those samples receive smaller weights on 
the subsequent iterations. Examples with very low relative weight have small 
impact on training of the weak classifier. Thus such examples may be excluded 
during the weak classifier training without having much effect on the induced 
classifier. This process is controlled via theweight_trim_rate parameter. Only 
examples with the summary fractionweight_trim_rate of the total weight mass are 
used in the weak classifier training. Note that the weights for<em>all</em> 
training examples are recomputed at each training iteration. Examples deleted 
at a particular iteration may be used again for learning some of the weak 
classifiers further [FHT98].</p> <b> 
<p>[HTF01] Hastie, T., Tibshirani, R., Friedman, J. H. The Elements of 
Statistical Learning: Data Mining, Inference, and Prediction. Springer Series 
in Statistics. 2001.</p> 
<p>[FHT98] Friedman, J. H., Hastie, T. and Tibshirani, R. Additive Logistic 
Regression: a Statistical View of Boosting. Technical Report, Dept. of 
Statistics, Stanford University, 1998.</p></b> 
<h3>CvBoostParams</h3> 
<p>Boosting training parameters</p> 
<pre> struct CvBoostParams : public CvDTreeParams { int boost_type; int 
weak_count; int split_criteria; double weight_trim_rate; CvBoostParams(); 
CvBoostParams( int boost_type, int weak_count, double weight_trim_rate, int 
max_depth, bool use_surrogates, const float* priors ); };</pre> 
<p></p> 
<dl> 
<dt> boost_type </dt> 
<dd> Boosting type, one of the following: <br>
<code>CvBoost::DISCRETE</code> 
- Discrete AdaBoost<br>
<code>CvBoost::REAL</code> - Real AdaBoost <br>
<code>
CvBoost::LOGIT</code> - LogitBoost <br>
<code>CvBoost::GENTLE</code> - Gentle 
AdaBoost<br>
 Gentle AdaBoost and Real AdaBoost are often the preferrable 
choices.</dd> 
<dt> weak_count </dt> 
<dd> The number of weak classifiers to build. </dd> 
<dt> split_criteria </dt> 
<dd> Splitting criteria, used to choose optimal splits during a weak tree 
construction:<br>
<code>CvBoost::DEFAULT</code> - Use the default criteria for 
the particular boosting method, see below.<br>
<code>CvBoost::GINI</code> - Use 
Gini index. This is default option for Real AdaBoost; may be also used for 
Discrete AdaBoost.<br>
<code>CvBoost::MISCLASS</code> - Use misclassification 
rate. This is default option for Discrete AdaBoost; may be also used for Real 
AdaBoost.<br>
<code>CvBoost::SQERR</code> - Use least squares criteria. This is 
default and the only option for LogitBoost and Gentle AdaBoost.<br>
</dd> 
<dt> weight_trim_rate </dt> 
<dd> The weight trimming ratio, within 0..1. See the discussion of it above. 
If the parameter is &le;0 or &gt;1, the trimming is not used, all the samples 
are used at each iteration. The default value is 0.95.</dd> </dl> 
<p> The structure is derived from <code>CvDTreeParams</code>, but not all of 
the decision tree parameters are supported. In particular, cross-validation is 
not supported.</p> 
<h3>CvBoostTree</h3> 
<p>Weak tree classifier</p> 
<pre> class CvBoostTree: public CvDTree { public: CvBoostTree(); virtual 
~CvBoostTree(); virtual bool train( CvDTreeTrainData* _train_data, const CvMat* 
subsample_idx, CvBoost* ensemble ); virtual void scale( double s ); virtual 
void read( CvFileStorage* fs, CvFileNode* node, CvBoost* ensemble, 
CvDTreeTrainData* _data ); virtual void clear(); protected: ... CvBoost* 
ensemble; };</pre> 
<p>The weak classifier, a component of boosted tree classifier CvBoost, is a 
derivative ofCvDTree. Normally, there is no need to use the weak classifiers 
directly, however they can be accessed as elements of sequence<code>
CvBoost::weak</code>, retrieved by CvBoost::get_weak_predictors. </p> 
<p> Note, that in case of LogitBoost and Gentle AdaBoost each weak predictor 
is a regression tree, rather than a classification tree. Even in case of 
Discrete AdaBoost and Real AdaBoost the<code>CvBoostTree::predict</code> return 
value (<code>CvDTreeNode::value</code>) is not the output class label; a 
negative value &quot;votes&quot; for class #0, a positive - for class #1. And 
the votes are weighted. The weight of each individual tree may be increased or 
decreased using method<code>CvBoostTree::scale</code>. </p> 
<h3>CvBoost</h3> 
<p>Boosted tree classifier</p> 
<pre> class CvBoost : public CvStatModel { public: // Boosting type enum { 
DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 }; // Splitting criteria enum { 
DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 }; CvBoost(); virtual ~CvBoost(); 
CvBoost( const CvMat* _train_data, int _tflag, const CvMat* _responses, const 
CvMat* _var_idx=0, const CvMat* _sample_idx=0, const CvMat* _var_type=0, const 
CvMat* _missing_mask=0, CvBoostParams params=CvBoostParams() ); virtual bool 
train( const CvMat* _train_data, int _tflag, const CvMat* _responses, const 
CvMat* _var_idx=0, const CvMat* _sample_idx=0, const CvMat* _var_type=0, const 
CvMat* _missing_mask=0, CvBoostParams params=CvBoostParams(), bool update=false 
); virtual float predict( const CvMat* _sample, const CvMat* _missing=0, CvMat* 
weak_responses=0, CvSlice slice=CV_WHOLE_SEQ, bool raw_mode=false ) const; 
virtual void prune( CvSlice slice ); virtual void clear(); virtual void write( 
CvFileStorage* storage, const char* name ); virtual void read( CvFileStorage* 
storage, CvFileNode* node ); CvSeq* get_weak_predictors(); const 
CvBoostParams&amp; get_params() const; ... protected: virtual bool set_params( 
const CvBoostParams&amp; _params ); virtual void update_weights( CvBoostTree* 
tree ); virtual void trim_weights(); virtual void write_params( CvFileStorage* 
fs ); virtual void read_params( CvFileStorage* fs, CvFileNode* node ); 
CvDTreeTrainData* data; CvBoostParams params; CvSeq* weak; ... };</pre> 
<h3>CvBoost::train</h3> 
<p>Trains boosted tree classifier</p> 
<pre> bool CvBoost::train( const CvMat* _train_data, int _tflag, const CvMat* 
_responses, const CvMat* _var_idx=0, const CvMat* _sample_idx=0, const CvMat* 
_var_type=0, const CvMat* _missing_mask=0, CvBoostParams 
params=CvBoostParams(), bool update=false );</pre> 
<p> The train method follows the common template, the last parameter <code>
update</code> specifies whether the classifier needs to be updated (i.e. the 
new weak tree classifiers added to the existing ensemble), or the classifier 
needs to be rebuilt from scratch. The responses must be categorical, i.e. 
boosted trees can not be built for regression, and there should be 2 classes.
</p> 
<h3>CvBoost::predict</h3> 
<p>Predicts response for the input sample</p> 
<pre> float CvBoost::predict( const CvMat* sample, const CvMat* missing=0, 
CvMat* weak_responses=0, CvSlice slice=CV_WHOLE_SEQ, bool raw_mode=false ) 
const;</pre> 
<p></p> 
<dl> 
<dt> sample </dt> 
<dd> The input sample. </dd> 
<dt> missing </dt> 
<dd> The optional mask of missing measurements. To handle missing 
measurements, the weak classifiers must include surrogate splits (see<code>
CvDTreeParams::use_surrogates</code>). </dd> 
<dt> weak_reponses </dt> 
<dd> The optional output parameter, a floating-point vector, of responses from 
each individual weak classifier. The number of elements in the vector must be 
equal to the<code>slice</code> length. </dd> 
<dt> slice </dt> 
<dd> The continuous subset of the sequence of weak classifiers to be used for 
prediction. By default, all the weak classifiers are used.</dd> 
<dt> raw_mode </dt> 
<dd> It has the same meaning as in <code>CvDTree::predict</code>. Normally, it 
should be set to false.</dd> </dl> 
<p> The method <code>CvBoost::predict</code> runs the sample through the trees 
in the ensemble and returns the output class label based on the weighted voting.
</p> 
<h3>CvBoost::prune</h3> 
<p>Removes specified weak classifiers</p> 
<pre> void CvBoost::prune( CvSlice slice ); </pre> 
<p> The method removes the specified weak classifiers from the sequence. Note 
that this method should not be confused with the prunning of individual 
decision trees, which is currently not supported.</p> 
<h3>CvBoost::get_weak_predictors</h3> 
<p>Returns the sequence of weak tree classifiers</p> 
<pre> CvSeq* CvBoost::get_weak_predictors(); </pre> 
<p> The method returns the sequence of weak classifiers. Each element of the 
sequence is a pointer to<code>CvBoostTree</code> class (or, probably, to some 
of its derivatives).</p> 
<h2>Random Trees</h2> 
<p>Random trees have been introduced by Leo Breiman and Adele Cutler:  
http://www.stat.berkeley.edu/users/breiman/RandomForests/. The algorithm can 
deal with both classification and regression problems. Random trees is a 
collection (ensemble) oftree predictors that is called <b>forest</b> further in 
this section (the term has been also introduced by L. Brieman). The 
classification works as following: the random trees classifier takes the input 
feature vector, classifies it with every tree in the forest, and outputs the 
class label that has got the majority of &quot;votes&quot;. In case of 
regression the classifier response is the average of responses over all the 
trees in the forest.</p> 
<p> All the trees are trained with the same parameters, but on the different 
training sets, which are generated from the original training set using 
bootstrap procedure: for each training set we randomly select the same number 
of vectors as in the original set (<code>=N</code>). The vectors are chosen 
with replacement. That is, some vectors will occur more than once and some will 
be absent. At each node of each tree trained not all the variables are used to 
find the best split, rather than a random subset of them. The each node a new 
subset is generated, however its size is fixed for all the nodes and all the 
trees. It is a training parameter, set to<code>sqrt(&lt;number_of_variables&gt;)
</code> by default. None of the tree built is pruned. </p> 
<p>  In random trees there is no need in any accuracy estimation procedures, 
such as cross-validation or bootstrap, or a separate test set to get an 
estimate of the training error. The error is estimated internally during the 
training. When the training set for the current tree is drawn by sampling with 
replacement, some vectors are left out (so-called<em>oob (out-of-bag) data</em>
). The size of oob data is about<code>N/3</code>. The classification error is 
estimated by using this oob-data as following:</p> 
<ul> 
<li>Get a prediction for each vector, which is oob relatively to the i-th 
tree, using the very i-th tree.</li> 
<li>After all the trees have been trained, for each vector that has ever been 
oob, find the class-&quot;winner&quot; for it (i.e. the class that has got the 
majority of votes in the trees, where the vector was oob) and compare it to the 
ground-truth response.</li> 
<li>Then the classification error estimate is computed as ratio of number of 
missclassified oob vectors to all the vectors in the original data. In the case 
of regression the oob-error is computed as the squared error for oob vectors 
difference divided by the total number of vectors.</li> </ul> 
<p></p> 
<p><b> References:<br>
</b></p> 
<ol> <b> 
<li> Machine Learning, Wald I, July 2002</li> 
<li> Looking Inside the Black Box, Wald II, July 2002 </li> 
<li> Software for the Masses, Wald III, July 2002 </li> 
<li>And other articles from the web-site  
http://www.stat.berkeley.edu/users/breiman/RandomForests/cc_home.htm.</li> </b> 
</ol> <b> </b> 
<p></p> 
<h3>CvRTParams</h3> 
<p>Training Parameters of Random Trees</p> 
<pre> struct CvRTParams : public CvDTreeParams { bool calc_var_importance; int 
nactive_vars; CvTermCriteria term_crit; CvRTParams() : CvDTreeParams( 5, 10, 0, 
false, 10, 0, false, false, 0 ), calc_var_importance(false), nactive_vars(0) { 
term_crit = cvTermCriteria( CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 50, 0.1 ); } 
CvRTParams( int _max_depth, int _min_sample_count, float _regression_accuracy, 
bool _use_surrogates, int _max_categories, const float* _priors, bool 
_calc_var_importance, int _nactive_vars, int max_tree_count, float 
forest_accuracy, int termcrit_type ); };</pre> 
<p></p> 
<dl> 
<dt> calc_var_importance </dt> 
<dd> If it is set, then variable importance is computed by the training 
procedure. To retrieve the computed variable importance array, call the method
<code>CvRTrees::get_var_importance()</code>. </dd> 
<dt> nactive_vars </dt> 
<dd> The number of variables that are randomly selected at each tree node and 
that are used to find the best split(s).</dd> 
<dt> term_crit </dt> 
<dd> Termination criteria for growing the forest: <code>term_crit.max_iter
</code> is the maximum number of trees in the forest (see also <code>
max_tree_count</code> parameter of the constructor, by default it is set to 50) 
<br> <code>term_crit.epsilon</code> is the sufficient accuracy ( OOB error). 
</dd> </dl> 
<p> The set of training parameters for the forest is the superset of the 
training parameters for a single tree. However, Random trees do not need all 
the functionality/features of decision trees, most noticeably, the trees are 
not pruned, so the cross-validation parameters are not used.</p> 
<h3>CvRTrees</h3> 
<p>Random Trees</p> 
<pre> class CvRTrees : public CvStatModel { public: CvRTrees(); virtual 
~CvRTrees(); virtual bool train( const CvMat* _train_data, int _tflag, const 
CvMat* _responses, const CvMat* _var_idx=0, const CvMat* _sample_idx=0, const 
CvMat* _var_type=0, const CvMat* _missing_mask=0, CvRTParams 
params=CvRTParams() ); virtual float predict( const CvMat* sample, const CvMat* 
missing = 0 ) const; virtual void clear(); virtual const CvMat* 
get_var_importance(); virtual float get_proximity( const CvMat* sample_1, const 
CvMat* sample_2 ) const; virtual void read( CvFileStorage* fs, CvFileNode* node 
); virtual void write( CvFileStorage* fs, const char* name ); CvMat* 
get_active_var_mask(); CvRNG* get_rng(); int get_tree_count() const; 
CvForestTree* get_tree(int i) const; protected: bool grow_forest( const 
CvTermCriteria term_crit ); // array of the trees of the forest CvForestTree** 
trees; CvDTreeTrainData* data; int ntrees; int nclasses; ... };</pre> 
<h3>CvRTrees::train</h3> 
<p>Trains Random Trees model</p> 
<pre> bool CvRTrees::train( const CvMat* train_data, int tflag, const CvMat* 
responses, const CvMat* comp_idx=0, const CvMat* sample_idx=0, const CvMat* 
var_type=0, const CvMat* missing_mask=0, CvRTParams params=CvRTParams() );</pre>
<p>The method <code>CvRTrees::train</code> is very similar to the first form of
CvDTree::train() and follows the generic method CvStatModel::train conventions. 
All the specific to the algorithm training parameters are passed asCvRTParams 
instance. The estimate of the training error (oob-error) is stored in the 
protected class member<code>oob_error</code>.</p> 
<h3>CvRTrees::predict</h3> 
<p>Predicts the output for the input sample</p> 
<pre> double CvRTrees::predict( const CvMat* sample, const CvMat* missing=0 ) 
const;</pre> 
<p> The input parameters of the prediction method are the same as in 
CvDTree::predict, but the return value type is different. This method returns 
the cummulative result from all the trees in the forest (the class that 
receives the majority of voices, or the mean of the regression function 
estimates).</p> 
<h3>CvRTrees::get_var_importance</h3> 
<p>Retrieves the variable importance array</p> 
<pre> const CvMat* CvRTrees::get_var_importance() const; </pre> 
<p>The method returns the variable importance vector, computed at the training 
stage when<code>CvRTParams::calc_var_importance</code> is set. If the training 
flag is not set, then the<code>NULL</code> pointer is returned. This is unlike 
decision trees, where variable importance can be computed anytime after the 
training.</p> 
<h3>CvRTrees::get_proximity</h3> 
<p>Retrieves proximitity measure between two training samples</p> 
<pre> float CvRTrees::get_proximity( const CvMat* sample_1, const CvMat* 
sample_2 ) const;</pre> 
<p>The method returns proximity measure between any two samples (the ratio of 
the those trees in the ensemble, in which the samples fall into the same leaf 
node, to the total number of the trees).</p> 
<h4>Example. Prediction of mushroom edibility using random trees classifier
</h4> 
<pre> #include &lt;float.h&gt; #include &lt;stdio.h&gt; #include 
&lt;ctype.h&gt; #include &quot;ml.h&quot; int main( void ) { CvStatModel* cls = 
NULL; CvFileStorage* storage = cvOpenFileStorage( &quot;Mushroom.xml&quot;, 
NULL,CV_STORAGE_READ ); CvMat* data = (CvMat*)cvReadByName(storage, NULL, 
&quot;sample&quot;, 0 ); CvMat train_data, test_data; CvMat response; CvMat* 
missed = NULL; CvMat* comp_idx = NULL; CvMat* sample_idx = NULL; CvMat* 
type_mask = NULL; int resp_col = 0; int i,j; CvRTreesParams params; 
CvTreeClassifierTrainParams cart_params; const int ntrain_samples = 1000; const 
int ntest_samples = 1000; const int nvars = 23; if(data == NULL || 
data-&gt;cols != nvars) { puts(&quot;Error in source data&quot;); return -1; } 
cvGetSubRect( data, &amp;train_data, cvRect(0, 0, nvars, ntrain_samples) ); 
cvGetSubRect( data, &amp;test_data, cvRect(0, ntrain_samples, nvars, 
ntrain_samples + ntest_samples) ); resp_col = 0; cvGetCol( &amp;train_data, 
&amp;response, resp_col); /* create missed variable matrix */ missed = 
cvCreateMat(train_data.rows, train_data.cols, CV_8UC1); for( i = 0; i &lt; 
train_data.rows; i++ ) for( j = 0; j &lt; train_data.cols; j++ ) 
CV_MAT_ELEM(*missed,uchar,i,j) = (uchar)(CV_MAT_ELEM(train_data,float,i,j) &lt; 
0); /* create comp_idx vector */ comp_idx = cvCreateMat(1, train_data.cols-1, 
CV_32SC1); for( i = 0; i &lt; train_data.cols; i++ ) { 
if(i&lt;resp_col)CV_MAT_ELEM(*comp_idx,int,0,i) = i; 
if(i&gt;resp_col)CV_MAT_ELEM(*comp_idx,int,0,i-1) = i; } /* create sample_idx 
vector */ sample_idx = cvCreateMat(1, train_data.rows, CV_32SC1); for( j = i = 
0; i &lt; train_data.rows; i++ ) { if(CV_MAT_ELEM(response,float,i,0) &lt; 0) 
continue; CV_MAT_ELEM(*sample_idx,int,0,j) = i; j++; } sample_idx-&gt;cols = j; 
/* create type mask */ type_mask = cvCreateMat(1, train_data.cols+1, CV_8UC1); 
cvSet( type_mask, cvRealScalar(CV_VAR_CATEGORICAL), 0); // initialize training 
parameters 
cvSetDefaultParamTreeClassifier((CvStatModelParams*)&amp;cart_params); 
cart_params.wrong_feature_as_unknown = 1; params.tree_params = 
&amp;cart_params; params.term_crit.max_iter = 50; params.term_crit.epsilon = 
0.1; params.term_crit.type = CV_TERMCRIT_ITER|CV_TERMCRIT_EPS; 
puts(&quot;Random forest results&quot;); cls = cvCreateRTreesClassifier( 
&amp;train_data, CV_ROW_SAMPLE, &amp;response, (CvStatModelParams*)&amp; 
params, comp_idx, sample_idx, type_mask, missed ); if( cls ) { CvMat sample = 
cvMat( 1, nvars, CV_32FC1, test_data.data.fl ); CvMat test_resp; int wrong = 0, 
total = 0; cvGetCol( &amp;test_data, &amp;test_resp, resp_col); for( i = 0; i 
&lt; ntest_samples; i++, sample.data.fl += nvars ) { if( 
CV_MAT_ELEM(test_resp,float,i,0) &gt;= 0 ) { float resp = cls-&gt;predict( cls, 
&amp;sample, NULL ); wrong += (fabs(resp-response.data.fl[i]) &gt; 1e-3 ) ? 1 : 
0; total++; } } printf( &quot;Test set error = %.2f\n&quot;, 
wrong*100.f/(float)total ); } else puts(&quot;Error forest creation&quot;); 
cvReleaseMat(&amp;missed); cvReleaseMat(&amp;sample_idx); 
cvReleaseMat(&amp;comp_idx); cvReleaseMat(&amp;type_mask); 
cvReleaseMat(&amp;data); cvReleaseStatModel(&amp;cls); 
cvReleaseFileStorage(&amp;storage); return 0; }</pre> 
<h2>Expectation-Maximization</h2> The EM (Expectation-Maximization) algorithm 
estimates the parameters of the multivariate probability density function in a 
form of the Gaussian mixture distribution with a specified number of mixtures.
<p></p> 
<p> Consider the set of the feature vectors {x1, x2,..., xN}: <code>N</code> 
vectors from<code>d</code>-dimensional Euclidean space drawn from a Gaussian 
mixture:</p> 
<p></p> where <code>m</code> is the number of mixtures, p k is the normal 
distribution density with the mean<code>ak</code> and covariance matrix <code>Sk
</code>, <code>&pi;k</code> is the weight of k-th mixture. Given the number of 
mixtures<code>m</code> and the samples <code>{xi, i=1..N}</code> the algorithm 
finds themaximum-likelihood estimates (MLE) of the all the mixture parameters, 
i.e.<code>ak</code>, <code>Sk</code> and <code>&pi;k</code>: 
<p></p> EM algorithm is an iterative procedure. Each iteration of it includes 
two steps. At the first step (Expectation-step, or E-step), we find a 
probability<code>pi,k</code> (denoted <code>&alpha;i,k</code> in the formula 
below) of sample<code>#i</code> to belong to mixture <code>#k</code> using the 
currently available mixture parameter estimates:
<p></p> At the second step (Maximization-step, or M-step) the mixture 
parameter estimates are refined using the computed probabilities:
<p></p> Alternatively, the algorithm may start with M-step when initial values 
for<code>pi,k</code> can be provided. Another alternative, when <code>pi,k
</code> are unknown, is to use a simpler clustering algorithm to pre-cluster 
the input samples and thus obtain initial<code>pi,k</code>. Often (and in ML) 
k-means algorithm is used for that purpose. 
<p>One of the main that EM algorithm should deal with is the large number of 
parameters to estimate. The majority of the parameters sits in covariation 
matrices, which are<code>d&times;d</code> elements each (where <code>d</code> 
is the feature space dimensionality). However, in many practical problems the 
covariation matrices are close to diagonal, or even to<code>&mu;k*I</code>, 
where<code>I</code> is identity matrix and <code>&mu;k</code> is 
mixture-dependent &quot;scale&quot; parameter. So a robust computation scheme 
could be to start with the harder constraints on the covariation matrices and 
then use the estimated parameters as an input for a less constrained 
optimization problem (often a diagonal covariation matrix is already a good 
enough approximation).</p> 
<p><b>References:</b><br>
</p> 
<ol> 
<li> <b> [Bilmes98] J. A. Bilmes. A Gentle Tutorial of the EM Algorithm and 
its Application to Parameter Estimation for Gaussian Mixture and Hidden Markov 
Models. Technical Report TR-97-021, International Computer Science Institute 
and Computer Science Division, University of California at Berkeley, April 1998.
</b><br>
</li> </ol> 
<p></p> 
<h3>CvEMParams</h3> 
<p>Parameters of EM algorithm</p> 
<pre> struct CvEMParams { CvEMParams() : nclusters(10), 
cov_mat_type(CvEM::COV_MAT_DIAGONAL), start_step(CvEM::START_AUTO_STEP), 
probs(0), weights(0), means(0), covs(0) { term_crit=cvTermCriteria( 
CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 100, FLT_EPSILON ); } CvEMParams( int 
_nclusters, int _cov_mat_type=1/*CvEM::COV_MAT_DIAGONAL*/, int 
_start_step=0/*CvEM::START_AUTO_STEP*/, CvTermCriteria 
_term_crit=cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 100, FLT_EPSILON), 
CvMat* _probs=0, CvMat* _weights=0, CvMat* _means=0, CvMat** _covs=0 ) : 
nclusters(_nclusters), cov_mat_type(_cov_mat_type), start_step(_start_step), 
probs(_probs), weights(_weights), means(_means), covs(_covs), 
term_crit(_term_crit) {} int nclusters; int cov_mat_type; int start_step; const 
CvMat* probs; const CvMat* weights; const CvMat* means; const CvMat** covs; 
CvTermCriteria term_crit; };</pre> 
<dl> 
<dt> nclusters </dt> 
<dd> The number of mixtures. Some of EM implementation could determine the 
optimal number of mixtures within a specified value range, but that is not the 
case in ML yet.</dd> 
<dt> cov_mat_type </dt> 
<dd> The type of the mixture covariation matrices; should be one of the 
following:<br>
<code>CvEM::COV_MAT_GENERIC</code> - a covariation matrix of 
each mixture may be arbitrary symmetrical positively defined matrix, so the 
number of free parameters in each matrix is about<code>d</code> 2/2. It is not 
recommended to use this option, unless there is pretty accurate initial 
estimation of the parameters and/or a huge number of training samples.<br>

<code>CvEM::COV_MAT_DIAGONAL</code> - a covariation matrix of each mixture may 
be arbitrary diagonal matrix with positive diagonal elements, that is, 
non-diagonal elements are forced to be 0's, so the number of free parameters is
<code>d</code> for each matrix. This is most commonly used option yielding good 
estimation results.<br>
<code>CvEM::COV_MAT_SPHERICAL</code> - a covariation 
matrix of each mixture is a scaled identity matrix,<code>&mu;k*I</code>, so the 
only parameter to be estimated is<code>&mu;k</code>. The option may be used in 
special cases, when the constraint is relevant, or as a first step in the 
optimization (e.g. in case when the data is preprocessed withPCA). The results 
of such preliminary estimation may be passed again to the optimization 
procedure, this time with<code>cov_mat_type=CvEM::COV_MAT_DIAGONAL</code>. </dd>
<dt> start_step </dt> 
<dd> The initial step the algorithm starts from; should be one of the 
following:<br>
<code>CvEM::START_E_STEP</code> - the algorithm starts with 
E-step. At least, the initial values of mean vectors,<code>CvEMParams::means
</code> must be passed. Optionally, the user may also provide initial values 
for weights (<code>CvEMParams::weights</code>) and/or covariation matrices ( 
<code>CvEMParams::covs</code>). <br>
<code>CvEM::START_M_STEP</code> - the 
algorithm starts with M-step. The initial probabilities<code>pi,k</code> must 
be provided.<br>
<code>CvEM::START_AUTO_STEP</code> - No values are required 
from the user, k-means algorithm is used to estimate initial mixtures 
parameters.</dd> 
<dt> term_crit </dt> 
<dd> Termination criteria of the procedure. EM algorithm stops either after a 
certain number of iterations (<code>term_crit.num_iter</code>), or when the 
parameters change too little (no more than<code>term_crit.epsilon</code>) from 
iteration to iteration.</dd> 
<dt> probs </dt> 
<dd> Initial probabilities <code>pi,k</code>; are used (and must be not NULL) 
only when<code>start_step=CvEM::START_M_STEP</code>. </dd> 
<dt> weights </dt> 
<dd> Initial mixture weights <code>&pi;k</code>; are used (if not NULL) only 
when<code>start_step=CvEM::START_E_STEP</code>. </dd> 
<dt> covs </dt> 
<dd> Initial mixture covariation matrices <code>Sk</code>; are used (if not 
NULL) only when<code>start_step=CvEM::START_E_STEP</code>. </dd> 
<dt> means </dt> 
<dd> Initial mixture means <code>ak</code>; are used (and must be not NULL) 
only when<code>start_step=CvEM::START_E_STEP</code>. </dd> </dl> 
<p>The structure has 2 constructors, the default one represents a rough 
rule-of-thumb, with another one it is possible to override a variety of 
parameters, from a single number of mixtures (the only essential 
problem-dependent parameter), to the initial values for the mixture parameters.
</p> 
<h3>CvEM</h3> 
<p>EM model</p> 
<pre> class CV_EXPORTS CvEM : public CvStatModel { public: // Type of 
covariation matrices enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, 
COV_MAT_GENERIC=2 }; // The initial step enum { START_E_STEP=1, START_M_STEP=2, 
START_AUTO_STEP=0 }; CvEM(); CvEM( const CvMat* samples, const CvMat* 
sample_idx=0, CvEMParams params=CvEMParams(), CvMat* labels=0 ); virtual 
~CvEM(); virtual bool train( const CvMat* samples, const CvMat* sample_idx=0, 
CvEMParams params=CvEMParams(), CvMat* labels=0 ); virtual float predict( const 
CvMat* sample, CvMat* probs ) const; virtual void clear(); int get_nclusters() 
const { return params.nclusters; } const CvMat* get_means() const { return 
means; } const CvMat** get_covs() const { return covs; } const CvMat* 
get_weights() const { return weights; } const CvMat* get_probs() const { return 
probs; } protected: virtual void set_params( const CvEMParams&amp; params, 
const CvVectors&amp; train_data ); virtual void init_em( const CvVectors&amp; 
train_data ); virtual double run_em( const CvVectors&amp; train_data ); virtual 
void init_auto( const CvVectors&amp; samples ); virtual void kmeans( const 
CvVectors&amp; train_data, int nclusters, CvMat* labels, CvTermCriteria 
criteria, const CvMat* means ); CvEMParams params; double log_likelihood; 
CvMat* means; CvMat** covs; CvMat* weights; CvMat* probs; CvMat* 
log_weight_div_det; CvMat* inv_eigen_values; CvMat** cov_rotate_mats; };</pre> 
<h3>CvEM::train</h3> 
<p>Estimates Gaussian mixture parameters from the sample set</p> 
<pre> void CvEM::train( const CvMat* samples, const CvMat* sample_idx=0, 
CvEMParams params=CvEMParams(), CvMat* labels=0 );</pre> 
<p>Unlike many of ML models, EM is an unsupervised learning algorithm and it 
does not take responses (class labels or the function values) on input. 
Instead, it computesMLE of Gaussian mixture parameters from the input sample 
set, stores all the parameters inside the stucture:<code>pi,k</code> in <code>
probs</code>, <code>ak</code> in <code>means</code> <code>Sk</code> in <code>
covs[k]</code>, <code>&pi;k</code> in <code>weights</code> and optionally 
computes the output &quot;class label&quot; for each sample:<code>labelsi=arg 
maxk(pi,k), i=1..N</code> (i.e. indices of the most-probable mixture for each 
sample).</p> 
<p>The trained model can be used further for prediction, just like any other 
classifier. The model trained is similar to thenormal bayes classifier.</p> 
<h4>Example. Clustering random samples of multi-gaussian distribution using EM
</h4> 
<pre> #include &quot;ml.h&quot; #include &quot;highgui.h&quot; int main( int 
argc, char** argv ) { const int N = 4; const int N1 = (int)sqrt((double)N); 
const CvScalar colors[] = 
{{{0,0,255}},{{0,255,0}},{{0,255,255}},{{255,255,0}}}; int i, j; int nsamples = 
100; CvRNG rng_state = cvRNG(-1); CvMat* samples = cvCreateMat( nsamples, 2, 
CV_32FC1 ); CvMat* labels = cvCreateMat( nsamples, 1, CV_32SC1 ); IplImage* img 
= cvCreateImage( cvSize( 500, 500 ), 8, 3 ); float _sample[2]; CvMat sample = 
cvMat( 1, 2, CV_32FC1, _sample ); CvEM em_model; CvEMParams params; CvMat 
samples_part; cvReshape( samples, samples, 2, 0 ); for( i = 0; i &lt; N; i++ ) 
{ CvScalar mean, sigma; // form the training samples cvGetRows( samples, 
&amp;samples_part, i*nsamples/N, (i+1)*nsamples/N ); mean = 
cvScalar(((i%N1)+1.)*img-&gt;width/(N1+1), ((i/N1)+1.)*img-&gt;height/(N1+1)); 
sigma = cvScalar(30,30); cvRandArr( &amp;rng_state, &amp;samples_part, 
CV_RAND_NORMAL, mean, sigma ); } cvReshape( samples, samples, 1, 0 ); // 
initialize model's parameters params.covs = NULL; params.means = NULL; 
params.weights = NULL; params.probs = NULL; params.nclusters = N; 
params.cov_mat_type = CvEM::COV_MAT_SPHERICAL; params.start_step = 
CvEM::START_AUTO_STEP; params.term_crit.max_iter = 10; params.term_crit.epsilon 
= 0.1; params.term_crit.type = CV_TERMCRIT_ITER|CV_TERMCRIT_EPS; // cluster the 
data em_model.train( samples, 0, params, labels ); #if 0 // the piece of code 
shows how to repeatedly optimize the model // with less-constrained parameters 
(COV_MAT_DIAGONAL instead of COV_MAT_SPHERICAL) // when the output of the first 
stage is used as input for the second. CvEM em_model2; params.cov_mat_type = 
CvEM::COV_MAT_DIAGONAL; params.start_step = CvEM::START_E_STEP; params.means = 
em_model.get_means(); params.covs = (const CvMat**)em_model.get_covs(); 
params.weights = em_model.get_weights(); em_model2.train( samples, 0, params, 
labels ); // to use em_model2, replace em_model.predict() with 
em_model2.predict() below #endif // classify every image pixel cvZero( img ); 
for( i = 0; i &lt; img-&gt;height; i++ ) { for( j = 0; j &lt; img-&gt;width; 
j++ ) { CvPoint pt = cvPoint(j, i); sample.data.fl[0] = (float)j; 
sample.data.fl[1] = (float)i; int response = cvRound(em_model.predict( 
&amp;sample, NULL )); CvScalar c = colors[response]; cvCircle( img, pt, 1, 
cvScalar(c.val[0]*0.75,c.val[1]*0.75,c.val[2]*0.75), CV_FILLED ); } } //draw 
the clustered samples for( i = 0; i &lt; nsamples; i++ ) { CvPoint pt; pt.x = 
cvRound(samples-&gt;data.fl[i*2]); pt.y = cvRound(samples-&gt;data.fl[i*2+1]); 
cvCircle( img, pt, 1, colors[labels-&gt;data.i[i]], CV_FILLED ); } 
cvNamedWindow( &quot;EM-clustering result&quot;, 1 ); cvShowImage( 
&quot;EM-clustering result&quot;, img ); cvWaitKey(0); cvReleaseMat( 
&amp;samples ); cvReleaseMat( &amp;labels ); return 0; }</pre> 
<h2>Neural Networks</h2> 
<p>ML implements feedforward artificial neural networks, more particularly, 
multi-layer perceptrons (MLP), the most commonly used type of neural networks. 
MLP consists of the input layer, output layer and one or more hidden layers. 
Each layer of MLP includes one or more neurons that are directionally linked 
with the neurons from the previous and the next layer. Here is an example of 
3-layer perceptron with 3 inputs, 2 outputs and the hidden layer including 5 
neurons:</p> 
<p></p> 
<p> All the neurons in MLP are similar. Each of them has several input links 
(i.e. it takes the output values from several neurons in the previous layer on 
input) and several output links (i.e. it passes the response to several neurons 
in the next layer). The values retrieved from the previous layer are summed 
with certain weights, individual for each neuron, plus the bias term, and the 
sum is transformed using the activation function<code>f</code> that may be also 
different for different neurons. Here is the picture:</p> 
<p></p> In other words, given the outputs <code>{xj}</code> of the layer <code>
n</code>, the outputs <code>{yi}</code> of the layer <code>n+1</code> are 
computed as:
<pre> ui=sumj(w(n+1)i,j*xj) + w(n+1)i,bias yi=f(ui) </pre> 
<p>Different activation functions may be used, the ML implements 3 standard 
ones:</p> 
<ul> 
<li>Identity function (<code>CvANN_MLP::IDENTITY</code>): <code>f(x)=x</code> 
</li> 
<li>Symmetrical sigmoid (<code>CvANN_MLP::SIGMOID_SYM</code>): <code>
f(x)=&beta;*(1-e-&alpha;x)/(1+e-&alpha;x)</code>, the default choice for MLP; 
the standard sigmoid with &beta;=1, &alpha;=1 is shown below:
<p></p> </li> 
<li>Gaussian function (<code>CvANN_MLP::GAUSSIAN</code>): <code>f(x)=&beta;e
-&alpha;x*x</code>, not completely supported by the moment. </li> </ul> 
<p>In ML all the neurons have the same activation functions, with the same 
free parameters (&alpha;, &beta;) that are specified by user and are not 
altered by the training algorithms.</p> 
<p> So the whole trained network works as following. It takes the feature 
vector on input, the vector size is equal to the size of the input layer, when 
the values are passed as input to the first hidden layer, the outputs of the 
hidden layer are computed using the weights and the activation functions and 
passed further downstream, until we compute the output layer.</p> 
<p>So, in order to compute the network one need to know all the weights <code>w
(n+1)i,j</code>. The weights are computed by the training algorithm. The 
algorithm takes a training set: multiple input vectors with the corresponding 
output vectors, and iteratively adjusts the weights to try to make the network 
give the desired response on the provided input vectors.</p> 
<p> The larger the network size (the number of hidden layers and their sizes), 
the more is the potential network flexibility, and the error on the training 
set could be made arbitrarily small. But at the same time the learned network 
will also &quot;learn&quot; the noise present in the training set, so the error 
on the test set usually starts increasing after the network size reaches some 
limit. Besides, the larger networks are train much longer than the smaller 
ones, so it is reasonable to preprocess the data (usingPCA or similar 
technique) and train a smaller network on only the essential features.</p> 
<p>Another feature of the MLP's is their inability to handle categorical data 
as is, however there is a workaround. If a certain feature in the input or 
output (i.e. in case of<code>n</code>-class classifier for <code>n&gt;2</code>) 
layer is categorical and can take<code>M</code> (&gt;2) different values, it 
makes sense to represent it as binary tuple of<code>M</code> elements, where 
<code>i</code>-th element is <code>1</code> if and only if the feature is equal 
to the<code>i</code>-th value out of <code>M</code> possible. It will increase 
the size of the input/output layer, but will speedup the training algorithm 
convergence and at the same time enable &quot;fuzzy&quot; values of such 
variables, i.e. a tuple of probabilities instead of a fixed value.</p> 
<p>ML implements 2 algorithms for training MLP's. The first is the classical 
random sequentialbackpropagation algorithm and the second (default one) is batch
RPROP algorithm</p> 
<p><b>References:<br>
</b></p> 
<ol> <b> 
<li>http://en.wikipedia.org/wiki/Backpropagation. Wikipedia article about the 
backpropagation algorithm.</li>
<li>Y. LeCun, L. Bottou, G.B. Orr and K.-R. Muller, &quot;Efficient 
backprop&quot;, in Neural Networks---Tricks of the Trade, Springer Lecture 
Notes in Computer Sciences 1524, pp.5-50, 1998.</li></b> 
<li><b>M. Riedmiller and H. Braun, &quot;A Direct Adaptive Method for Faster 
Backpropagation Learning: The RPROP Algorithm&quot;, Proc. ICNN, San Fransisco 
(1993).</b> </li> </ol> 
<p></p> 
<h3>CvANN_MLP_TrainParams</h3> 
<p>Parameters of MLP training algorithm</p> 
<pre> struct CvANN_MLP_TrainParams { CvANN_MLP_TrainParams(); 
CvANN_MLP_TrainParams( CvTermCriteria term_crit, int train_method, double 
param1, double param2=0 ); ~CvANN_MLP_TrainParams(); enum { BACKPROP=0, RPROP=1 
}; CvTermCriteria term_crit; int train_method; // backpropagation parameters 
double bp_dw_scale, bp_moment_scale; // rprop parameters double rp_dw0, 
rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max; };</pre> 
<dl> 
<dt> term_crit </dt> 
<dd> The termination criteria for the training algorithm. It identifies how 
many iterations is done by the algorithm (for sequential backpropagation 
algorithm the number is multiplied by the size of the training set) and how 
much the weights could change between the iterations to make the algorithm 
continue.</dd> 
<dt> train_method </dt> 
<dd> The training algoithm to use; can be one of <code>
CvANN_MLP_TrainParams::BACKPROP</code> (sequential backpropagation algorithm) or
<code>CvANN_MLP_TrainParams::RPROP</code> (RPROP algorithm, default value). 
</dd> 
<dt> bp_dw_scale </dt> 
<dd> (Backpropagation only): The coefficient to multiply the computed weight 
gradient by. The recommended value is about<code>0.1</code>. The parameter can 
be set via<code>param1</code> of the constructor. </dd> 
<dt> bp_moment_scale </dt> 
<dd> (Backpropagation only): The coefficient to multiply the difference 
between weights on the 2 previous iterations. This parameter provides some 
inertia to smooth the random fluctuations of the weights. It can vary from<code>
0</code> (the feature is disabled) to <code>1</code> and beyond. The value 
<code>0.1</code> or so is good enough. The parameter can be set via <code>param2
</code> of the constructor. </dd> 
<dt> rp_dw0 </dt> 
<dd> (RPROP only): Initial magnitude of the weight delta. The default value is 
<code>0.1</code>. This parameter can be set via <code>param1</code> of the 
constructor.</dd> 
<dt> rp_dw_plus </dt> 
<dd> (RPROP only): The increase factor for the weight delta. It must be &gt;1, 
default value is<code>1.2</code> that should work well in most cases, according 
to the algorithm's author. The parameter can only be changed explicitly by 
modifying the structure member.</dd> 
<dt> rp_dw_minus </dt> 
<dd> (RPROP only): The decrease factor for the weight delta. It must be &lt;1, 
default value is<code>0.5</code> that should work well in most cases, according 
to the algorithm's author. The parameter can only be changed explicitly by 
modifying the structure member.</dd> 
<dt> rp_dw_min </dt> 
<dd> (RPROP only): The minimum value of the weight delta. It must be &gt;0, 
the default value is<code>FLT_EPSILON</code>. The parameter can be set via 
<code>param2</code> of the constructor. </dd> 
<dt> rp_dw_max </dt> 
<dd> (RPROP only): The maximum value of the weight delta. It must be &gt;1, 
the default value is<code>50</code>. The parameter can only be changed 
explicitly by modifying the structure member.</dd> </dl> 
<p>The structure has default constructor that initializes parameters for <code>
RPROP</code> algorithm. There is also more advanced constructor to customize 
the parameters and/or choose backpropagation algorithm. Finally, the individual 
parameters can be adjusted after the structure is created.</p> 
<h3>CvANN_MLP</h3> 
<p>MLP model</p> 
<pre> class CvANN_MLP : public CvStatModel { public: CvANN_MLP(); CvANN_MLP( 
const CvMat* _layer_sizes, int _activ_func=SIGMOID_SYM, double _f_param1=0, 
double _f_param2=0 ); virtual ~CvANN_MLP(); virtual void create( const CvMat* 
_layer_sizes, int _activ_func=SIGMOID_SYM, double _f_param1=0, double 
_f_param2=0 ); virtual int train( const CvMat* _inputs, const CvMat* _outputs, 
const CvMat* _sample_weights, const CvMat* _sample_idx=0, CvANN_MLP_TrainParams 
_params = CvANN_MLP_TrainParams(), int flags=0 ); virtual float predict( const 
CvMat* _inputs, CvMat* _outputs ) const; virtual void clear(); // possible 
activation functions enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 }; // 
available training flags enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, 
NO_OUTPUT_SCALE = 4 }; virtual void read( CvFileStorage* fs, CvFileNode* node 
); virtual void write( CvFileStorage* storage, const char* name ); int 
get_layer_count() { return layer_sizes ? layer_sizes-&gt;cols : 0; } const 
CvMat* get_layer_sizes() { return layer_sizes; } protected: virtual bool 
prepare_to_train( const CvMat* _inputs, const CvMat* _outputs, const CvMat* 
_sample_weights, const CvMat* _sample_idx, CvANN_MLP_TrainParams _params, 
CvVectors* _ivecs, CvVectors* _ovecs, double** _sw, int _flags ); // sequential 
random backpropagation virtual int train_backprop( CvVectors _ivecs, CvVectors 
_ovecs, const double* _sw ); // RPROP algorithm virtual int train_rprop( 
CvVectors _ivecs, CvVectors _ovecs, const double* _sw ); virtual void 
calc_activ_func( CvMat* xf, const double* bias ) const; virtual void 
calc_activ_func_deriv( CvMat* xf, CvMat* deriv, const double* bias ) const; 
virtual void set_activ_func( int _activ_func=SIGMOID_SYM, double _f_param1=0, 
double _f_param2=0 ); virtual void init_weights(); virtual void scale_input( 
const CvMat* _src, CvMat* _dst ) const; virtual void scale_output( const CvMat* 
_src, CvMat* _dst ) const; virtual void calc_input_scale( const CvVectors* 
vecs, int flags ); virtual void calc_output_scale( const CvVectors* vecs, int 
flags ); virtual void write_params( CvFileStorage* fs ); virtual void 
read_params( CvFileStorage* fs, CvFileNode* node ); CvMat* layer_sizes; CvMat* 
wbuf; CvMat* sample_weights; double** weights; double f_param1, f_param2; 
double min_val, max_val, min_val1, max_val1; int activ_func; int max_count, 
max_buf_sz; CvANN_MLP_TrainParams params; CvRNG rng; };</pre> 
<p>Unlike many other models in ML that are constructed and trained at once, in 
the MLP model these steps are separated. First, a network with the specified 
topology is created using the non-default constructor or the methodcreate. All 
the weights are set to zeros. Then the network is trained using the set of 
input and output vectors. The training procedure can be repeated more than 
once, i.e. the weights can be adjusted based on the new training data.</p> 
<h3>CvANN_MLP::create</h3> 
<p>Constructs the MLP with the specified topology</p> 
<pre> void CvANN_MLP::create( const CvMat* _layer_sizes, int 
_activ_func=SIGMOID_SYM, double _f_param1=0, double _f_param2=0 );</pre> 
<dl> 
<dt> _layer_sizes </dt> 
<dd> The integer vector specifies the number of neurons in each layer 
including the input and output layers.</dd> 
<dt> _activ_func </dt> 
<dd> Specifies the activation function for each neuron; one of <code>
CvANN_MLP::IDENTITY</code>, <code>CvANN_MLP::SIGMOID_SYM</code> and <code>
CvANN_MLP::GAUSSIAN</code>. </dd> 
<dt> _f_param1, _f_param2 </dt> 
<dd> Free parameters of the activation function, &alpha; and &beta;, 
respectively. See the formulas in the introduction section.</dd> </dl> 
<p> </p> 
<p>The method creates MLP network with the specified topology and assigns the 
same activation function to all the neurons.</p> 
<h3>CvANN_MLP::train</h3> 
<p>Trains/updates MLP</p> 
<pre> int CvANN_MLP::train( const CvMat* _inputs, const CvMat* _outputs, const 
CvMat* _sample_weights, const CvMat* _sample_idx=0, CvANN_MLP_TrainParams 
_params = CvANN_MLP_TrainParams(), int flags=0 );</pre> 
<dl> 
<dt> _inputs </dt> 
<dd> A floating-point matrix of input vectors, one vector per row. </dd> 
<dt> _outputs </dt> 
<dd> A floating-point matrix of the corresponding output vectors, one vector 
per row.</dd> 
<dt> _sample_weights </dt> 
<dd> (RPROP only) The optional floating-point vector of weights for each 
sample. Some samples may be more important than others for training, e.g. user 
may want to gain the weight of certain classes to find the right balance 
between hit-rate and false-alarm rate etc.</dd> 
<dt> _sample_idx </dt> 
<dd> The optional integer vector indicating the samples (i.e. rows of <code>
_inputs</code> and <code>_outputs</code>) that are taken into account. </dd> 
<dt> _params </dt> 
<dd> The training params. See CvANN_MLP_TrainParams description. </dd> 
<dt> _flags </dt> 
<dd> The various parameters to control the training algorithm. May be a 
combination of the following:<br>
<code>UPDATE_WEIGHTS = 1</code> - algorithm 
updates the network weights, rather than computes them from scratch (in the 
latter case the weights are initialized using<em>Nguyen-Widrow</em> algorithm). 
<br> <code>NO_INPUT_SCALE</code> - algorithm does not normalize the input 
vectors. If this flag is not set, the training algorithm normalizes each input 
feature independently, shifting its mean value to 0 and making the standard 
deviation<code>=1</code>. If the network is assumed to be updated frequently, 
the new training data could be much different from original one. In this case 
user should take care of proper normalization.<br>
<code>NO_OUTPUT_SCALE</code> 
- algorithm does not normalize the output vectors. If the flag is not set, the 
training algorithm normalizes each output features independently, by 
transforming it to the certain range depending on the activation function used.
<br> </dd> </dl> 
<p> This method applies the specified training algorithm to compute/adjust the 
network weights. It returns the number of done iterations.</p> 
</body>