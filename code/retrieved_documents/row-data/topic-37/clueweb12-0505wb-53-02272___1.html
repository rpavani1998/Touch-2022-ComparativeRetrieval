<!doctype html>
<meta charset="utf-8">
<title>An Overview of Direct3D</title>
<body>

<p>Jump to content</p> 
<ul> 
<li>  &nbsp;&nbsp;&nbsp;&nbsp; Sign In&nbsp;&nbsp;&nbsp; </li> 
<li> Create Account </li> </ul> <br>
<br>

<ul> 
<li>Home</li> 
<li>For Beginners</li> 
<li>Technical 
<ul> 
<li>Game Programming</li> 
<li>General Programming</li> 
<li>Graphics Programming and Theory</li> 
<li>DirectX and XNA</li> 
<li>OpenGL</li> 
<li>Multiplayer and Network Programming</li> 
<li>Artificial Intelligence</li> 
<li>Math and Physics</li> 
<li>Mobile &amp; Console Development</li> 
<li>APIs and Tools</li> </ul> </li> 
<li>Creative 
<ul> 
<li>Game Design</li> 
<li>Writing For Games</li> 
<li>Music and Sound</li> 
<li>Visual Arts</li> 
<li>Gallery</li> </ul> </li> 
<li>Business 
<ul> 
<li>Breaking into the Industry</li> 
<li>Business &amp; Law</li> 
<li>Production &amp; Management</li> </ul> </li> 
<li>Community 
<ul> 
<li>Forums</li> 
<li>Developer Journals</li> 
<li>GDNet+ Subscriptions</li> 
<li>Gallery</li> 
<li>Books</li> 
<li>Calendar</li> 
<li>Store</li> </ul> </li> 
<li>Classifieds 
<ul> 
<li>Job Offers</li> 
<li>Contractors For Hire</li> 
<li>Contract Projects</li> 
<li>Hobbyist Projects</li> </ul> </li> 
<li>Marketplace</li> </ul> Search Advanced 
<ul> 
<li><strong>Search section:</strong></li> 
<li> <strong>Google</strong> </li> 
<li>Forums</li> 
<li>Members</li> 
<li>Help Files</li> 
<li>Developer Journals</li> 
<li>Gallery</li> 
<li>Calendar</li> 
<li>Downloads</li> 
<li>Resources</li> 
<li>Store</li> 
<li>Classifieds</li> 
<li>Tracker</li> </ul> <br>
<br>
<br>

<ol> 
<li> Articles </li> 
<li> &raquo; Technical </li> 
<li> &raquo; DirectX and XNA </li> 
<li> &raquo; Article: An Overview of Direct3D </li> </ol> Watched Content New 
Content <br>
<br>
<br>

<h3>Categories (See All)</h3> 
<ul> 
<li> Technical 
<ul> 
<li> Game Programming </li> 
<li> General Programming </li> 
<li> Graphics Programming and Theory </li> 
<li> DirectX and XNA </li> 
<li> OpenGL </li> 
<li> Multiplayer and Network Programming </li> 
<li> Artificial Intelligence </li> 
<li> Math and Physics </li> 
<li> Mobile Development </li> 
<li> APIs and Tools </li> </ul> </li> 
<li> Creative 
<ul> 
<li> Game Design </li> 
<li> Music and Sound </li> 
<li> Visual Arts </li> </ul> </li> 
<li> Business 
<ul> 
<li> Event Coverage </li> 
<li> Breaking Into the Industry </li> 
<li> Business and Law </li> 
<li> Interviews </li> 
<li> Production and Management </li> </ul> </li> </ul> 
<h3>Recent Resources</h3> 
<ul> 
<li> Using Animated Pieces in a Board-based Game wit...<br>

<p>Feb 24 2012 11:17 PM | 0 Comments</p> </li> 
<li> Getting Started with Audacity<br>

<p>Feb 24 2012 10:04 PM | 0 Comments</p> </li> 
<li> Peter Molyneux: How to get a job in games devel...<br>

<p>Feb 24 2012 11:17 AM | 0 Comments</p> </li> 
<li> How we Built an iOS game on PC<br>

<p>Feb 23 2012 07:07 PM | 0 Comments</p> </li> 
<li> 3D Animation Techniques with XNA Game Studio 4.0<br>

<p>Feb 23 2012 02:40 PM | 0 Comments</p> </li> 
<li> Producer Consumer Using Double Queues<br>

<p>Feb 22 2012 09:13 AM | 0 Comments</p> </li> 
<li> Introducing Xcode Tools for iPhone Development<br>

<p>Feb 21 2012 09:39 PM | 0 Comments</p> </li> </ul> 
<p>Show more &raquo; | View all recent resources&raquo;</p> 
<h1>An Overview of Direct3D</h1> 
<p> <b>By Bipin Patwardhan </b> | Published Nov 22 2002 10:00 PM in DirectX 
and XNA </p> 
<ul> 
<li>Article</li> 
<li>Comments (0)</li> 
<li>Revisions (4)</li> 
<li>Related Stuff (25)</li> </ul> <br>
 Direct3D constitutes one of the 
emerging APIs from Microsoft Corporation, for providing new software features 
to developers, so that new and existing features of the PC can be exploited 
much better than is possible presently.<br>
<br>
 As the information available 
on Direct3D is quite a lot, we will present the information on Direct3D using 
three tutorials, with each covering a different aspect of Direct3D. The three 
tutorials are:<br>

<ul> 
<li>Overview of Direct3D</li> 
<li>Direct3D Retained Mode</li> 
<li>Direct3D Immediate Mode</li> </ul> As we mentioned before, Direct3D is one 
of the APIs in a set, available for application development. Direct3D is 
available to the developer as an API, using which, applications utilizing 3D 
graphics can be developed much faster using a standard way. The Direct3D API is 
part of DirectX.<br>
<br>
<br>
<strong>DirectX</strong> <br>
<br>
 DirectX is a 
set of APIs, available as COM (Component Object Model) objects. These APIs 
provide objects and functions for developing real-time, high-performance 
applications on the Windows platform.<br>
<br>
 The primary motivation for 
developing these libraries is that the performance of existing Windows 
applications catering to graphics intensive application like games and 
multimedia is very poor in comparison to the same applications developed on 
DOS. The DirectX set has been developed keeping this need for high performance 
in mind, and it provides a standard, robust platform for developing such 
applications.<br>
<br>
 DirectX provides a standard, robust platform to 
application developers, by guaranteeing hardware independence. This is done by 
providing a consistent interface to the hardware. Due to this, the complexity 
of software development is reduced and the incompatibilities between the 
hardware platforms is neutralized as far as possible. The present applications, 
written in DOS, have to take care of the different hardware configurations, 
making them quite configuration specific and harder to port to different 
configurations. By providing a consistent interface across all hardware 
platforms, taking care of incompatibilities is shifted away from the 
application developer, resulting in less code and hence faster development.<br>

<br> Hardware independence is guaranteed by DirectX, by providing requirement 
guidelines to all hardware vendors. Due to these guidelines, it is ensured that 
at least minimal support is guaranteed to the applications.<br>
<br>
 DirectX 
is not a single entity, but a collection of closely interacting and 
interdependent applications. The components of DirectX are:<br>
<br>
<strong>
DirectDraw</strong> <br>

<blockquote> - for 2D interactions, like fast 2D blitting (bit block 
transfers), overlays, etc</blockquote> <strong>DirectSound</strong> <br>

<blockquote> - for incorporating soung into applications </blockquote> <strong>
DirectPlay</strong> <br>

<blockquote> - for incorporating multiple users into the applications, using 
the network for communicating between the users</blockquote> <strong>Direct3D
</strong> <br>

<blockquote> - for incorporating 3D capabilities into applications 
</blockquote> <strong>DirectInput</strong> <br>

<blockquote> - for incorporating support for other peripherals, like 
joysticks, into the applications</blockquote> Of these components, let us 
briefly cover the DirectDraw component, before covering the overview of 
Direct3D.<br>
<br>
<strong>DirectDraw</strong> <br>
<br>
 The DirectDraw 
component is important, as many of its features are used either directly or 
indirectly by the Direct3D component of DirectX.<br>
<br>
 The DirectDraw 
component is implemented in hardware and software. DirectDraw is the only 
client of the DirectDraw hardware abstraction layer (HAL). The HAL protects the 
application from the differences of the different hardware. Applications using 
DirectDraw only communicate with DirectDraw and cannot access the HAL directly 
or indirectly.<br>
<br>
 DirectDraw improves performance by providing support 
for 2D functions of the applications. It provides direct access to the off 
screen bitmaps, making access faster.<br>
<br>
 It also provides fast access to 
a blitting (bit block transfer) and buffer flipping. Some of the other features 
include support for transparent blitting and support for overlays, for 
implementing sprites and managing multiple layers of animation.<br>
<br>
 All 
these features help in drastically improving the performance of the Windows 
applications as compared to Windows applications written without such support.
<br> <br>
<br>
<strong>DirectDraw Objects</strong> <br>
<br>
 An application 
using DirectDraw, uses two objects, namely DirectDraw and DirectDrawSurface. 
The DirectDraw object represents the display adapter card. The 
DirectDrawSufrace object represents the display memory, on which the data to be 
displayed is rendered.<br>
<br>
 Applications can also make use of additional 
objects like DirectDrawPalette and DirectDrawClipper.<br>
<br>
<br>
<strong>
Common Usage</strong> <br>
<br>
 A standard method of using DirectDraw is given 
below:<br>

<ul> 
<li>Create the front buffer and back buffer (to exchange the images)</li> 
<li>Images to be displayed are written to the back buffer, instead of directly 
to the screen</li> 
<li>At the end of drawing, the screen is updated by flipping the back and the 
front buffers. After this flipping operation, the back buffer becomes the 
current front buffer while the front buffer becomes the current back buffer</li>
</ul> <br>
<br>
<strong>Direct3D</strong> <br>
<br>
 After taking a brief look 
at the capabilities of DirectDraw, let us come to the overview of Direct3D.<br>

<br> <strong>Introduction</strong> <br>
<br>
 Direct3D, is part of DirectX and 
is the component that helps us integrate 3D into Windows applications. Direct3D 
is used to develop real-time, interactive, 3D applications.<br>
<br>
 For 
developing these applications, Direct3D provides the following features:<br>

<br> <strong>Device independence</strong> <br>

<blockquote> - helps shield the applications from the vagaries of the 
different hardware platforms. As a result of this, applications become 
independent of the hardware platform and hence become more portable</blockquote>
<strong>Common driver model to hardware</strong> <br>

<blockquote> - guarantees to applications, that all the drivers supporting 
Direct3D will support a defined minimal set of features and capabilities. Due 
to this, applications developed using such features will work on all hardware 
platforms. Additionally, Direct3D provides a specification to all hardware 
developers, which help their cards support the various Direct3D features. 
Applications using these features will see a boost in performance</blockquote> 
<strong>Eases addition of 3D to applications</strong> <br>

<blockquote> - as Direct3D provides a standard mechanism and a standard set of 
algorithms for 3D graphics, applications requiring such features can be 
developed much faster. Additionally, the time spent in developing such well 
known and well defined techniques is saved, helping in developing applications 
faster</blockquote> <strong>Transparent access to hardware acceleration</strong>
<br> 
<blockquote> - is one of the very important features of Direct3D, which uses 
the hardware support, if available. In case a hardware platform does not 
support a certain feature, Direct3D provides an equivalent implementation in 
software. This choice of using the hardware features if available, is 
transparent to the user. The application, at runtime can detect the hardware 
capabilities and use them if present</blockquote> In addition to these 
features, Direct3D provides a fast software based rendering of the full 3D 
rendering pipeline. Applications developed using Direct3D are scalable as a 
part or whole of the 3D rendering pipeline can be in the hardware and Direct3D 
can make use of it, if it is detected.<br>
<br>
 A possible restriction on 
Direct3D is the tight restriction with DirectX and its different components.<br>
<br> The features of Direct3D are available to the user in two different ways. 
These are through the two modes of Direct3D, namely: the retained mode and the 
immediate mode. The retained mode is a high-level interface, while the 
immediate mode is a lower-level interface to the features of Direct3D. The two 
modes are discussed in details in separate tutorials. For detailed discussions 
of the retained mode and the immediate mode, refer [8] and [7] respectively.<br>
<br> <strong>Place</strong> <br>
<br>
 Figure 1 shows the different parts of 
Direct3D, in relation to the other modules of a Win32 system.<br>
<br>

<p> <br>
<strong>Figure 1:</strong> Place of Direct3D<br>
</p> <br>
 From 
figure 1, it is clear that the retained mode uses the immediate mode, 
transparent to the developer using the retained mode. The developer is not made 
aware of this usage. From the figure, it is also clear that the retained mode 
also uses some features of DirectDraw. The retained mode, the immediate mode 
and the Direct3D HAL, together, constitute the Direct3D component of DirectX.
<br> <br>
 Though many of the existing programs for 3D graphics on the Windows 
platform talk to the different parts directly, it is envisaged that the 
DirectDraw and Direct3D components of DirectX will be incorporated into future 
versions of Win32 systems. Any system providing 3D, will have to use Direct3D 
to provide its own features.<br>
<br>
<strong>Layers</strong> <br>
<br>
 
Direct3D uses two layers, namely the Hardware Abstraction Layer (HAL) and the 
Hardware Emulation Layer (HEL).<br>
<br>
 All of the features of Direct3D are 
built on top of the HAL, which provides hardware independence and makes 
applications portable.<br>
<br>
 The HEL is a companion of Direct3D and 
provides software emulation for the features of the 3D rendering pipeline, not 
supported by the hardware. This layer is tightly integrated with the DirectDraw 
HAL and the Graphics Device Interface (GDI) driver of the Win32 system. This 
layer helps provide a unified driver model for accelerated 3D.<br>
<br>
<br>

<strong>Rendering Engine</strong> <br>
<br>
 The rendering engine forms an 
important part of Direct3D. It is responsible for taking a scene definition in 
terms of points in 3D, the different texture specifications, the lights and the 
camera specifications, and rendering ready, so that it can be displayed on the 
display device.<br>
<br>
 The functionality of the rendering engine is provided 
using three modules, namely the<em>transformation module</em>, the <em>lighting 
module</em> and the <em>rasterization module</em>. Each of these modules can be 
hardware accelerated, transparent to the user of the application. The 
application developer only has to put the detection facility into the 
application, which will allow it to query the hardware to find and use its 
capabilities, if present.<br>
<br>
 Figure 2 shows the three modules of the 
rendering engine and their interactions with the Direct3D API, before 
displaying the results on the rendering target, which is the 2D display 
surface. The diagram shows the sequence of operations performed on the data, 
before it is displayed.<br>
<br>

<p><br>
<strong>Figure 2:</strong> Rendering Engine Modules<br>
</p> <br>
 The 
3D data to be displayed, is given to the transformation module, which maps the 
3D data onto its equivalent 2D data. This 2D data is then given to the lighting 
module, which calculates the light received by the data, considering the lights 
in the scene. The lit data is then given to the rasterization module, which 
calculates the transparency and applies the texture to the data. After 
rasterization, the data is 2D, lit using the different lights in the scene and 
may also have the specified texture maps applied to them.<br>
<br>
 Let us now 
consider each of the modules in a bit more detail.<br>
<br>
<strong>
Transformation Module</strong> <br>
<br>
 The transformation module is the 
first of the three modules of the rendering engine. This module handles the 
geometry transformations in the rendering engine. To do this, it uses three 
four-by-four (4x4) matrices, namely the<em>view transformation matrix</em>, the 
<em>world transformation matrix</em> and the <em>projection matrix</em>. For an 
explanation of these three matrices, refer [5], [6], [11], [12], [13] and [14]. 
The three matrices are maintained in three state registers, namely the viewing 
matrix, the world matrix and the projection matrix, respectively. This module 
uses one more state register, the viewport, for holding the dimensions of the 
2D display area.<br>
<br>
 The transformation module combines all the matrices 
into one composite matrix and uses this for computations, as using only one 
matrix, as opposed to four, speeds up the calculations in the application.<br>

<br> It is possible to set the states of the state registers separately, in 
addition to setting the value of the composite matrix. But, it is advisable to 
let Direct3D calculate the composite matrix, as the matrix multiplication 
operations required, have been specially optimized in Direct3D. Additionally, 
the newer versions of DirectX make use of MMX technology.<br>
<br>
 Figure 3 
shows a diagrammatic representation of the transformation module.<br>
<br>

<p><br>
<strong>Figure 3:</strong> Transformation Module<br>
</p> <br>
<strong>
Lighting Module</strong> <br>
<br>
 The lighting module of the rendering engine 
is the second of the three modules. It uses the data provided by the 
transformation module and calculates the lighting information for the received 
data.<br>
<br>
 This module maintains a stack of the current lights and the 
ambient light level and the different material properties of the data. All this 
information is used while calculating the light falling at a particular point 
in the scene.<br>
<br>
 Figure 4 shows a diagrammatic representation of the 
lighting module.<br>
<br>

<p><br>
<strong>Figure 4:</strong> Lighting Module<br>
</p> <br>
 The lighting 
module can be operated in any one of the two lighting models it supports. The 
two models supported are:<br>
<br>
<strong>Monochromatic model</strong> <br>

<blockquote> - also known as the <strong>ramp</strong> model. This model uses 
only the gray component of each light source specified in the scene, to 
calculate a single shade value. This shade value is the diffuse component. 
Though this model supports multiple light sources, the colour components of the 
lights are ignored.<br>
<br>
 A restriction of this model is that only gray 
shades can be displayed and the textures used have to be of 8-bit depth. An 
advantage of this model over the RGB model is that it gives better performance 
than the RGB model.</blockquote> <strong>RGB model</strong> <br>

<blockquote> - is the other model supported by the lighting module of the 
rendering engine. This model helps produce more realistic effects of the given 
scene, as it uses the full colour content of the light sources and the material 
of the object being lit. This model supports multiple coloured light sources.
<br> <br>
 A limitation of this model is that it may produce a banding effect 
if the colour depth available is not very good. In the banding effect, the 
transition from one colour to another, is not smooth. It is as if two different 
coloured bands have been placed side-by-side. This effect is produced when the 
number of pixels available for representing the colours is far less than the 
number of colours actually required by the application to display the data 
properly. Also, its performance as compared to the monochromatic model may be 
less</blockquote> <strong>Rasterization Module</strong> <br>
<br>
 The 
rasterization module is the last of the three modules of the rendering engine. 
This module takes only execute calls and the data and displays it onto the 
display surface.<br>
<br>
 On being given the execute call, the module goes 
through the list of vertices to be displayed and generates the transfomed 
vertices to be rendered. Clipping parameters can also be specified in this 
module. The module also culls back-facing triangles, viz. the triangles whose 
surface normals face away from the camera. An important point about this module 
is that it renders only clockwise oriented triangles.<br>
<br>
 Figure 5 shows 
a diagrammatic representation of the rasterization module.<br>
<br>

<p><br>
<strong>Figure 5:</strong> Rasterization Module<br>
</p> <br>
 For 
more details on the Direct3D API and its features, refer [3] and [2].<br>
<br>

<br> <strong>File Format</strong> <br>
<br>
 Though we have said until now that 
Direct3D can be used to display 3D data and though it is possible to generate 
3D data on the fly, it is very difficult and restrictive to store information 
of various complex models and scenes, typically used in 3D systems, directly 
inside the application. Usually, a 3D scene is specified using a data file, 
which provides all the relevant information required for rendering purposes.<br>
<br> Though Direct3D does not provide a file format for specifying whole 
scenes, it provides a file format to specify a 3D mesh object that can be 
placed in a scene.<br>
<br>
 This file format is template driven and is 
architecture neutral and context free. It is also extensible and new templates 
can be added very easily. The file format allows storage of predefined object 
meshes, texture and animations, in addition to allows storage of user defined 
objects. Applications can define higher-level templates using existing 
lower-level or other higher-level templates.<br>
<br>
 The file format is the 
DirectX file format and has a ``.x'' extension. It is also called the ``xof'' 
file. This file format is natively supported and used by the retained mode, 
which provides objects and methods to read, save and manipulate a file.<br>
<br>
 The file format allows specification of fixed path animations and also 
supports instancing of objects, which helps in reuse of data sets and hence 
reducing the total size of the object being manipulated.<br>
<br>
 Let us now 
consider the details of the file format.<br>
<br>
 A data file can be split 
into three parts, namely: header, template and data. Each of the parts is 
described in the following sections.<br>
<br>
<strong>Header</strong> <br>
<br>

 The header part contains information which helps identify the file. It is 
compulsory at the beginning of the file. The header consists of a magic number 
(``xof''), which identifies the file and the major and minor version numbers of 
the file. These numbers can be used to take care of versioning problems in data 
files, if required.<br>
<br>
 The version numbers are followed by the format 
type, which can be one of the following:<br>

<ul> 
<li>``txt'' - text file</li> 
<li>``bin'' - binary file</li> 
<li>``com'' - compressed file</li> </ul> If the file is a compressed file, the 
compression type is specified following the format type. The compression type 
can be one of the following:<br>

<ul> 
<li>``lzw'' - LZW compression algorithm</li> 
<li>``zip''</li> </ul> The compression type is followed by 4 digits, which 
indicate the number of bits used to represent floating point numbers.<br>
<br>

<strong>Template</strong> <br>
<br>
 The different templates used in the file 
follow the header information. A template defines how a data stream is to be 
interpreted by the reader of the file.<br>
<br>
 A template is specified using 
a skeleton, as shown in figure 6.<br>
<br>

<pre> template &lt;name&gt; {<br>
 &lt;UUID&gt;<br>
 &lt;member 1&gt;<br>
 . . 
. .<br>
 &lt;member n&gt;<br>
 [restrictions]<br>
} </pre> 
<p><strong><br>
 Figure 6:</strong> Template Specification Skeleton <br>
</p> 
<br> A template has a name, which is used to identify the data type being read, 
when it is encountered. The name is followed by the UUID (Universally Unique 
IDentifier) of the COM object to be used to read this template when it is 
encountered. The UUID is followed by a list of members of the template. The 
member list can be followed by an optional list of restrictions that need to be 
observed while reading the data or creating the data structure to hold the read 
data.<br>
<br>
<strong>Data</strong> <br>
<br>
 This part contains the actual 
object information. The data part can either store actual data or a reference 
to the data. This referencing is used for the feature of instancing, supported 
by the file format. The feature of instancing allows reference to an data set, 
if it is required at multiple places, instead of replicating all the data 
elements. Each data object is read using a corresponding template object. All 
data objects have to belong to one of the templates specified after the header.
<br> <br>
 The data is specified using a template skeleton, as illustrated in 
figure 7.<br>
<br>

<pre> &lt;id&gt; [name] {<br>
 &lt;member 1&gt;<br>
 . . . .<br>
 &lt;member 
n&gt;<br>
} </pre> 
<p> <strong>Figure 7:</strong> Data Format Skeleton <br>
</p> <strong><br>

Sample Data File</strong> <br>
<br>
 A sample data file, to help understand the 
file format is presented in appendix A.<br>
<br>
<br>
<strong>DirectX and COM
</strong> <br>
<br>
 Before we conclude the overview on Direct3D, we would like 
to briefly comment in the relationship between DirectX and the Component Object 
Model (COM), and its usage.<br>
<br>
 DirectX is based on the principles of 
COM, which allow us to develop and distribute the required functionality, 
packaged as components or objects. Most of the objects and interfaces in 
DirectX are based on COM and many of the DirectX APIs are instantiated as a set 
of OLE objects.<br>
<br>
<strong>COM Interface</strong> <br>
<br>
 All the 
functions supported by a COM object are available as interfaces of that object. 
An interface is nothing but a group of related functions. The user of a 
component has to query the component for an interface. If an interface is 
supported by an object, a reference is returned, which in turn can be used to 
access the different methods provided in the interface.<br>
<br>
<strong>
IUnknown</strong> <br>
<br>
 To allow a component user to query for an 
interface, all COM objects have to be derived from the standard<em>IUnknown</em>
 interface. This interface provides three methods, namely<em>AddRef</em>, <em>
QueryInterface</em> and <em>Release</em>. <br>
<br>
<strong>AddRef</strong> <br>
<br> All COM objects work on the principle of reference counting. Whenever a 
COM object is used, its reference count is incremented by one. The reference 
count is decremented by one, when the object is released, using the<em>Release
</em> method. An object is a valid candidate for garbage collection, when its 
reference count becomes zero.<br>
<br>
<strong>QueryInterface</strong> <br>
<br>
 This method is used to query an object for its supported interface and hence 
the supported methods. The supported features can be accessed by asking for a 
specific interface from the COM object. If the interface is supported,<em>
QueryInterface</em> returns a pointer to the interface and calls <em>AddRef</em>
 to increment the reference count on the COM object. It is the responsibility 
of the application to call<em>Release</em>, after its work with the COM object 
is over. After getting a pointer to the interface, the application can call 
specific methods from the interface, to get its job done.<br>
<br>
 Typically, 
DirectX provides one object per device.<br>
<br>
<strong>COM Advantage</strong> 
<br> <br>
 An advantage that we get by using COM is that we can have language 
independence between the COM object and its users. What this means is that a 
COM object can be used irrespective of the language being used for developing 
the application requiring 3D capabilities.<br>
<br>
 Though many languages can 
be used with COM objects the languages we briefly cover are the C programming 
language and the C++ programming language. We are considering these two 
languages as they are the part of the primary languages being used to develop 
applications and that the differences between using these languages though not 
being very major, are significant. Using these languages does not change the 
way we use COM objects for incorporating 3D content into our applications. 
Another motivating factor for choosing these two languages is the comfort level 
of the authors, in using these languages.<br>
<br>
 For more details on COM and 
its usage with other languages, refer [1].<br>
<br>
<strong>C++ and COM</strong>
<br> <br>
 Code written C++ and COM is less complex that equivalent code 
written in C and COM. In C++, a COM interface is like an abstract base class, 
with all methods being pure virtual. Both C++ and COM use virtual tables 
(vtable) for pure virtual functions.<br>
<br>
 When COM objects are used 
through C++, the<em>QueryInterface</em> method returns a pointer to the virtual 
table and the different methods supported by the object can be accessed 
directly.<br>
<br>
 The sample in source listing 1 illustrates the usage of COM 
objects through C++.<br>
<br>

<pre> LPDIRECT3DRM lpD3DRM; // Direct3D object<br>
LPDIRECT3DRMDEVICE dev; // 
Direct3DRM device<br>
// viewport through which the scene is viewed<br>

LPDIRECT3DRMVIEWPORT view;<br>
LPDIRECT3DRMFRAME camera; // camera<br>
. . .<br>
. . .<br>
Direct3DRMCreate(&amp;lpD3DRM);<br>
. . .<br>
. . .<br>

lpD3DRM-&gt;CreateViewport(device, camera,<br>
 0, 0, width, height, &amp;view);
<br>. . .<br>
. . .<br>
view-&gt;Release(); </pre> In this sample, the <em>
QueryInterface</em> method is being invoked for us by the <em>Direct3DRMCreate
</em> function. This function returns a pointer to the <em>Direct3DRM</em> 
(Direct3D Retained Mode) object, which provides different methods like creation 
of a viewport, loading a mesh, etc. Notice that we are not calling the<em>AddRef
</em> explicitly, but we are calling the <em>Release</em> method, after using 
the COM object.<br>
<br>
<strong>C and COM</strong> <br>
<br>
 A major 
difference between using C and C++ and COM is that the<em>QueryInterface</em> 
method does no return a pointer to the virtual table, when COM objects are used 
through C. The methods of the COM object have to be explicitly invoked through 
the virtual table as is illustrated in the sample code in source listing 2.<br>

<br> 
<pre> // The methods of the COM object have to be explicitly invoked through
<br>// the virtual table as is illustrated below<br>
<br>
LPDIRECT3DRM lpD3DRM; 
// Direct3D object<br>
LPDIRECT3DRMDEVICE dev; // Direct3DRM device <br>
// 
viewport through which the scene is viewed<br>
LPDIRECT3DRMVIEWPORT view;<br>

LPDIRECT3DRMFRAME camera; // camera<br>
. . .<br>
. . .<br>

Direct3DRMCreate(&amp;lpD3DRM);<br>
. . .<br>
. . .<br>

lpD3DRM-&gt;lpVtbl-&gt;CreateViewport(lpD3DRM, device,<br>
 camera, 0, 0, 
width, height, &amp;view);<br>
. . .<br>
. . .<br>

view-&gt;lpVtbl-&gt;Release(view);</pre> Note the explicit use of the pointer 
to the virtual table<strong>lpVtbl</strong> and passing of the object itself as 
the first parameter in each method call.<br>
<br>
 A few points to be 
remembered while using COM objects through C are:<br>

<ul> 
<li>The first parameter of each method call on an object, has to refer to the 
object on which the methods is being invoked</li> 
<li>Each method of an object has to be explicitly accessed through the pointer 
to the virtual table (<strong>lpVtbl</strong>)</li> </ul> <strong>Notes on 
Programming</strong> <br>
<br>
 For developing applications using Direct3D on 
Windows, knowledge of Windows programming using the SDK or MFC is necessary. 
For more details on programming using SDK and using MFC, refer [9] and [10] 
respectively.<br>
<br>
<br>
<strong>Summary</strong> <br>
<br>
 In this 
tutorial, we have seen that Direct3D is one of the components of DirectX and is 
an API for 3D graphics programming. This API gives hardware independence in 
addition to transparent hardware acceleration and a fast software based 
emulation for missing hardware implementations of the rendering pipeline. We 
saw that the rendering engine of Direct3D consists of three modules, namely the 
transformation module, the lighting module and the rasterization module. We 
mentioned the different modes in which Direct3D can be operated, namely the 
retained mode and the immediate mode.<br>
<br>
 Then we covered the file format 
used to represent the data objects and the relationship of Direct3D to COM and 
its usage in the C++ and C programming languages.<br>
<br>
<strong>Appendix A
</strong> <br>
<br>
 This section presents a sample data file. The data file 
specifies a cube.<br>
<br>

<pre> // Appendix A - This section presents a sample data file.<br>
// The 
data file specifies a cube<br>
<br>
xof 0302txt 0064<br>
template Header {<br>
 
&lt;3D82AB43-62DA-11cf-AB39-0020AF71E433&gt;<br>
 WORD major;<br>
 WORD minor;
<br> DWORD flags;<br>
}<br>
<br>
template Vector {<br>
 
&lt;3D82AB5E-62DA-11cf-AB39-0020AF71E433&gt;<br>
 FLOAT x;<br>
 FLOAT y;<br>
 
FLOAT z;<br>
}<br>
<br>
template Coords2d {<br>
 
&lt;F6F23F44-7686-11cf-8F52-0040333594A3&gt;<br>
 FLOAT u;<br>
 FLOAT v;<br>
}
<br><br>
template Matrix4x4 {<br>
 &lt;F6F23F45-7686-11cf-8F52-0040333594A3&gt;
<br> array FLOAT matrix[16];<br>
}<br>
<br>
template ColorRGBA {<br>
 
&lt;35FF44E0-6C7C-11cf-8F52-0040333594A3&gt;<br>
 FLOAT red;<br>
 FLOAT green;
<br> FLOAT blue;<br>
 FLOAT alpha;<br>
}<br>
<br>
template ColorRGB {<br>
 
&lt;D3E16E81-7835-11cf-8F52-0040333594A3&gt;<br>
 FLOAT red;<br>
 FLOAT green;
<br> FLOAT blue;<br>
}<br>
<br>
template IndexedColor {<br>
 
&lt;1630B820-7842-11cf-8F52-0040333594A3&gt;<br>
 DWORD index;<br>
 ColorRGBA 
indexColor;<br>
}<br>
<br>
template Boolean {<br>
 
&lt;4885AE61-78E8-11cf-8F52-0040333594A3&gt;<br>
 WORD truefalse;<br>
}<br>
<br>
template Boolean2d {<br>
 &lt;4885AE63-78E8-11cf-8F52-0040333594A3&gt;<br>
 
Boolean u;<br>
 Boolean v;<br>
}<br>
<br>
template MaterialWrap {<br>
 
&lt;4885AE60-78E8-11cf-8F52-0040333594A3&gt;<br>
 Boolean u;<br>
 Boolean v;<br>
}<br>
<br>
template TextureFilename {<br>
 
&lt;A42790E1-7810-11cf-8F52-0040333594A3&gt;<br>
 STRING filename;<br>
}<br>

<br>template Material {<br>
 &lt;3D82AB4D-62DA-11cf-AB39-0020AF71E433&gt;<br>
 
ColorRGBA faceColor;<br>
 FLOAT power;<br>
 ColorRGB specularColor;<br>
 
ColorRGB emissiveColor;<br>
 [...]<br>
}<br>
<br>
template MeshFace {<br>
 
&lt;3D82AB5F-62DA-11cf-AB39-0020AF71E433&gt;<br>
 DWORD nFaceVertexIndices;<br>

 array DWORD faceVertexIndices[nFaceVertexIndices];<br>
}<br>
<br>
template 
MeshFaceWraps {<br>
 &lt;4885AE62-78E8-11cf-8F52-0040333594A3&gt;<br>
 DWORD 
nFaceWrapValues;<br>
 Boolean2d faceWrapValues;<br>
}<br>
<br>
template 
MeshTextureCoords {<br>
 &lt;F6F23F40-7686-11cf-8F52-0040333594A3&gt;<br>
 
DWORD nTextureCoords;<br>
 array Coords2d textureCoords[nTextureCoords];<br>
}
<br><br>
template MeshMaterialList {<br>
 
&lt;F6F23F42-7686-11cf-8F52-0040333594A3&gt;<br>
 DWORD nMaterials;<br>
 DWORD 
nFaceIndexes;<br>
 array DWORD faceIndexes[nFaceIndexes];<br>
 [Material]<br>
}
<br><br>
template MeshNormals {<br>
 
&lt;F6F23F43-7686-11cf-8F52-0040333594A3&gt;<br>
 DWORD nNormals;<br>
 array 
Vector normals[nNormals];<br>
 DWORD nFaceNormals;<br>
 array MeshFace 
faceNormals[nFaceNormals];<br>
}<br>
<br>
template MeshVertexColors {<br>
 
&lt;1630B821-7842-11cf-8F52-0040333594A3&gt;<br>
 DWORD nVertexColors;<br>
 
array IndexedColor vertexColors[nVertexColors];<br>
}<br>
<br>
template Mesh {
<br> &lt;3D82AB44-62DA-11cf-AB39-0020AF71E433&gt;<br>
 DWORD nVertices;<br>
 
array Vector vertices[nVertices];<br>
 DWORD nFaces;<br>
 array MeshFace 
faces[nFaces];<br>
 [...]<br>
}<br>
<br>
template FrameTransformMatrix {<br>
 
&lt;F6F23F41-7686-11cf-8F52-0040333594A3&gt;<br>
 Matrix4x4 frameMatrix;<br>
}
<br><br>
template Frame {<br>
 &lt;3D82AB46-62DA-11cf-AB39-0020AF71E433&gt;<br>

 [...]<br>
}<br>
<br>
Header {<br>
 1;<br>
 0;<br>
 1;<br>
}<br>
<br>
Material 
x3ds_mat_GREEN_0_ {<br>
 0.000000, 0.666667, 0.000000, 1.000000;;<br>
 
15.000000;<br>
 0.874510, 1.000000, 0.839216;;<br>
 0.00, 0.00, 0.00;;<br>
}<br>
<br>Frame x3ds_cube {<br>
 Mesh cube {<br>
 8;<br>
 -40.000000; -30.000000; 
-49.999996;,<br>
 40.000000; -30.000000; -49.999996;,<br>
 40.000000; 
29.999998; -50.000000;,<br>
 -40.000000; 29.999998; -50.000000;,<br>
 
-40.000000; -30.000000; 50.000000;,<br>
 40.000000; -30.000000; 50.000000;,<br>

 40.000000; 30.000000; 50.000000;,<br>
 -40.000000; 30.000000; 50.000000;;<br>
 
12;<br>
 3;0,2,1;,<br>
 3;0,3,2;,<br>
 3;0,5,4;,<br>
 3;0,1,5;,<br>
 3;1,6,5;,
<br> 3;1,2,6;,<br>
 3;2,7,6;,<br>
 3;2,3,7;,<br>
 3;3,4,7;,<br>
 3;3,0,4;,<br>
 
3;4,6,7;,<br>
 3;4,5,6;;<br>
 MeshMaterialList {<br>
 1;<br>
 12;<br>
 0,<br>
 
0,<br>
 0,<br>
 0,<br>
 0,<br>
 0,<br>
 0,<br>
 0,<br>
 0,<br>
 0,<br>
 0,<br>
 
0;<br>
 {x3ds_mat_GREEN_0_}<br>
 }<br>
 MeshNormals {<br>
 24;<br>
 
0.000000;-0.000000;-1.000000;,<br>
 0.000000;-1.000000;0.000000;,<br>
 
-1.000000;0.000000;0.000000;,<br>
 0.000000;-0.000000;-1.000000;,<br>
 
0.000000;-1.000000;0.000000;,<br>
 1.000000;0.000000;0.000000;,<br>
 
0.000000;-0.000000;-1.000000;,<br>
 1.000000;0.000000;0.000000;,<br>
 
-0.000000;1.000000;-0.000000;,<br>
 0.000000;-0.000000;-1.000000;,<br>
 
0.000000;1.000000;-0.000000;,<br>
 -1.000000;0.000000;0.000000;,<br>
 
0.000000;-1.000000;0.000000;,<br>
 -1.000000;0.000000;0.000000;,<br>
 
0.000000;0.000000;1.000000;,<br>
 0.000000;-1.000000;0.000000;,<br>
 
1.000000;0.000000;0.000000;,<br>
 0.000000;0.000000;1.000000;,<br>
 
1.000000;0.000000;0.000000;,<br>
 -0.000000;1.000000;-0.000000;,<br>
 
0.000000;0.000000;1.000000;,<br>
 -0.000000;1.000000;-0.000000;,<br>
 
-1.000000;0.000000;0.000000;,<br>
 0.000000;0.000000;1.000000;;<br>
 12;<br>
 
3;0,6,3;,<br>
 3;0,9,6;,<br>
 3;1,15,12;,<br>
 3;1,4,15;,<br>
 3;5,18,16;,<br>
 
3;5,7,18;,<br>
 3;8,21,19;,<br>
 3;8,10,21;,<br>
 3;11,13,22;,<br>
 3;11,2,13;,
<br> 3;14,20,23;,<br>
 3;14,17,20;;<br>
 }<br>
 }<br>
} </pre> <strong>
References</strong> <br>
<br>
<strong>1</strong> <br>

<blockquote> Kraig Brockschmidt. <em>Inside OLE</em>. Microsoft Press, 2nd 
edition, 1995.</blockquote> <strong>2</strong> <br>

<blockquote> Microsoft Corporation. <em>DirectX SDK (ver 3.0, 5.0) Reference
</em>. Microsoft Corporation, 1996-97. </blockquote> <strong>3</strong> <br>

<blockquote> Microsoft Corporation. <em>Direct3D Reference Manual</em>. 
Microsoft Corporation, 1997. Visual Studio Help.</blockquote> <strong>4</strong>
<br> 
<blockquote> Microsoft Corporation. DirectX File Format Specification, ver 
1.13.<em>Microsoft Corporation Web Page (www.microsoft.com/directx)</em>, 1997. 
</blockquote> <strong>5</strong> <br>

<blockquote> Foley and Van Damm. <em>Introduction to Computer Graphics</em>. 
Addison Wesley, 1994.</blockquote> <strong>6</strong> <br>

<blockquote> Donald Hearn and Pauline Baker. <em>Computer Graphics</em>. 
Prentice Hall of India, 2nd edition, 1994.</blockquote> <strong>7</strong> <br>

<blockquote> Bipin Patwardhan. Direct3D Immediate Mode. National Centre for 
Software Technology, Mumbai, India, Aug-Sep 1997. Intel Developers Conference, 
Aug-Sep 97.</blockquote> <strong>8</strong> <br>

<blockquote> Bipin Patwardhan. Direct3D Retained Mode. National Centre for 
Software Technology, Mumbai, India, Aug-Sep 1997. Intel Developers Conference, 
Aug-Sep 97.</blockquote> <strong>9</strong> <br>

<blockquote> Charles Petzold. <em>Windows 95 Programming</em>. Microsoft 
Press, 1st edition, 1996.</blockquote> <strong>10</strong> <br>

<blockquote> Jeff Prosise. <em>Windows 95 Programming Using MFC</em>. 
Microsoft Press, 1st edition, 1997.</blockquote> <strong>11</strong> <br>

<blockquote> David Rogers. <em>Procedural Elements for Computer Graphics</em>. 
McGraw-Hill Book Company, 1st edition, 1985.</blockquote> <strong>12</strong> 
<br> 
<blockquote> David Rogers. <em>Mathematical Elements for Computer Graphics</em>
. McGraw-Hill Book Company, 2nd edition, 1990.</blockquote> <strong>13</strong> 
<br> 
<blockquote> Alan Watt. <em>Fundamentals of Three Dimensional Computer Graphics
</em>. Addison Wesley, 1989. </blockquote> <strong>14</strong> <br>

<blockquote> Alan Watt. <em>3D Computer Graphics</em>. Addison Wesley, 2nd 
edition, 1993.</blockquote> <br>
 Bipin Patwardhan <br>
 National Centre for 
Software Technology, Juhu, Mumbai, India.<br>
 email: bipin@ncst.ernet.in <br>

<br> <br>
<br>
Compare Revision Date Title Editor <br>
<b>4</b> Jun 29 2011 
06:12 AM <strong>An Overview of Direct3D</strong>  Gaiiden <br>
<b>3</b> Jun 29 
2011 06:10 AM <strong>An Overview of Direct3D</strong>  Gaiiden <br>
<b>2</b> 
Jun 29 2011 06:10 AM <strong>An Overview of Direct3D</strong>  Gaiiden <br>
<b>1
</b> Jun 29 2011 05:53 AM <strong>An Overview of Direct3D</strong>  Gaiiden <br>
<br> <br>
<br>
<strong>Developing a Mobile Application with Flash</strong> 
<ul> 
<li>5 comments</li> 
<li>3934 views</li> </ul> <br>
<strong>Video Game Localisation - A Tricky Game
</strong> 
<ul> 
<li>3 comments</li> 
<li>7344 views</li> </ul> <br>
<strong>Comparing Shadow Mapping Techniques 
with Shadow Explorer</strong> 
<ul> 
<li>7 comments</li> 
<li>10309 views</li> </ul> <br>
<strong>New Incentives and a Whole New 
Platform From The Intel AppUp developer program</strong> 
<ul> 
<li>0 comments</li> 
<li>4741 views</li> </ul> <br>
<strong>Autodesk Previews a Games Production 
Solution</strong> 
<ul> 
<li>1 comments</li> 
<li>8684 views</li> </ul> <br>
<strong>3D in Photoshop: The Ultimate Guide for 
Creative Professionals</strong> 
<ul> 
<li>7 comments</li> 
<li>25871 views</li> </ul> <br>
<strong>Getting your app on Intel AppUp: 
Porting &quot;Ancient Frog&quot;</strong> 
<ul> 
<li>2 comments</li> 
<li>6301 views</li> </ul> <br>
<strong>Why AppUp? A Quick Review of the AppUp 
Model</strong> 
<ul> 
<li>0 comments</li> 
<li>103 views</li> </ul> <br>
<strong>The Game Maker's Companion</strong> 
<ul> 
<li>0 comments</li> 
<li>308 views</li> </ul> <br>
<strong>Interview with Firelight Technologies
</strong> 
<ul> 
<li>1 comments</li> 
<li>918 views</li> </ul> <br>
<strong>Learning iOS Game Programming</strong> 
<ul> 
<li>0 comments</li> 
<li>678 views</li> </ul> <br>
<strong>Real-Time Dynamic Fur on the GPU</strong>
<ul> 
<li>11 comments</li> 
<li>425 views</li> </ul> <br>
<strong>A Super Simple Method for Creating 
Infinite Scenery</strong> 
<ul> 
<li>0 comments</li> 
<li>354 views</li> </ul> <br>
<strong>A Type-safe Generic Pointer</strong> 
<ul> 
<li>11 comments</li> 
<li>173 views</li> </ul> <br>
<strong>A Collection of Examples of 64-bit 
Errors in Real Programs</strong> 
<ul> 
<li>11 comments</li> 
<li>230 views</li> </ul> <br>
<br>

<ul> 
<li></li> 
<li></li> 
<li> <br>
</li> 
<li></li> 
<li></li> 
<li></li> 
<li></li> 
<li></li> </ul> <br>
<br>

<ol> 
<li> &raquo; Articles </li> 
<li> &raquo; Technical </li> 
<li> &raquo; DirectX and XNA </li> 
<li> &raquo; Article: An Overview of Direct3D </li> </ol> 
<ul> 
<li> </li> 
<li> Mark Community Read 
<ul> 
<li> </li> 
<li> Forums </li> 
<li> Developer Journals </li> 
<li> Gallery </li> 
<li> Downloads </li> 
<li> Resources </li> 
<li> Store </li> 
<li> Classifieds </li> 
<li> Tracker </li> 
<li> <strong>Mark all as read</strong> </li> </ul> </li> 
<li> Help </li> </ul>  PARTNERS <br>
<br>
<br>
<br>
<br>
 Copyright &copy; 
1999-2012 GameDev.Net LLC
<p><br>
GameDev.net&trade;, the GameDev.net logo, and GDNet&trade; are 
trademarks of GameDev.net, LLC</p> 
<h5>Navigation</h5> 
<ul> 
<li>Home</li> 
<li>Features</li> 
<li>Community</li> 
<li>Resources</li> 
<li>Careers</li> </ul> 
<h5>Customer Service</h5> 
<ul> 
<li>GDNet+ Subscriptions</li> 
<li>Job Advertising</li> 
<li>Terms of Service</li> 
<li>Privacy Policy</li> </ul> 
<h5>Company Info</h5> 
<ul> 
<li>About Us</li> 
<li>Advertise on Gamedev.net</li> 
<li>Contact Us</li> </ul> <br>
<br>
<br>

</body>