<!doctype html>
<meta charset="utf-8">
<title>C++0x Concepts fall - Page 2</title>
<body>
<br>

<ul> 
<li>Register</li> 
<li> <br>
 Remember Me? <br>
<br>
</li> 
<li> </li> </ul> <br>

<ul> 
<li>Forum 
<ul> 
<li>Today's Posts</li> 
<li>C and C++ FAQ</li> 
<li> Forum Actions 
<ul> 
<li> Mark Forums Read </li> </ul> </li> 
<li> Quick Links 
<ul> 
<li> View Forum Leaders </li> </ul> </li> </ul> </li> 
<li>What's New?</li> 
<li>Get Started with C or C++</li> 
<li>C Tutorial</li> 
<li>C++ Tutorial</li> 
<li>Game Programming Tutorial</li> 
<li>All Tutorials</li> </ul> <br>

<ul> 
<li>Advanced Search</li> </ul> 
<ul> 
<li></li> 
<li>Forum</li> 
<li>Community Boards</li> 
<li>General Discussions</li> 
<li> C++0x Concepts fall</li> </ul> <br>
<br>
<br>

<h1>C++0x Concepts fall</h1> 
<p>This is a discussion on <em>C++0x Concepts fall</em> within the <b>General 
Discussions</b> forums, part of the Community Boards category; In general, 
Direct3D is designed to be a 3D hardware interface. The feature set of Direct3D 
is derived from the ...</p> <br>

<ul> 
<li> 
<h6>LinkBack</h6> 
<ul> 
<li> LinkBack URL</li> 
<li> About LinkBacks</li> 
<li>&nbsp;</li> 
<li>Bookmark &amp; Share</li> 
<li>Digg this Thread!</li> 
<li>Bookmark in Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> 
<li> 
<h6>Thread Tools</h6> 
<ul> 
<li>Show Printable Version</li> 
<li>Email this Page&hellip;</li> 
<li> Subscribe to this Thread&hellip; </li> </ul> </li> 
<li> 
<h6>Display</h6> 
<ul> 
<li>Linear Mode</li> 
<li> Switch to Hybrid Mode</li> 
<li> Switch to Threaded Mode</li> </ul> </li> </ul> 
<ol> 
<li> 07-24-2009 #16 <br>
<strong> BobMcGee123 </strong> <br>
<br>
 &infin; 
<dl> 
<dt> Join Date </dt> 
<dd> May 2005 </dd> 
<dt> Posts </dt> 
<dd> 1,036 </dd> </dl> <br>

<blockquote> <br>
 In general, Direct3D is designed to be a 3D hardware 
interface. The feature set of Direct3D is derived from the feature set of what 
hardware provides. OpenGL, on the other hand, is designed to be a 3D rendering 
system that may be hardware accelerated. These two APIs are fundamentally 
designed under two separate modes of thought. The fact that the two APIs have 
become so similar in functionality shows how well hardware is converging into 
user functionality[citation needed]. Comparison of OpenGL and Direct3D - 
Wikipedia, the free encyclopedia </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> You know what date is on this coin? 1958. It's been travelling 
twenty two years to get here.<br>
 And now it's here. <br>
 And I'm here. <br>
 
And it's either heads or tails.<br>
 And you have to say... <br>
 Call it. <br>

</blockquote> <br>
</li> 
<li> 07-24-2009 #17 <br>
<strong> Brafil </strong> <br>
<br>
 Making mistakes 
<dl> 
<dt> Join Date </dt> 
<dd> Dec 2008 </dd> 
<dt> Posts </dt> 
<dd> 476 </dd> </dl> 
<blockquote> Why is this thread turning into &quot;OpenGL vs Direct3D&quot;? 
<br> <br>
 Anyway, I think concepts are a good idea, but not a great one. I 
understand that they dropped them. Seems like they have understood that they 
were making the language too complex. There are so many things that are added, 
and I doubt there will be a complete reference for C++0x - The current ones for 
&quot;normal&quot; C++ are thick enough.<br>
<br>
 I personally don't like the 
new function definition types nor the new typedef possibilities.<br>
<br>
 But 
I love static_assert and many others.<br>
<br>
 And I don't know who will 
implement all this </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> <br>
</li> 
<li> 07-24-2009 #18 <br>
<strong> bithub </strong> <br>
<br>
 Registered User 
<dl> 
<dt> Join Date </dt> 
<dd> Sep 2004 </dd> 
<dt> Location </dt> 
<dd> California </dd> 
<dt> Posts </dt> 
<dd> 3,242 </dd> </dl> 
<blockquote> <br>
 Why is this thread turning into &quot;OpenGL vs 
Direct3D&quot;? I should not have used that as an example. I forgot how easy it 
was to derail threads simply by mentioning those two words.<br>
<br>
 At any 
rate, I'm just looking forward to the &quot;auto&quot; keyword. Everything else 
is just unnecessary fluff </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> <br>
</li> 
<li> 07-24-2009 #19 <br>
<strong> Mario F. </strong> <br>
<br>
 (?&lt;!re)tired
<dl> 
<dt> Join Date </dt> 
<dd> May 2006 </dd> 
<dt> Location </dt> 
<dd> Portugal </dd> 
<dt> Posts </dt> 
<dd> 6,998 </dd> </dl> 
<blockquote> <br>
 Originally Posted by <strong>Brafil</strong> <br>
 Seems 
like they have understood that they were making the language too complex. I 
have very personal opinions on that matter which probably aren't very popular. 
But I don't see syntax or semantics complexity as such a big problem. But hey, 
here it is...<br>
<br>
 C++ is already a complex language to learn <b>and use
</b>. Certainly adding new features to the language while keeping a close eye 
on complexity is a good goal. But there's three aspects to Concepts that I 
think make the whole &quot;will Joe Coder want to use Concepts&quot; the wrong 
debate. The fact that this is at the core of the decision to abandon Concepts 
on C++0x, since even the implicit or explicit concept mapping discussion has 
its roots on that question, is very disheartening to me. It leaves a foul taste 
in my mouth that politics and frivolous debate was the real issue. Not 
Concepts. A feeling that Herb Sutter'srecent blog post makes even stronger. 
Especially if you then compare that toStroustrup article. <br>
<br>
 But the 
three aspects...<br>
<br>
 1. Can we tell exactly what adds more to complexity? 
Hard to follow syntax and semantics, or weak error diagnostics? It's my feeling 
it is the latter. A hard to follow syntax is invariably going to be learned at 
some point, the same goes for semantics. It's a matter of study. No different 
from so many other professional areas, from accounting to scientific fields. 
But hard to track bugs or hard to understand compiler reports is going to 
strain the coder a lot more. What we have now is a syntax that is somewhat easy 
to teach, semantics somewhat easy to learn, but the coder is left alone trying 
to understand template related errors messages. This is particularly damaging 
to library developers who suffer the most. One of Concepts primary aim was 
exactly to create the necessary groundwork that would help to considerably 
improve current template diagnostics. In my view, this alone makes Concepts a 
feature that reduces programming complexity already.<br>
<br>
 2. C++ is a 
multi-paradigm programming language. This has far more repercussions than just 
the admission we can use different tools for different jobs. It should also be 
the understanding that some jobs simply aren't as easy as others. In C++ 
certain paradigms are definitely harder to grasp than others. For a newcommer 
going from procedural programming to OOP is a big step. The language is made 
harder for them and it will take a long while until all the new concepts, 
semantics and syntax get buried in their brain. It is in my view acceptable 
that Generic Programming is accepted as being even harder. Of course, whenever 
there is a chance to simplify learning and usage one should take it. But this 
can't be the basis for deciding wether a feature is going to be implemented or 
not. Being that Concepts was primarily aimed at Library Developers, does it 
really makes sense to ask &quot;will Joe Coder use Concepts&quot;? Joe Coder 
will use concepts yes. One day, whe, he feels more comfortable with the 
language and decides to step into more complex areas of software development. 
Just like he did a couple of years ago when he decided it was time to go OOP 
and tackle all the incredible complexity of this new paradigm in C++. This has 
also a lot to do with the natural characteristic of C++ of being a modular 
programming language, which makes it easy to teach and learn. And it really 
surprises me the whole debate around complexity vs. simplicity. It's in my 
opinion a mistake to oversimplify or to aim for simplicity above all else. 
&quot;Simple&quot; is often harder or impossible to achieve... should the 
alternative be no feature at all?<br>
<br>
 3. Finally, there's the admission 
that conceptually C++ templates are irreprehensible, but the theoretic basis on 
which they were implemented in C++ is weak. I'm not sure I understand this 
argument very well. But it's a fact that it took me a long time to actually 
soak in the concept of Generic Programming to start taking advantage of it 
beyond simple function templating. However the<i>concept</i> of Concepts was 
immediately understood. It made a whole lot of sense to me. That... and I liked 
it because of that. It just seems, with Concepts, C++ Generic Programming would 
be made easier to teach and learn. Can I be biased by the fact I was already 
aware of Generic Programming<i>concept</i> and its advantages when I first 
started reading about Concepts? It's possible. I may be looking at Concepts as 
easier simply because I understand better now what generic programming is under 
C++. But inm my defense I'll say that I'm in fact a newcmmer to generic 
programming with no more than 1 year on my back and very little to show in 
terms of actual work. So I'd give this 3rd point also some consideration. 
</blockquote> 
<blockquote> Last edited by Mario F.; 07-24-2009 at 10:42 AM. </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> Originally Posted by <b>brewbuck</b>: <br>
<i>Reimplementing a 
large system in another language to get a 25% performance boost is nonsense. It 
would be cheaper to just get a computer which is 25% faster.</i> <br>
<br>

Quiet Technologies... that make some noise. <br>
</blockquote> <br>
</li> 
<li> 07-24-2009 #20 <br>
<strong> <b>CornedBee</b> </strong> <br>
<br>
 Cat 
without Hat 
<dl> 
<dt> Join Date </dt> 
<dd> Apr 2003 </dd> 
<dt> Posts </dt> 
<dd> 8,762 </dd> </dl> 
<blockquote> <br>
 Originally Posted by <strong>phantomotap</strong> <br>
 
&quot;Integration, especially with the library, was a very complex task, and 
uncovered many weaknesses, both of concepts themselves and of other language 
features, such as rvalue references.&quot;<br>
<br>
 O_o <br>
<br>
 Please 
don't tell me &quot;r-value references&quot; were dropped too!? No. <br>
<br>
 
But it was the interaction with concepts that pointed out that it's not safe, 
in general, to let rvalue references bind to lvalues. So they changed it.<br>

<br> It was in the course of concept integration that they discovered that 
throwing move constructors (and moving is closely tied with rvalue refs) are 
completely unsafe - as with throwing destructors, if you have one, you simply 
cannot write exception-safe code. Now they're discussing a &quot;nothrow&quot; 
annotation that is actually part of the type system. </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> All the buzzt! <br>
 CornedBee <br>
<br>
 &quot;There is not now, 
nor has there ever been, nor will there ever be, any programming language in 
which it is the least bit difficult to write bad code.&quot;<br>
 - Flon's Law 
<br> </blockquote> <br>
</li> 
<li> 07-24-2009 #21 <br>
<strong> Elysia </strong> <br>
<br>
 
C++&#12414;&#12356;&#12427;&#65281;C&#12434;&#12371;&#12431;&#12379;&#65281; 
<dl> 
<dt> Join Date </dt> 
<dd> Oct 2007 </dd> 
<dt> Posts </dt> 
<dd> 19,912 </dd> </dl> 
<blockquote> <br>
 Originally Posted by <strong>Brafil</strong> <br>
 Why is 
this thread turning into &quot;OpenGL vs Direct3D&quot;?<br>
<br>
 Anyway, I 
think concepts are a good idea, but not a great one. I understand that they 
dropped them. Seems like they have understood that they were making the 
language too complex. There are so many things that are added, and I doubt 
there will be a complete reference for C++0x - The current ones for 
&quot;normal&quot; C++ are thick enough.<br>
<br>
 I personally don't like the 
new function definition types nor the new typedef possibilities.<br>
<br>
 But 
I love static_assert and many others.<br>
<br>
 And I don't know who will 
implement all this I think you have a negative outlook. <br>
 C++ is supposed 
to be a general purpose programming language, combining multiple paradigms.<br>

 Now, templates are difficult to master. Should we remove them to make the 
language easier to learn? I think not. Expert programmers should not have to 
suffer because newbies might have a difficult time grasping all concepts.<br>
 
Is there a single developer out there that knows the entire C# or Java Standard 
Library? Doubtful.<br>
 What I mean is that usually we strive to learn what it 
is we want to do and a language provides the facilities to do so. So you want 
to do OOP programming. Sure. Learn the OOP part.<br>
 So, you want to do 
Generic programming. Sure. Learn the generic part.<br>
<br>
 The new typedefs 
and the new function definition types enhances the parts that C++ specializes 
in. Making it easier and more powerful, even.<br>
 So I think it's a real shame 
they dropped Concepts, but I am very positive about every other added feature. 
</blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> <br>
 Originally Posted by <strong>Adak</strong> <br>
 io.h 
certainly IS included in some modern compilers. It is no longer part of the 
standard for C, but it is nevertheless, included in the very latest Pelles C 
versions.  Originally Posted by <strong>Salem</strong> <br>
 You mean it's 
included as a crutch to help ancient programmers limp along without them having 
to relearn too much.<br>
<br>
 Outside of your DOS world, your header file is 
meaningless. 
&#12424;&#12367;&#12365;&#12367;&#12364;&#12356;&#12356;&#65281;&#12431;&#12425;&#12431;&#12399;&#12390;&#12435;&#12373;&#12356;&#12384;&#12363;&#12425;&#12397;&#65281; 
^_^ <br>
</blockquote> <br>
</li> 
<li> 07-24-2009 #22 <br>
<strong> Brafil </strong> <br>
<br>
 Making mistakes 
<dl> 
<dt> Join Date </dt> 
<dd> Dec 2008 </dd> 
<dt> Posts </dt> 
<dd> 476 </dd> </dl> 
<blockquote> I don't blame. Many concepts are great: <br>
<br>
 constexpr, <br>
 rvalue references,<br>
 extern templates, <br>
 initializer lists, <br>
 auto 
variable,<br>
 decltype, <br>
 the new for-loops, <br>
 thread_local, <br>
 
regexes,<br>
 Suffixes - a nice &quot;toy&quot; that can be both very fun and 
useful<br>
<br>
 The things I would reconsider: <br>
 nullptr - It's not very 
elegant IMO. But I don't know a better way of doing it.<br>
 using instead of 
typedef. I didn't really grasp that.<br>
<br>
 Just a question: Isn't it 
possible to add template typedefs?<br>
 Just another question: can you have 
mixed initalizer lists (std::initializer_list&lt;int, char, double&gt;)?<br>

<br>  Now, templates are difficult to master. Should we remove them to make the 
language easier to learn? I think not. Expert programmers should not have to 
suffer because newbies might have a difficult time grasping all concepts. 
Never! Templates are a very important part of C++!<br>
<br>
 The only thing I 
didn't like was the added complexity for _compiler-writers_ and the possibility 
of misusing some concepts. Like always using the new function definitions - 
looks more like Pascal. The &quot;C&quot; way is one of the things I truly like 
about C/C++.<br>
<br>
 But the discussion was about concepts, right? Maybe 
they'll include them later. </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> <br>
</li> 
<li> 07-24-2009 #23 <br>
<strong> Elysia </strong> <br>
<br>
 
C++&#12414;&#12356;&#12427;&#65281;C&#12434;&#12371;&#12431;&#12379;&#65281; 
<dl> 
<dt> Join Date </dt> 
<dd> Oct 2007 </dd> 
<dt> Posts </dt> 
<dd> 19,912 </dd> </dl> 
<blockquote> <br>
 Originally Posted by <strong>Brafil</strong> <br>
 using 
instead of typedef. I didn't really grasp that. You declare template typedefs 
the same way you declare namespace aliases.<br>
<br>
 But the discussion was 
about concepts, right? Maybe they'll include them later. Maybe. We'll see in 
the future. </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> <br>
 Originally Posted by <strong>Adak</strong> <br>
 io.h 
certainly IS included in some modern compilers. It is no longer part of the 
standard for C, but it is nevertheless, included in the very latest Pelles C 
versions.  Originally Posted by <strong>Salem</strong> <br>
 You mean it's 
included as a crutch to help ancient programmers limp along without them having 
to relearn too much.<br>
<br>
 Outside of your DOS world, your header file is 
meaningless. 
&#12424;&#12367;&#12365;&#12367;&#12364;&#12356;&#12356;&#65281;&#12431;&#12425;&#12431;&#12399;&#12390;&#12435;&#12373;&#12356;&#12384;&#12363;&#12425;&#12397;&#65281; 
^_^ <br>
</blockquote> <br>
</li> 
<li> 07-24-2009 #24 <br>
<strong> <b>CornedBee</b> </strong> <br>
<br>
 Cat 
without Hat 
<dl> 
<dt> Join Date </dt> 
<dd> Apr 2003 </dd> 
<dt> Posts </dt> 
<dd> 8,762 </dd> </dl> 
<blockquote> <br>
 Originally Posted by <strong>Brafil</strong> <br>
 The 
things I would reconsider:<br>
 nullptr - It's not very elegant IMO. But I 
don't know a better way of doing it. What do you think are the problems of 
nullptr? I've played around with it (and I've implemented it) and I find it 
very intuitive.<br>
<br>
 using instead of typedef. I didn't really grasp that. 
<br> <br>
 Just a question: Isn't it possible to add template typedefs? The 
alias declarations with 'using' can do that, yeah. You can actually have a lot 
of fun with them. The reason we have 'using' instead of 'typedef' is, I think, 
mainly one of grammar. The way typedef works, I think it would be very hard to 
make template typedefs that don't look absolutely atrocious. In general, the 
new syntax is much nicer than the arcane C syntax.<br>
 Code: 
<pre>using INT = int; // Arcane: typedef void (*WhyIsTheNameHere)(int); // 
Logical: using ThisIsGood = void (*)(int); // Template: template &lt;typename 
T&gt; using SpecialVector = std::vector&lt;T, SpecialAllocator&lt;T&gt;&gt;; // 
Fun: template &lt;bool MutablePointer&gt; struct MetaFunction { using type = 
std::string; }; template &lt;&gt; struct MetaFunction&lt;true&gt; { using type 
= std::vector&lt;char&gt;; }; template &lt;bool MutablePointer&gt; using 
StringType = typename MetaFunction&lt;MutablePointer&gt;::type; 
StringType&lt;false&gt; this_is_a_std_string; Stringtype&lt;true&gt; 
this_is_a_char_vector;</pre>  Just another question: can you have mixed 
initalizer lists (std::initializer_list&lt;int, char, double&gt;)? Initializer 
lists can be heterogenous, and the compiler will interpret the elements as 
constructor arguments and do overload resolution. However, 
std::initializer_list can only represent homogenous initializer lists.<br>
 
Code: 
<pre>class A { A(int, float, std::string); }; class B { 
B(std::initializer_list&lt;int&gt;); }; A a{1, 1, &quot;hello&quot;}; B b{1, 2, 
3, 4, 5, 6, 7, 8, 9};</pre> </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> All the buzzt! <br>
 CornedBee <br>
<br>
 &quot;There is not now, 
nor has there ever been, nor will there ever be, any programming language in 
which it is the least bit difficult to write bad code.&quot;<br>
 - Flon's Law 
<br> </blockquote> <br>
</li> 
<li> 07-25-2009 #25 <br>
<strong> <b>VirtualAce</b> </strong> <br>
<br>
 Super 
Moderator 
<dl> 
<dt> Join Date </dt> 
<dd> Aug 2001 </dd> 
<dt> Posts </dt> 
<dd> 9,290 </dd> </dl> 
<blockquote> <br>
 Why is this thread turning into &quot;OpenGL vs 
Direct3D&quot;? It's not. <br>
<br>
 I was hoping the new standard would be 
finalized soon because the longer it takes the longer we have to wait for it to 
appear in compilers. It does seem to me that, based on the article, there have 
been some significant missteps. </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> Arrogance breeds bad code <br>
</blockquote> <br>
</li> 
<li> 07-25-2009 #26 <br>
<strong> Brafil </strong> <br>
<br>
 Making mistakes 
<dl> 
<dt> Join Date </dt> 
<dd> Dec 2008 </dd> 
<dt> Posts </dt> 
<dd> 476 </dd> </dl> 
<blockquote> Yeah, but anyone should agree it's not easy to design all that. 
So we should rather have called it C++1x. Some do so.<br>
<br>
 How about that: 
<br>  Code: 
<pre>template &lt;typename Type&gt; typedef Getter = const Type 
&amp;(*)(void); template &lt;typename Type&gt; typedef Setter = void (*)(const 
Type &amp;); Getter&lt;bool&gt; IsActive; Setter&lt;bool&gt; SetActive;</pre>  
So, just typedef instead of using? With the new syntax? I think that would be 
nice. </blockquote> 
<blockquote> Last edited by Brafil; 07-25-2009 at 02:18 AM. </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> <br>
</li> 
<li> 07-25-2009 #27 <br>
<strong> <b>CornedBee</b> </strong> <br>
<br>
 Cat 
without Hat 
<dl> 
<dt> Join Date </dt> 
<dd> Apr 2003 </dd> 
<dt> Posts </dt> 
<dd> 8,762 </dd> </dl> 
<blockquote> <br>
 So, just typedef instead of using? With the new syntax? I 
think that would be nice. As I said, it's a grammar problem. I know the 
internals of only one compiler, but I can tell that while it would be possible 
to modify it to parse this, it would lead to some very ugly code in the parser.
<br> The using keyword doesn't have as much grammatical cruft attached. 
</blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> All the buzzt! <br>
 CornedBee <br>
<br>
 &quot;There is not now, 
nor has there ever been, nor will there ever be, any programming language in 
which it is the least bit difficult to write bad code.&quot;<br>
 - Flon's Law 
<br> </blockquote> <br>
</li> 
<li> 07-25-2009 #28 <br>
<strong> Elysia </strong> <br>
<br>
 
C++&#12414;&#12356;&#12427;&#65281;C&#12434;&#12371;&#12431;&#12379;&#65281; 
<dl> 
<dt> Join Date </dt> 
<dd> Oct 2007 </dd> 
<dt> Posts </dt> 
<dd> 19,912 </dd> </dl> 
<blockquote> <br>
 Originally Posted by <strong>Brafil</strong> <br>
 Yeah, 
but anyone should agree it's not easy to design all that. So we should rather 
have called it C++1x. Some do so. I kinda agree. It would be far better if they 
incorporated less stuff in less timeframes so new standards can be released 
more often. It already takes a decade to figure out how to implement all this 
stuff since they meet so &quot;often.&quot; </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> <br>
 Originally Posted by <strong>Adak</strong> <br>
 io.h 
certainly IS included in some modern compilers. It is no longer part of the 
standard for C, but it is nevertheless, included in the very latest Pelles C 
versions.  Originally Posted by <strong>Salem</strong> <br>
 You mean it's 
included as a crutch to help ancient programmers limp along without them having 
to relearn too much.<br>
<br>
 Outside of your DOS world, your header file is 
meaningless. 
&#12424;&#12367;&#12365;&#12367;&#12364;&#12356;&#12356;&#65281;&#12431;&#12425;&#12431;&#12399;&#12390;&#12435;&#12373;&#12356;&#12384;&#12363;&#12425;&#12397;&#65281; 
^_^ <br>
</blockquote> <br>
</li> 
<li> 07-25-2009 #29 <br>
<strong> maxorator </strong> <br>
<br>
 Reverse 
Engineer 
<dl> 
<dt> Join Date </dt> 
<dd> Aug 2005 </dd> 
<dt> Location </dt> 
<dd> Estonia </dd> 
<dt> Posts </dt> 
<dd> 2,318 </dd> </dl> 
<blockquote> <br>
 Originally Posted by <strong>Elysia</strong> <br>
 I kinda 
agree. It would be far better if they incorporated less stuff in less 
timeframes so new standards can be released more often. It already takes a 
decade to figure out how to implement all this stuff since they meet so 
&quot;often.&quot; But then again, switching between languages often isn't good 
either. </blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> 
<blockquote> &quot;The Internet treats censorship as damage and routes around 
it.&quot; - John Gilmore <br>
</blockquote> <br>
</li> 
<li> 07-26-2009 #30 <br>
<strong> Brafil </strong> <br>
<br>
 Making mistakes 
<dl> 
<dt> Join Date </dt> 
<dd> Dec 2008 </dd> 
<dt> Posts </dt> 
<dd> 476 </dd> </dl> 
<blockquote> Ok. I understand now. As far as I know, using is only used for 
copying data into namespaces. And in C++0x, also into classes, right? 
</blockquote> 
<ul> 
<li>Share 
<ul> 
<li>Share this post on</li> 
<li>Digg</li> 
<li>Technorati</li> 
<li>Share on Facebook</li> 
<li>twitter</li> </ul> </li> </ul> <br>
</li> </ol> Page 2 of 3 First 1 2 3 
Last 
<ul> 
<li>Jump to page: </li> </ul> <strong>&laquo;</strong> Previous Thread | Next 
Thread <strong>&raquo;</strong> <b>Popular pages</b> 
<ul> 
<li>Exactly how to get started with C++ (or C) today </li> 
<li>C Tutorial </li> 
<li>C++ Tutorial </li> 
<li>5 ways you can learn to program faster </li> 
<li>The 5 Most Common Problems New Programmers Face </li> 
<li>How to set up a compiler </li> 
<li>8 Common programming Mistakes </li> 
<li>What is C++11? </li> 
<li>Creating a game, from start to finish </li> </ul> <b>Recent additions</b> 
<ul> 
<li>How to create a shared library on Linux with GCC - December 30, 2011</li> 
<li> Enum classes and nullptr in C++11 - November 27, 2011</li> 
<li>Learn about The Hash Table - November 20, 2011</li> 
<li>Rvalue References and Move Semantics in C++11 - November 13, 2011</li> 
<li>C and C++ for Java Programmers - November 5, 2011</li> 
<li>A Gentle Introduction to C++ IO Streams - October 10, 2011</li> </ul> 
<h4>Similar Threads</h4> 
<ol> 
<li> 
<h6>could any one help me in understanding the concepts of recursive fns.</h6> 
 By chaitanya in forum C Programming Replies: 5 Last Post: 08-31-2004, 06:41 PM 
<br> </li> 
<li> 
<h6>Programming concepts</h6>  By lyx in forum C++ Programming Replies: 2 Last 
Post: 12-02-2003, 11:37 PM <br>
</li> 
<li> 
<h6>Independent &amp; Effeciency :: Programming Concepts</h6>  By kuphryn in 
forum C++ Programming Replies: 5 Last Post: 06-08-2002, 05:08 AM <br>
</li> 
<li> 
<h6>Basic 2d Programming Concepts</h6>  By JoshG in forum Game Programming 
Replies: 4 Last Post: 05-17-2002, 05:54 AM <br>
</li> 
<li> 
<h6>Microsoft Fall?</h6>  By Sekti in forum A Brief History of Cprogramming.com
Replies: 5 Last Post: 02-25-2002, 03:21 PM <br>
</li> </ol> -- Normal Style -- 
Mobile Style-- Default Mobile Style <br>

<ul> 
<li>Contact Us</li> 
<li>C and C++ Programming at Cprogramming.com</li> 
<li>Archive</li> 
<li>Privacy Statement</li> 
<li>Top</li> </ul>  All times are GMT -6. The time now is 01:58 PM. <br>
 
Powered byvBulletin&reg; Version 4.1.11 <br>
Copyright &copy; 2012 vBulletin 
Solutions, Inc. All rights reserved.<br>
Search Engine Optimization by vBSEO 
3.6.0 <br>
<br>
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <br>

</body>