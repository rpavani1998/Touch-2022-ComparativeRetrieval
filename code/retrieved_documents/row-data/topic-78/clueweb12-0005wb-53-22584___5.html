<!doctype html>
<meta charset="utf-8">
<title>Computer Science II: Programming Abstractions  | Stanford Video Course</title>
<body>
<br>

<ul> 
<li>Welcome </li> 
<li>Favorites (0)</li> 
<li>Logout</li> 
<li> <br>
Username <br>
Password <br>
&nbsp;&nbsp;or&nbsp;&nbsp; Cancel <br>

</li> 
<li>Password Lookup</li> 
<li>Login</li> 
<li>Register</li> 
<li>Advanced Search</li> </ul> Academic Earth 
<ul> 
<li>Subjects</li> 
<li>Universities</li> 
<li>Instructors</li> 
<li>Playlists</li> 
<li>Courses for Credit</li> </ul> <br>
<br>
 searching... <br>
<br>
Home &gt; 
Courses &gt; Course Details <br>
<br>

<h1>Computer Science II: Programming Abstractions </h1> 
<h2> Julie Zelenski<br>
Stanford </h2> <br>
<br>
Tweet <br>
<br>

<h3>Course Description</h3> 
<p>Note: This course is being offered by Stanford this summer as an online 
course for credit. It can be taken individually, or as part of a master&rsquo;s 
degree or graduate certificate earned online through the Stanford Center for 
Professional Development.<br>
<br>
 This course is the natural successor to 
Programming Methodology and covers such advanced programming topics as 
recursion, algorithmic analysis, and data abstraction using the C++ programming 
language, which is similar to both C and Java. If you've taken the Computer 
Science AP exam and done well (scored 4 or 5) or earned a good grade in a 
college course, Programming Abstractions may be an appropriate course for you 
to start with, but often Programming Abstractions (Accelerated) is a better 
choice. Programming Abstractions assumes that you already have familiarity with 
good programming style and software engineering issues (at the level of 
Programming Methodology), and that you can use this understanding as a 
foundation on which to tackle new topics in programming and data abstraction.
<br> <br>
 Topics: Abstraction and its relation to programming. Software 
engineering principles of data abstraction and modularity. Object-oriented 
programming, fundamental data structures (such as stacks, queues, sets) and 
data-directed design. Recursion and recursive data structures (linked lists, 
trees, graphs). Introduction to time and space complexity analysis. Uses the 
programming language C++ covering its basic facilities.<br>
<br>
 
Prerequisites: Solid performance inProgramming Methodology and readiness to 
move on to advanced programming topics. A comparable introductory programming 
course (including high school AP courses) is often a reasonable substitute for 
our Programming Methodology.</p> 
<h3>Lectures</h3> 
<ol> 
<li> favorites 
<h4>Lecture 1 - About the Introduction to Computer Science Series at Stanford
</h4> 
<p>About the Introduction to Computer Science Series at Stanford, The 
Philosophy, Why take CS106B?, Logistics of the Course, Introducing C++</p> </li>
<li> favorites 
<h4>Lecture 2 - Similarity between C++ &amp; Java: - syntax - variable types - 
operators - control structures</h4> 
<p>Similarity between C++ &amp; Java: - syntax - variable types - operators - 
control structures, Looking at an Example C++ code: - comment, #include 
Statements, Global Declarations (constant), Declaring a Function Prototype, The 
main() Function, Decomposed Function Definition, Example Live Coding: To 
Calculate the Average, for loop -&gt; a while : Another Purpose of the Same 
Code, C++ User Defined Data Types: -enums -records, C++ Parameters Passing: 
-pass by value - pass by reference</p> </li> 
<li> favorites 
<h4>Lecture 3 - C++ Libraries - Standard Libraries</h4> 
<p>C++ Libraries - Standard Libraries, CS106 Libraries, CS106 random.h 
Library, C++ String Type, Operations on String Type, String Class' Member 
Functions, C++ string vs Java String, Live Example Code : Working on Strings, 
CS106 strutils.h Library, C++ String vs C String, Concatenation Pitfall (C++ vs 
C string cont.), C++ Console I/O</p> </li> 
<li> favorites 
<h4>Lecture 4 - C++ Console I/O</h4> 
<p>C++ Console I/O, C++ File I/O, Stream Operations, Live Example Coding : 
Working with Files, Live Coding Continuation: Function to Operate on the Opened 
File Stream, Passing the File Stream by Reference, Error Function, Class 
Libraries OO Features, Why OO is So Successful, CS106 Class Library, CS106: 
Scanner Library, Scanner Client Interface, Client Use of Scanner, Container 
Classes, Template Containers, Vector Interface</p> </li> 
<li> favorites 
<h4>Lecture 5 - Client Use of Templates</h4> 
<p>Client Use of Templates, Vector Class, Vector Client Interface, Client Use 
of Vector, Type-safety in Templates, Grid Class, Grid Client Interface, Client 
Use of Grid, Stack Class, Stack Client Interface, Queue Class, Queue Client 
Interface, Client Use of Queue, Nested Templates, Learning a New API, CS106B 
Library Documentation</p> </li> 
<li> favorites 
<h4>Lecture 6 - More Containers</h4> 
<p>More Containers, Map Class, Uses of Map, Map Client Interface, Live Coding 
Example: Use of Map, More information on Maps, What s Missing? Iterator 
Operation Through the Map, Iterating Over the Map, Set Class, Set Client 
Interface, Live Coding Example : Use of Set, Set Higher-level Operations, Why 
Set is Different</p> </li> 
<li> favorites 
<h4>Lecture 7 - Seeing Functions as Data: Specific Plot Functions</h4> 
<p>Seeing Functions as Data: Specific Plot Functions, Generic Plot Function, 
Back to the Set, Live Coding Example: Use of Set with User Defined Data Types, 
Client Callback Function, Review of the Classes Seen,5 Using Nested ADTs 
(Abstract Data Types), Live Coding Example, Recursion, Recursive Decomposition
</p> </li> 
<li> favorites 
<h4>Lecture 8 - Common Mistakes Stumbled Upon: 'I'terator</h4> 
<p>Stumbled Upon: 'I'terator, Common Mistakes Stumbled Upon: Concatenating 
Strings, Solving Problems Recursively, Functional Recursion, Example of 
Recursion: Calculating Raise to Power, Demo of &quot;Raise to the Power 
Example&quot; Through Live Coding, Mechanics of What s Going to Happen in 
Recursion, More Efficient Recursion, Being Wary of Too Many Base Cases, 
Recursion &amp; Efficiency, Example: Palindromes, Example: Binary Search, 
Binary Search Code Walk Through, Choosing a Subset; Choose Code</p> </li> 
<li> favorites 
<h4>Lecture 9 - Thinking Recursively</h4> 
<p>Thinking Recursively, Procedural vs Functional Recursion, Fractal Code, 
Live Demo: Fractal Example, Another Recursive Graphic: Mondrian Art, Random 
Pseudo-Mondrian and the Code, Hanois Towers : Classic Recursion Example, Tower 
Code, Live Demo, Permutations, Permute Code, Tree of Recursive Calls</p> </li> 
<li> favorites 
<h4>Lecture 10 - Refresh: Permute Code</h4> 
<p>Refresh: Permute Code, Tree of Recursive Calls, Live Demo: Testing with 
Different Cases, Eliminating Duplicates, Subsets, Subset Strategy, Subset Code, 
Tree of RecursiveCalls: Subset, Exhaustive Recursion, Recursive Backtracking, 
Turning Recursive Permute to Backtracking, Permute -&gt; Anagram Finder Code, 
Decision Problems: 8 Queens, Extension to N Queens</p> </li> 
<li> favorites 
<h4>Lecture 11 - Backtracking Pseudocode</h4> 
<p>Backtracking Pseudocode, Sudoku Solver, Sudoku Code, Cryptarithmetic, Dumb 
Solver, Smarter Solver, Looking for Patterns, Introduction to Pointers, Single 
Pointer Operations</p> </li> 
<li> favorites 
<h4>Lecture 12 - Pointer Movie</h4> 
<p>Pointer Movie, Pointer Operations: Code &amp; Pointer Memory Diagrams, 
Pointer Basics, Pointer and Dynamic Arrays, Use of Pointers, Recursive Data, A 
Recursive Structure, Live Demo: Working with Linked List, Building the List</p> 
</li> 
<li> favorites 
<h4>Lecture 13 - Coding with Linked List</h4> 
<p>Coding with Linked List, Printing the List, Using Recursion to Print List, 
De-allocating the Memory Used for the Linked List, Watch the Pointers: Prepend 
Function, Passing Pointers by Reference, Array vs Linked List, Insert in Sorted 
(order) Linked List, Insert in Sorted Order: Code, Recursive Insert</p> </li> 
<li> favorites 
<h4>Lecture 14 - Algorithm Analysis</h4> 
<p>Algorithm Analysis, Evaluating the Performance, Analysis of Codes: 
Statement Counts, Another Example (Statement Count Contd.), Comparing 
Algorithm, Big-O Notation, Big-O to Predict the Time of Execution, 
Best/Worst/Average Case, Analysis of Recursive Algorithms, Another Example : 
Towers of Hanoi, A Tabulation for Different Algorithms, Growth Patterns, 
Application of Algorithm Analysis to Sorting, Selection Sort, Selection Sort 
Code</p> </li> 
<li> favorites 
<h4>Lecture 15 - Selection Sort</h4> 
<p>Selection Sort, Live Demo: Working/execution of the Code, Selection Sort 
Analysis, Insertion Sort Algorithm, Live Demo: Working/execution of Insertion 
Sort, Insertion Sort Analysis, Insertion vs Selection, Quadratic Growth of the 
Algorithm, Merge Sort, Merge Sort: Working/execution Demo, Merge Sort Code 
Explanation, Merge Sort Analysis, Quadratic vs Linear Arithmetic, Sort 'Race', 
Quick Sort Idea</p> </li> 
<li> favorites 
<h4>Lecture 16 - Partitioning for Quicksort</h4> 
<p>Partitioning for Quicksort, Quicksort Code Working/execution, Quicksort 
Code, Live Demo: Running Quicksort vs Merge Sort, Bad Split Example, Worst Case 
Split, What Input has Worst Case for Quick Sort, Live Demo: Running Quicksort 
vs Merge Sort, Different Input Scenarios, Strategy to Avoid Worst Case Split, 
Execution Time Tabulation, Towards Generic Functions: Swap, Function Template, 
Example Live Code, Template Instantiation and its Errors, Sort Template, Client 
Use of Sort Template</p> </li> 
<li> favorites 
<h4>Lecture 17 - Sort Template with Callback</h4> 
<p>Sort Template with Callback, Supplying the Callback Function, One Last 
Convenience: Default Callback Function, Why Object Oriented Programming, Class 
Division, Class Interface in &quot;.h&quot; File, Storage for Objects, 
Accessing Members of a Class, Class Implementation, Implementing Member 
Functions, Maintaining Object Consistency, Constructors of a Class, Destructors 
of a Class, Basic Thoughts on Object Design, Internal vs External 
Representation: Idea of Encapsulation, Better Representation, ADTs (Abstract 
Data Types)</p> </li> 
<li> favorites 
<h4>Lecture 18 - Abstract Data Types</h4> 
<p>Abstract Data Types, Wall of Abstraction, Why ADTs?, Live Coding Example: 
Creating the Vector Class, Private Data Members, Growing Dynamically: Making 
Space at Runtime, Insert and Remove Functions, Templatizing the Class Created, 
Including the &quot;template.cpp&quot; - Why?</p> </li> 
<li> favorites 
<h4>Lecture 19 - Rules of Template Implementation</h4> 
<p>Rules of Template Implementation, Explanation of the Working, Not Allow 
Member Wise Copy, InsertAt Function, Consequences of Contiguous Memory Being a 
Disadvantage, Stack Class, The Member Function Definitions, Midterm Post Mortem
</p> </li> 
<li> favorites 
<h4>Lecture 20 - Live Coding: Recap of the Vector-based Implementation for 
Stack</h4> 
<p>Live Coding: Recap of the Vector-based Implementation for Stack, Linked 
List Implementation for Stack, Live Coding: Linked List Implementation for 
Stack, Analyzing Push/pop Functions, Queue Implementation, Live Coding: Queue 
Implementation, Alternative Implementation, Text Editor Case Study, Buffered 
Class Interface and Buffer Layered on Vector, Live Coding: Text Editor, 
Evaluate Vector Buffer, Buffer Layered on Stack, Live Demo, Compare 
Implementations, Buffer as Linked List</p> </li> 
<li> favorites 
<h4>Lecture 21 - Buffer: Vector vs Stack</h4> 
<p>Buffer: Vector vs Stack, Buffer as Linked List, Cursor Design, Use of Dummy 
Cell, Linked List Insert/delete, Linked List Cursor Movement, Compare 
Implementation, Doubly Linked List, Compare Implementation, Space Time Trade 
Off, Implementing Map, Simple Map Implementation: Vector, Map as Vector : 
Performance Implication, A Different Strategy</p> </li> 
<li> favorites 
<h4>Lecture 22 - Map as Vector</h4> 
<p>Map as Vector, A different Strategy: Binary Search Tree, Trees in General, 
Binary Search Tree for Numbers, Operating on Trees, Tree Traversals at Work, 
Implementing Map as Tree, Map - getValue(), Important Syntactical Advice, 
Adding to a BST, Trace treeEnter(), Passing Nodes by Reference, Evaluate Map as 
a Tree, Impact of the Height of the Tree, Degenerate Trees, What to do About 
Unbalanced Trees?</p> </li> 
<li> favorites 
<h4>Lecture 23 - Pathfinder Demo</h4> 
<p>Pathfinder Demo, Graphs: Examples, Graphs: Explanation, Implementation 
Strategies, Graph Representation in C++, Nodes and Arcs in C++, Graph 
Traversals, DFS - (Depth First Search), Trace DfS, BFS - (Breadth First 
Search), Trace BFS, Graph Search Algorithms, Weighted arcs</p> </li> 
<li> favorites 
<h4>Lecture 24 - Compare Map Implementations</h4> 
<p>Compare Map Implementations, Hashtable Idea, Hash Functions, Hash 
Collisions, Live Demo: Hashing, Live Coding: Hashing, Hashing Idea : Example in 
Real World, Hash Table Performance, Compare Map Implementations, Hashing 
Generic Types, Implementing Set</p> </li> 
<li> favorites 
<h4>Lecture 25 - Lexicon Case Study</h4> 
<p>Lexicon Case Study, Lexicon as Sorted Vector, Lexicon as BST, Lexicon as 
Hash Table, Summary so Far, Noticing Patterns/repetitions in the Words, Letter 
Trie, Lexicon as Trie, Dynamic Array of Children, Flatten Tree into Array, 
Exploiting Prefixes and Suffixes, DAWG: Directed Acyclic Word Graph, Lexicon as 
DAWG, The Final Result, Cool Facts about the DAWG</p> </li> 
<li> favorites 
<h4>Lecture 26 - Final Showdown</h4> 
<p>Final Showdown, Thinking About Design, Runtime Performance, Memory Used, 
Code Complexity, Making Tradeoffs, Array vs Vector, Stack/Queue vs Vector, Set 
vs Sorted Vector, Pointer-based vs. Contiguous Memory, CS106B MVPs, Pointers, 
To Remember Years from Now, After CS106B, considering.cs</p> </li> 
<li> favorites 
<h4>Lecture 27 - About the C++ Language, Quick History of C++, C++ Philosophy
</h4> 
<p>Guest Lecturer: Keith Schwarz, About the C++ Language, Quick History of 
C++, C++ Philosophy, C++ Without genlib.h, A Working genlib.h Replacement, 
Other CS106 Headers, strutils.h, simpio.h, random.h, graphics.h/extrgraph.h, 
What about ADTs?, Standard Template Library, STL Algorithms, Language Features, 
Operator Overloading, What Next?</p> </li> </ol> 
<h3>Course Details</h3> 
<p> Source: Stanford Engineering Everywhere<br>
 License: </p> 
<h3>Subscribe as Podcast</h3> 
<ul> 
<li>Audio Podcast in iTunes</li> 
<li>Video Podcast in iTunes</li> 
<li>Audio via RSS</li> 
<li>Video via RSS</li> </ul> 
<h3>Related Resources</h3> 
<ul> 
<li>Practice Final </li> </ul> 
<h3>Related Courses</h3> 
<ol> 
<li> <br>

<h4>Introduction to Algorithms</h4> MIT / Computer Science <br>
Charles E. 
Leiserson <br>
</li> 
<li> <br>

<h4>Computer Science I: Programming Methodology</h4> Stanford / Computer 
Science <br>
Mehran Sahami <br>
</li> 
<li> <br>

<h4>Computer Science III: Programming Paradigms </h4> Stanford / Computer 
Science <br>
Jerry Cain <br>
</li> </ol> 
<h3>Editor&rsquo;s Picks</h3> 
<ol> 
<li> 
<h3>Prototyping the Mouse</h3> 
<h4>Stanford /  Entrepreneurship </h4> 
<h5> David Kelley<br>
</h5> </li> 
<li> 
<h3>Paul as Pastor</h3> 
<h4>Yale /  Literature </h4> 
<h5> Dale B Martin<br>
</h5> </li> 
<li> 
<h3>Stock market simulation</h3> 
<h4>MIT /  Computer Science </h4> 
<h5> Eric Grimsom<br>
John Guttag<br>
</h5> </li> 
<li> 
<h3>An Angel Investor's Strategic Advice for the Start-Up</h3> 
<h4>Stanford /  Entrepreneurship </h4> 
<h5> Ron Conway<br>
Mike Maples Jr.<br>
</h5> </li> 
<li> 
<h3>What Is It Like to Be a Baby: The Development of Thought</h3> 
<h4>Yale /  Psychology </h4> 
<h5> Paul Bloom<br>
</h5> </li> </ol> 
<p> About Us&nbsp;&nbsp;|&nbsp;&nbsp; Contact&nbsp;&nbsp;|&nbsp;&nbsp; Privacy 
Policy&nbsp;&nbsp;|&nbsp;&nbsp; Terms of Use&nbsp;&nbsp;|&nbsp;&nbsp; FAQ
&nbsp;&nbsp;</p> 
<p>&copy; 2012 Academic Earth. All rights reserved.</p> 
<p> Resources From Our Friends:&nbsp;&nbsp;Open Culture
&nbsp;&nbsp;|&nbsp;&nbsp;Grockit </p> <br>

</body>